[{"title":"置顶公告","url":"/Blog/posts/25ad5f96/","content":"关于新版本网站的公告（其实是笨蛋亓翎的谢罪函）大家好，这里跟大家说明一下网站的新版本情况。\n因为之前亓翎在整理&#x2F;维护网站时不小心把网站的原始结构数据整个误删了，导致旧版本的数据出现了比较大的缺口。现在手头能留下来的内容，主要是一些零散的存档（并不是完整站点），还有就是Hexo的生成文件，很多页面之间的关联、分类、时间线、链接结构之类的信息都丢失了。也正因为这样，旧版想要“一键恢复”基本不现实，要恢复的话只能靠后续一点点整理、核对、重建，工作量和难度都会比较高。\n考虑到网站不能一直停着不更新，也不想让大家一直看到缺内容、打不开的页面，所以我决定把网站直接重构，先把新版本的框架搭起来。新版本会以更清晰、也更好维护的方式重新整理结构，这样后面更新内容、修复问题、补充功能都会更顺手，也能减少类似情况再次发生的概率。\n关于大家比较关心的“以前的文章还会不会回来”：会的，但可能需要时间。我会根据现有存档的情况，优先把能确定内容完整、整理成本相对低的文章先恢复出来；剩下比较零碎、需要补齐信息或重新排版的内容，会在后续慢慢补。恢复进度可能不会特别快，但会持续推进。也就是说，旧内容不是“没了”，而是需要一个逐步找回、逐步整理的过程。\n这次的情况给大家带来不便真的很抱歉，也谢谢大家一直以来的理解和支持。如果你发现新版本里有链接失效、排版问题，或者你记得某篇旧文但现在找不到，也欢迎提醒我（有线索会更好，比如标题、关键词、发布时间大概范围等），我会尽量安排处理。\n总之：新版本先保证稳定可用，旧内容会陆续回归。谢谢大家，敬请期待后续更新。（我这次也是对内容做了原始数据的备份，长教训了）\n","categories":["Announcement"],"tags":["Announcement"]},{"title":"FileLocksmith-单文件版本","url":"/Blog/posts/5d98e7ac/","content":"File Locksmith 是用于定位并解除文件&#x2F;文件夹占用的工具。\n项目信息\n原始项目仓库：https://github.com/microsoft/PowerToys\n拆分自 PowerToys 0.97.1 的 File Locksmith\n目标环境：Windows 11 24H2 26100.7623\n\n下载方式一：下载发布包（推荐）Releases：https://github.com/RE-TikaRa/FileLocksmith/releases\n\nFileLocksmith Portable version：自带依赖，开箱即用，体积更大  \nFileLocksmith System dependency versions：不带运行库，体积更小，需要系统已安装依赖  \n依赖：Windows App SDK Runtime、VC++ 运行库、WebView2 Runtime\n\n\n\n方式二：获取源码用于自行构建或二次开发：\ngit clone https://github.com/RE-TikaRa/FileLocksmith.git\n\n界面预览首页\n设置页\n关于页\n功能概览\n右键菜单：快速定位占用文件&#x2F;文件夹的进程并处理\n扫描界面：展示占用进程、文件列表，可结束进程\n管理主界面：统一管理注册状态与显示方式\n支持“仅扩展菜单显示”（Win11“显示更多选项”）\n支持提升权限完成注册&#x2F;卸载与系统进程查看\n\n运行方式\n直接运行：启动管理主界面\n从右键菜单启动：进入扫描&#x2F;解锁界面\nCLI：FileLocksmithCLI.exe\n\n依赖说明\n本项目已尽量对关键依赖进行本地化与版本固定，以降低外部环境变化带来的不确定性。但由于 Windows SDK、运行库与系统环境差异较大，仍可能出现未覆盖的构建或运行问题。本地化范围主要包含仓库内置的 C++ 依赖（如 deps/spdlog、deps/expected-lite）以及明确的 NuGet 版本锁定。仍需在线还原的依赖以 Directory.Packages.props&#x2F;packages.config 为准。如遇异常，请提交 issue 并附上系统版本、构建日志或崩溃日志，便于定位与完善。\n\n构建环境\n\nWindows 11 + Visual Studio 2022（Build Tools 或 Professional，含 C++ 工具集与 MSBuild）\n.NET SDK 9（TargetFramework: net9.0-windows10.0.26100.0）\nWindows 11 SDK（WindowsSdkPackageVersion: 10.0.26100.68-preview）\nPowerShell 5+（便携包脚本）\n\n核心依赖（NuGet&#x2F;源码）\n\nWindows App SDK 1.8.251106002\nC#&#x2F;WinRT Microsoft.Windows.CsWinRT 2.2.0\nC++&#x2F;WinRT Microsoft.Windows.CppWinRT 2.0.240111.5\nWIL Microsoft.Windows.ImplementationLibrary 1.0.231216.1\nUI 组件：CommunityToolkit.WinUI.*、WinUIEx\nC++ 依赖（仓库内置）：deps/spdlog、deps/expected-lite\n\n运行时依赖\n\nWindows App SDK Runtime（便携包内会自带）\nVC++ 运行库（便携包脚本会尝试复制）\nWebView2 Runtime（WinUI WebView2）\n\n配置与数据位置（独立路径）根目录%LocalAppData%\\\\ALp_Studio\\\\FileLocksmith\n设置文件file-locksmith-settings.json\n\nEnabled：是否启用\nshowInExtendedContextMenu：仅扩展菜单显示\n\n运行数据last-run.log：上次选择路径列表（UTF-16 + 换行，空行终止）\n日志\n\nLogs\\\\log.log（原生日志）\nLogs\\\\Log_YYYY-MM-DD.log（托管日志）\n不再使用版本子目录，历史的 Logs\\\\&lt;版本&gt; 可删除。\n\n\n\n组策略（GPO）管理员可通过策略强制启用&#x2F;禁用：\nHKLM\\\\Software\\\\Policies\\\\FileLocksmith\n\nEnabled（DWORD）：1 启用，0 禁用若存在该键值，将覆盖本地设置。\n\n注册表标记（状态）用于记录右键菜单注册状态（脚本写入）：\nHKCU\\\\Software\\\\FileLocksmith\n\nContextMenuRegistered（DWORD）\n\nCLI 使用FileLocksmithCLI.exe [选项] &lt;路径1&gt; [路径2] ...选项:  --kill      结束占用文件的进程  --json      以 JSON 格式输出结果  --wait      等待文件解锁  --timeout   --wait 的超时（毫秒）  --help      显示帮助\n\n结构速览\nsrc/modules/FileLocksmith/FileLocksmithUI\n管理主界面与 WinUI 视图\n\n\nsrc/modules/FileLocksmith/FileLocksmithContextMenu\n右键菜单（Win11）\n\n\nsrc/modules/FileLocksmith/FileLocksmithExt\n右键菜单（经典）\n\n\nsrc/modules/FileLocksmith/FileLocksmithLib\n原生核心逻辑（句柄枚举&#x2F;扫描）\n\n\nsrc/modules/FileLocksmith/FileLocksmithLibInterop\n原生互操作层（WinRT）\n\n\nsrc/modules/FileLocksmith/FileLocksmithCLI\n命令行与单元测试\n\n\ntools/FileLocksmithPortable\n便携版打包脚本\n\n\n\n构建与打包项目使用 WinUI 3 + Windows App SDK（.NET 9 目标）。\n输出目录\n\nUI：x64/Release/WinUI3Apps\nCLI：x64/Release/FileLocksmithCLI.exe\n便携包（自带依赖）：artifacts/FileLocksmith Portable version/x64/Release\n便携包（系统依赖）：artifacts/FileLocksmith System dependency versions/x64/Release\n\n快捷脚本\n\n仅构建 UI：build_project.bat\n构建 + 便携版打包：build_and_pack.bat（输出 Portable&#x2F;System 两个版本）\n\n清理缓存（推荐在重新构建前执行）\n\n删除 x64/\n删除 artifacts/FileLocksmith Portable version/\n删除 artifacts/FileLocksmith System dependency versions/\n删除 src/**/bin 与 src/**/obj\n删除旧版日志子目录 Logs\\\\&lt;版本&gt;（如果仍存在）\n\n构建 UI（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithUI/FileLocksmithUI.csproj /restore /p:Configuration=Release /p:Platform=x64 /p:RunAnalyzers=false /p:RunCodeAnalysis=false /p:EnableNETAnalyzers=false /p:EnforceCodeStyleInBuild=false /p:TreatWarningsAsErrors=false\n\n构建 CLI（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithCLI/FileLocksmithCLI.vcxproj /p:Configuration=Release /p:Platform=x64\n\n构建原生组件（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithLib/FileLocksmithLib.vcxproj /p:Configuration=Release /p:Platform=x64&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithLibInterop/FileLocksmithLibInterop.vcxproj /p:Configuration=Release /p:Platform=x64\n\n构建右键菜单组件（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithContextMenu/FileLocksmithContextMenu.vcxproj /p:Configuration=Release /p:Platform=x64&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithExt/FileLocksmithExt.vcxproj /p:Configuration=Release /p:Platform=x64\n\nCLI 与原生项目（可选）\n\n使用 Visual Studio 2022 打开对应 .vcxproj，选择 x64 构建。\n\n便携包powershell -ExecutionPolicy Bypass -File tools\\\\FileLocksmithPortable\\\\pack.ps1 -Platform x64 -Configuration Release -Mode Portablepowershell -ExecutionPolicy Bypass -File tools\\\\FileLocksmithPortable\\\\pack.ps1 -Platform x64 -Configuration Release -Mode System\n\n便携版构建&#x2F;打包常见问题\n\n输出目录为空：pack.ps1 依赖 x64/Release/WinUI3Apps。请先构建 UI，再打包。\nSystem 模式找不到 WinUI3Apps.System：请先执行 build_and_pack.bat 或用相同参数构建 System 版本 UI。\n便携版点击关于&#x2F;设置闪退（MUI 资源缺失）：若输出目录缺少 FileLocksmithXAML、Assets 或语言目录（如 zh-CN），WinUI 资源加载会崩溃。pack.ps1 已改为复制 WinUI3Apps 下所有子目录，若仍异常请重新构建并打包。\nSystem dependency versions 启动失败：请确认系统已安装 Windows App SDK Runtime、VC++ 运行库与 WebView2 Runtime。\n\n其他文档\ntools/FileLocksmithPortable/README.md：便携版打包与使用说明\nsrc/common/Telemetry/README.md：Telemetry 采集说明（排查&#x2F;性能）\nsrc/common/CalculatorEngineCommon/README.md：exprtk 封装说明（共享库）\ndeps/spdlog/README.md：第三方日志依赖说明\n同目录下 *.Original.md 为上游&#x2F;历史说明备份（PowerToys 官方说明）\n\n作者与信息\n创建日期：2026-01-29\n制作者：亓翎_Re-TikaRa\n网站：https://re-tikara.fun\n\n许可本项目遵循 PowerToys 仓库的原始许可，即 MIT 许可，详见仓库根目录 LICENSE。\n免责声明本项目为开源研究与学习用途的软件分支，按“现状”提供，不对适用性、稳定性或特定用途做任何保证。使用本项目进行文件占用解除、进程终止、右键菜单注册&#x2F;卸载等操作可能影响系统或数据，请自行确认风险并对操作结果负责。\n","categories":["Project"],"tags":["project"]},{"title":"Certificate-Management","url":"/Blog/posts/6c20921f/","content":"\n  \n  荣誉证书管理系统\n  \n    一款功能完整、界面精美的荣誉证书管理桌面应用。\n    支持荣誉证书的全生命周期管理：从录入、统计分析、成员管理到附件管理，一应俱全。\n    当前版本： v1.4.0（2025-12-18）\n  \n\n\n\n\n\n  📖 目录导航 (点击展开)\n\n\n✨ 核心特性\n🎯 功能详情\n\n\n🛠️ 技术栈\n📸 界面预览\n🚀 快速开始\n📥 安装步骤\n🛠️ 常用命令\n🧾 AI 证书识别\n⚙️ 配置与模型\n🧾 使用流程\n\n\n📥 导入 &#x2F; 导出（CSV&#x2F;XLSX）\n🤖 MCP 接入（本地）\n🔌 连接方式\n🛡️ 权限与安全\n🛠️ 能力概览\n⚙️ 常用环境变量\n\n\n\n\n📂 文件目录说明\n🏗️ 项目架构\n💾 数据模型\n🏆 荣誉记录 (Awards)\n🧩 荣誉成员快照 (AwardMembers)\n👤 参与成员 (TeamMembers)\n🤖 AI 提供商 (AIProviders)\n🏷️ 自定义开关 (CustomFlags&#x2F;AwardFlagValues)\n🎓 专业与学校 (Majors&#x2F;Schools)\n\n\n🔐 数据安全与备份\n🎨 主题系统\n🛠️ 开发指南\n🧰 故障排查\n📝 更新日志\nv1.4.0 (2025-12-18)\nv1.3.1 (2025-12-17)\nv1.3.0 (2025-12-16)\nv1.2.0 (2025-12-14)\nv1.1.0 (2025-12-09 ~ 2025-12-10)\nv1.0.1 (2025-12-04 ~ 2025-12-07)\nv1.0.0 (2025-12-02 ~ 2025-12-03)\n\n\n📈 Star History\n🤝 如何贡献\n📄 许可证\n\n\n\n\n✨ 核心特性\n  \n    \n      \n        ⚡ 极速检索\n        500ms 防抖全文检索FTS5 引擎加持\n      \n      \n        📊 数据可视化\n        8 张动态指标卡图表实时联动\n      \n      \n        🧭 丝滑体验\n        页面异步懒加载启动速度飞快\n      \n      \n        🛡️ 数据安全\n        本地 SQLite 存储自动定时备份\n      \n    \n    \n      \n        🧠 智能补全\n        专业/学院自动匹配支持拼音/代码搜索\n      \n      \n        🗑️ 后悔药\n        回收站机制双重删除确认\n      \n      \n        🎨 炫彩主题\n        深色/浅色模式一键实时切换\n      \n      \n        🛠️ 运维工具\n        一键清理日志/备份数据库维护工具\n      \n    \n  \n\n\n🎯 功能详情\n首页: 快速导航与最近动态，一键直达常用功能。\n仪表盘: 8 个梯度指标卡 + 饼&#x2F;柱图可视化 + 最近荣誉速览。\n总览: FTS5 全文搜索（比赛名&#x2F;证书号&#x2F;成员）+ 筛选排序分页，支持编辑与批量操作。\n录入: 卡片式表单，多成员动态管理；集成专业&#x2F;学校智能搜索（中文&#x2F;拼音&#x2F;代码）；支持一键 AI 识别证书（图片&#x2F;PDF）。\n成员管理: 成员库维护与详情，10 字段监控与快速修改。\n回收站: 已删除记录可恢复&#x2F;彻底删除，双重确认。\n系统设置: 主题&#x2F;备份&#x2F;日志&#x2F;索引维护与清理工具，自定义开关管理，导入模板下载；AI 与 MCP 配置入口。\nMCP 接入: 内置本地 MCP（stdio&#x2F;SSE）与可选 Web 控制台，默认只读，支持 PII 脱敏与写入开关。\n\n\n🛠️ 技术栈\n\n\n\n\n核心框架\n数据存储\n工具链\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAI 证书识别：OpenAI 兼容 API（Chat Completions&#x2F;Responses）+ PyMuPDF（PDF 渲染）+ Pydantic（结构化解析）\nMCP：mcp（FastMCP），支持 stdio&#x2F;SSE；可选 gradio Web 控制台\n日志：loguru（应用日志与 MCP 进程日志输出到 logs/）\n类型检查：pyright（标准模式）+ ruff（风格&#x2F;未使用项）\n\n\n📸 界面预览\n💡 提示: 点击图片可查看大图\n\n\n  \n    \n      \n        \n        🏠 首页快速导航与最近动态\n      \n      \n        \n        📊 仪表盘指标卡 + 统计图表\n      \n    \n    \n      \n        \n        👀 总览页FTS5 搜索 + 筛选排序\n      \n      \n        \n        📝 录入页成员卡片式表单 + AI 识别\n      \n    \n    \n      \n        \n        👥 成员管理10 字段监控与详情\n      \n      \n        \n        ⚙️ 设置页主题/备份/清理/日志\n      \n    \n  \n\n\n\n🚀 快速开始📥 安装步骤\n克隆仓库\ngit clone https://github.com/RE-TikaRa/Certificate-Management.gitcd Certificate-Management\n\n安装依赖 (推荐使用 uv)\n# 安装 uv (如果尚未安装)# pip install uv# 同步环境uv sync\n\n启动应用\n# Windows 快捷启动./main.bat# 或使用 uv 启动uv run python -m src.main\n\n🛠️ 常用命令\n\n\n操作\n命令\n说明\n\n\n\n运行\nuv run python -m src.main\n启动主程序\n\n\n调试\nuv run python -m src.main --debug\n开启调试日志\n\n\n检查\nuv run ruff check .\n代码 Lint 检查\n\n\n格式化\nuv run ruff format .\n代码自动格式化\n\n\n类型检查\nuv run python -m pyright\nPyright 标准模式\n\n\n语法检查\nuv run python -m py_compile src/\n基础语法编译检查\n\n\nMCP 服务\nuv run certificate-mcp\n启动 MCP（默认 stdio，只读）\n\n\nMCP SSE\nCERT_MCP_TRANSPORT=sse uv run certificate-mcp\n启动 SSE（默认 http://127.0.0.1:8000/sse；推荐用设置页随软件启动）\n\n\nMCP Web\nuv run certificate-mcp-web\n启动本地 Web 控制台（需安装可选依赖；默认 http://127.0.0.1:7860）\n\n\n\n🧾 AI 证书识别AI 证书识别用于“荣誉录入”页面的一键识别：从证书图片&#x2F;PDF 自动抽取 比赛名称、获奖日期、赛事级别、奖项等级、证书编号、成员姓名，并在预览对话框中确认后再写入表单。\n⚙️ 配置与模型\n打开 系统设置 → AI 证书识别，勾选“启用 AI 证书识别”\n配置一个提供商（Provider）\nAPI 地址：OpenAI 兼容地址（如 https://api.openai.com 或你的兼容中转）\nAPI Key：支持多 Key，程序会按请求轮换（见下文）\n模型：可手动填写模型 ID；若你的服务支持 /v1/models，可在设置页刷新&#x2F;选择\nPDF 页数：1~10（PDF 会渲染前 N 页作为图片参与识别）\n\n\n点击“测试联通”验证配置（会发起最小请求）\n\n说明（按当前实现）：\n\n支持文件：.pdf .png .jpg .jpeg .webp\nKey 轮换：每次调用（识别证书、刷新模型、测试联通）都会轮到下一个 Key；当前不会在失败时自动切 Key 重试\nOpenAI 官方 api.openai.com：会走 responses 接口；PDF 会以文件方式上传，图片会以单张图片方式上传\n兼容服务：走 /v1/chat/completions；PDF 会按“PDF 页数”渲染多页图片后发送\n\n🧾 使用流程\n在 荣誉录入 页点击顶部“AI 识别证书”\n选择证书文件后，程序会自动将其加入附件并开始识别\n在“AI 识别预览”中确认&#x2F;修改结果后应用到表单\n\n\n📥 导入 &#x2F; 导出（CSV&#x2F;XLSX）\n入口：系统设置 → 导入&#x2F;导出\n导入：支持 CSV&#x2F;XLSX；表头需与模板一致；可选字段 附件路径（用 ; 分隔多个文件的绝对路径）\n导出：导出文件包含 附件数量 与 附件路径；若要回导请确保附件文件在原路径可访问（跨机器需自行拷贝并修正路径）\n\n\n🤖 MCP 接入（本地）本项目内置了 MCP (Model Context Protocol) 服务，允许 AI Agent（如 Claude Desktop、Cursor 等）安全地读取本地荣誉数据与附件。\n🔌 连接方式\nstdio 模式（推荐）\n\n适用场景：本地客户端直接拉起进程（无需占用端口）。\n启动命令：uv run certificate-mcp\n配置示例：见下文“客户端配置示例”。\n\n\nSSE 模式（HTTP 服务）\n\n适用场景：本机调试（HTTP）。\n地址：http://127.0.0.1:8000/sse\n启动方式：\n自动（推荐）：在“设置页 → MCP 服务”中开启“随软件启动 MCP”。\n手动：CERT_MCP_TRANSPORT=sse uv run certificate-mcp\n\n\n日志：logs/mcp_sse.log\n注意：服务端强制本地绑定，CERT_MCP_HOST 只能是 127.0.0.1 &#x2F; localhost &#x2F; ::1，请勿暴露到公网。\n\n\nWindows PowerShell 手动启动命令\n\n$env:CERT_MCP_TRANSPORT = &quot;sse&quot;$env:CERT_MCP_HOST = &quot;127.0.0.1&quot;$env:CERT_MCP_PORT = &quot;8000&quot;uv run certificate-mcp\n\n\nWeb 控制台（调试用）\n\n功能：提供一个 Web 界面来测试 MCP 工具调用。\n安装：uv sync --group mcp-web（或在设置页点击安装）。\n启动：uv run certificate-mcp-web（默认访问 http://127.0.0.1:7860）。\n说明：无登录，仅用于本机调试；如关闭后端口仍占用见“故障排查”。\n\n\n\n🛡️ 权限与安全\n默认只读：默认不允许写入数据库或修改文件。如需开启写入（仅限本地），请在设置页勾选或设置环境变量 CERT_MCP_ALLOW_WRITE=1。\n隐私保护：默认开启 PII 脱敏（CERT_MCP_REDACT_PII=1），自动隐藏身份证号与手机号中间位。\n附件限额：单次读取附件最大 1MB（可配置 CERT_MCP_MAX_BYTES）。\n网络安全：服务默认绑定 127.0.0.1，请勿暴露到公网。\n\n🛠️ 能力概览\nTools (工具)：\nlist_awards &#x2F; get_award &#x2F; search_awards：查询荣誉记录。\nlist_members &#x2F; get_member：查询成员信息。\nread_attachment：读取附件内容（支持文本提取）。\nhealth：健康检查。\n\n\nResources (资源)：\ndocs://readme &#x2F; docs://agents：读取项目 README&#x2F;AGENTS 指南。\nschema://models：查看数据库模型定义。\ntemplates://awards_csv：获取导入模板。\n\n\n\n⚙️ 常用环境变量\n\n\n变量名\n说明\n默认值\n\n\n\nCERT_MCP_TRANSPORT\n传输模式 (stdio&#x2F;sse)\nstdio\n\n\nCERT_MCP_HOST\nSSE Host（仅允许本地）\n127.0.0.1\n\n\nCERT_MCP_PORT\nSSE 端口\n8000\n\n\nCERT_MCP_ALLOW_WRITE\n允许写入 (0&#x2F;1)\n0\n\n\nCERT_MCP_REDACT_PII\n敏感信息脱敏 (0&#x2F;1)\n1\n\n\nCERT_MCP_MAX_BYTES\n单次附件读取上限（字节）\n1048576\n\n\nCERT_MCP_DEBUG\n输出调试错误细节 (0&#x2F;1)\n0\n\n\nCERT_MCP_WEB_HOST\nWeb 控制台 Host\n127.0.0.1\n\n\nCERT_MCP_WEB_PORT\nWeb 控制台端口\n7860\n\n\nCERT_MCP_WEB_INBROWSER\n是否自动打开浏览器 (0&#x2F;1)\n1\n\n\n\n📎 客户端配置示例 (Claude Desktop / Cursor)\n\nstdio 模式 (推荐)：\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;certificate&quot;: &#123;      &quot;command&quot;: &quot;uv&quot;,      &quot;args&quot;: [&quot;run&quot;, &quot;certificate-mcp&quot;],      &quot;env&quot;: &#123;        &quot;CERT_MCP_ALLOW_WRITE&quot;: &quot;0&quot;,        &quot;CERT_MCP_REDACT_PII&quot;: &quot;1&quot;      &#125;    &#125;  &#125;&#125;\n\nSSE 模式：\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;certificate&quot;: &#123;      &quot;type&quot;: &quot;sse&quot;,      &quot;url&quot;: &quot;http://127.0.0.1:8000/sse&quot;    &#125;  &#125;&#125;\n\n\n\n📂 文件目录说明\n点击展开完整目录树\n\nCertificate-Management/├── 📄 README.md                    # 项目文档├── ⚙️ pyproject.toml               # 依赖配置├── 🔒 uv.lock                      # 依赖锁定├── 🚀 main.bat                     # Windows 启动脚本├── 🚫 .gitignore                   # Git 忽略规则├── 🧰 tools/                       # 开发辅助脚本（可选）│├── 📦 src/                         # 源代码│   ├── 🏁 main.py                  # 入口文件│   ├── 🌍 app_context.py           # DI 容器│   ├── ⚙️ config.py                # 配置加载│   ├── 📝 logger.py                # 日志配置│   ├── 🤖 mcp/                     # MCP 模块（本地）│   │   ├── server.py               # MCP 服务端（默认只读）│   │   ├── web.py                  # MCP 本地 Web 控制台（可选）│   │   ├── helpers.py              # MCP 配置/解析辅助│   │   └── runtime.py              # MCP 进程/自启动管理（本地）│   ││   ├── 💾 data/                    # 数据层│   │   ├── models.py               # SQLAlchemy 模型│   │   └── database.py             # 数据库会话│   ││   ├── 🔧 services/                # 业务层│   │   ├── award_service.py        # 荣誉逻辑│   │   ├── statistics_service.py   # 统计分析│   │   ├── import_export.py        # 导入导出│   │   ├── ai_certificate_service.py # AI 证书识别（OpenAI 兼容 API）│   │   ├── ai_provider_service.py  # AI Provider / Key 轮换│   │   ├── attachment_manager.py   # 附件存储/去重/回收站│   │   ├── backup_manager.py       # 备份/验证/恢复（含定时任务）│   │   ├── flag_service.py         # 自定义布尔开关（flag）│   │   └── ...│   ││   ├── 🎨 ui/                      # 表现层│   │   ├── main_window.py          # 主窗口│   │   ├── styled_theme.py         # 主题管理│   │   ├── pages/                  # 各功能页面│   │   └── widgets/                # 自定义组件│   ││   └── 📂 resources/               # 静态资源│       ├── styles/                 # QSS 样式│       └── templates/              # 导入模板│├── 📂 data/                        # 数据库存储 (自动生成)├── 📂 attachments/                 # 附件存储├── 📂 backups/                     # 自动备份├── 📂 logs/                        # 运行日志└── 📂 docs/                        # 文档与参考数据\n\n\n\n🏗️ 项目架构flowchart TD    subgraph UI [表现层 Presentation]        direction TB        MainWindow[主窗口 MainWindow]        Pages[页面 Pages]        Widgets[组件 Widgets]        Theme[主题 ThemeManager]    end    subgraph Service [业务层 Business Logic]        direction TB        AwardSvc[荣誉服务 AwardService]        StatSvc[统计服务 StatisticsService]        BackupSvc[备份服务 BackupManager]        ImportSvc[导入服务 ImportExport]        AttachSvc[附件服务 AttachmentManager]        FlagSvc[开关服务 FlagService]        AISvc[AI 证书识别 AICertificateService]    end    subgraph Data [数据层 Data Access]        direction TB        ORM[SQLAlchemy ORM]        SQLite[(SQLite Database)]    end    subgraph Integration [集成 Integration]        direction TB        MCP[MCP Server (FastMCP)]    end    UI --&gt; Service    Service --&gt; Data    MCP --&gt; Service        style UI fill:#e1f5fe,stroke:#01579b    style Service fill:#fff3e0,stroke:#ff6f00    style Data fill:#e8f5e9,stroke:#2e7d32    style Integration fill:#f3e5f5,stroke:#6a1b9a\n\n\n架构说明：本项目采用经典的三层架构（表现层、业务层、数据层），各层职责分明，通过依赖注入（DI）容器 AppContext 进行解耦。\n\n\n💾 数据模型\n查看详细数据库表结构\n\n🏆 荣誉记录 (Awards)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\ncompetition_name\nString\n比赛名称\n\n\naward_date\nDate\n获奖日期\n\n\nlevel\nString\n级别（国家&#x2F;省&#x2F;校等）\n\n\nrank\nString\n等级（一&#x2F;二&#x2F;三&#x2F;优秀）\n\n\ncertificate_code\nString\n证书编号\n\n\nremarks\nText\n备注\n\n\nattachment_folder\nString\n附件目录相对路径\n\n\ndeleted &#x2F; deleted_at\nBool&#x2F;DateTime\n软删除标记\n\n\ncreated_at &#x2F; updated_at\nDateTime\n时间戳\n\n\naward_members\nRelation\n荣誉成员快照（AwardMember，级联删除）\n\n\nattachments\nRelation\n附件（级联删除）\n\n\n🧩 荣誉成员快照 (AwardMembers)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\naward_id\nFK\n关联荣誉\n\n\nmember_id\nFK &#x2F; Nullable\n关联成员库（可空；未入库则为空）\n\n\nmember_name\nString\n当时录入的姓名快照（必填）\n\n\nsort_order\nInteger\n成员顺序\n\n\n👤 参与成员 (TeamMembers)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\nname\nString\n姓名\n\n\ngender\nString\n性别\n\n\nid_card\nString\n身份证号（唯一）\n\n\nphone\nString\n手机号\n\n\nstudent_id\nString\n学号（唯一）\n\n\nemail\nString\n邮箱\n\n\nschool &#x2F; school_code\nString\n学校名称&#x2F;标识码\n\n\nmajor &#x2F; major_code\nString\n专业名称&#x2F;代码\n\n\nclass_name\nString\n班级\n\n\ncollege\nString\n学院\n\n\npinyin\nString\n姓名拼音\n\n\nactive\nBool\n启用状态\n\n\nsort_index\nInteger\n排序权重\n\n\ncreated_at &#x2F; updated_at\nDateTime\n时间戳\n\n\naward_associations\nRelation\n通过 AwardMember 关联荣誉（成员库可变更不影响历史快照）\n\n\n🤖 AI 提供商 (AIProviders)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\nname\nString\n提供商名称（唯一）\n\n\napi_base\nString\nOpenAI 兼容 API Base\n\n\napi_keys\nText\n多 Key（支持 &#96;name\n\n\nmodel\nString\n默认模型 ID\n\n\npdf_pages\nInteger\nPDF 渲染页数（1~10）\n\n\nlast_key_index\nInteger\nKey 轮换索引（-1 表示未开始）\n\n\n\nsettings.ai_active_provider_id 用于标记当前激活的 provider；旧版单配置（ai_api_base/ai_api_key/ai_model）会在首次启动时迁移到默认 provider。\n\n🏷️ 自定义开关 (CustomFlags&#x2F;AwardFlagValues)\n\n\n模型\n关键字段\n说明\n\n\n\nCustomFlag\nkey(唯一), label, enabled, default_value, sort_order\n自定义布尔开关定义（用于录入&#x2F;导出&#x2F;筛选）\n\n\nAwardFlagValue\naward_id, flag_key, value\n荣誉对应的开关值（与 award_id+flag_key 唯一）\n\n\n🎓 专业与学校 (Majors&#x2F;Schools)\n\n\n模型\n关键字段\n说明\n\n\n\nMajor\nname(唯一), code(唯一), pinyin, category, discipline_code/name, class_code/name, 时间戳\n2025 本科专业目录（约 840 条）\n\n\nSchool\nname(唯一), code(唯一), pinyin, region, 时间戳\n全国高校列表\n\n\nSchoolMajorMapping\nschool_name/code, major_name/code, college_name, category, discipline_*, class_*\n学校-专业-学院映射，支持代码缺失时按名称回退\n\n\nAttachment\naward_id, stored_name, original_name, relative_path(唯一), file_md5, file_size, deleted, 时间戳\n附件记录\n\n\nBackupRecord &#x2F; ImportJob\n路径&#x2F;状态&#x2F;消息&#x2F;时间戳\n备份与导入任务记录\n\n\n(更多模型细节请查阅源码 src/data/models.py)\n\n\n\n🔐 数据安全与备份\n  \n    \n      \n        🛡️ 本地优先\n        数据存于 data/awards.db，附件在 attachments/，默认不上传云端。\n      \n      \n        🔄 自动备份\n        支持手动/启动时/每日/每周备份；基于 SQLite backup() 生成快照，并可在恢复前自动创建还原点。\n      \n    \n    \n      \n        🗑️ 回收站\n        删除荣誉进入回收站可恢复；附件删除会移入 attachments/.trash。\n      \n      \n        🧹 清理策略\n        提供日志/备份清空与数据库重建（reset）工具，均带双重确认；数据库清空会重建空库并重载默认设置。\n      \n    \n  \n\n\n\n⚠️ 隐私提醒：请勿将 data/、backups/、attachments/、logs/、.env 等敏感目录提交到版本控制系统。\n\n\n🎨 主题系统应用内置了一套精美的色彩系统，适配深色&#x2F;浅色模式。\n\n\n\n指标类型\n渐变色 (Light -&gt; Dark)\n语义\n\n\n\n总荣誉\n💜 #a071ff → #7b6cff\n综合实力\n\n\n国家级\n💙 #5a80f3 → #4ac6ff\n最高荣誉\n\n\n省级\n💛 #ffb347 → #ffcc33\n中坚力量\n\n\n校级\n💚 #3ec8a0 → #45dd8e\n基础积累\n\n\n一等奖\n💠 #00b4d8 → #48cae4\n顶尖表现\n\n\n二等奖\n💜 #b54cb8 → #d896ff\n稳定发挥\n\n\n三等奖\n❤️ #ff6b6b → #ff8787\n鼓励奖项\n\n\n优秀奖\n🤍 #999999 → #b3b3b3\n参与&#x2F;优秀\n\n\n\n🛠️ 开发指南\n环境准备: 确保 Python 3.14+，推荐使用 uv 管理虚拟环境。\n新增页面: 继承 BasePage，在 main_window.py 中注册路由。\n数据库变更: 修改 models.py，目前使用自动建表，生产环境建议引入 Alembic。\n代码规范: 提交前请运行 ruff check 和 pyright。\n版本与文档: 版本号统一来自 pyproject.toml（运行时由 src/version.py 读取）；升级版本时请同步更新 README 顶部&#x2F;更新日志与应用“关于”页文案。\n\n\n🧰 故障排查\n点击查看常见问题解决方案\n\n\n\n\n问题现象\n可能原因\n解决方案\n\n\n\n启动缺少 Qt 插件\n环境依赖不完整\n运行 uv sync，若无效则删除 .venv 重试\n\n\n界面文字乱码\n字体缺失或编码问题\n检查系统字体，确认未强制覆盖 QFontDatabase\n\n\n数据库被锁\n异常退出导致锁文件残留\n先关闭应用；仍锁时删除 data/awards.db-shm 和 .db-wal（恢复备份前程序会尝试清理这两类文件）\n\n\n导入无响应\n模板格式错误\n确认 CSV&#x2F;XLSX 表头与模板一致，查看设置页日志\n\n\nMCP 连接失败\n端口未启动&#x2F;URL 错误&#x2F;依赖缺失\nSSE：确认 http://127.0.0.1:8000/sse 且设置页已启动；Web：先 uv sync --group mcp-web，再启动 Web 控制台并访问 http://127.0.0.1:7860\n\n\nMCP Web 关闭后端口仍占用（7860）\n进程未退出&#x2F;残留子进程\n退出应用与相关终端后，用 netstat -ano | findstr :7860 查 PID，再 taskkill /PID &lt;pid&gt; /T /F\n\n\nMCP SSE 启动报 host 限制\nMCP 服务仅允许本地绑定\n将 CERT_MCP_HOST 设置为 127.0.0.1 &#x2F; localhost &#x2F; ::1（或直接用设置页启动）\n\n\nAI 识别提示缺少 PDF 依赖\n未安装 PyMuPDF\n运行 uv sync 安装依赖（需要识别 PDF 时必须）\n\n\nAI 识别失败：Cloudflare 1010\n网络&#x2F;代理&#x2F;风控拦截\n更换网络&#x2F;代理或更换中转；该错误通常与本机环境无关\n\n\nAI 识别失败：模型输出不是有效 JSON\n模型不按要求输出结构化结果\n更换模型&#x2F;提供商；确保模型支持图像输入，并尝试在设置页手动填写模型 ID\n\n\n主题不更新\n信号未连接\n检查 __init__ 是否连接 themeChanged 信号\n\n\n附件校验失败\n文件被占用或修改\n检查文件权限，清空回收站后重试\n\n\n\n\n\n📝 更新日志\n说明：以下版本号按 GitHub main 分支提交记录分段整理（无 Tag 时以日期为准），采用 SemVer（主版本&#x2F;次版本&#x2F;修订号）。\n\nv1.4.0 (2025-12-18)\nAI 证书识别\n荣誉录入页支持一键从证书图片&#x2F;PDF 抽取比赛名称、日期、级别、奖项、证书编号与成员姓名，并提供预览确认后再填充\nAI 设置页新增&#x2F;完善：多 Provider 管理（名称&#x2F;API 地址&#x2F;模型&#x2F;PDF 页数）、模型列表刷新&#x2F;选择、联通测试、API Key 多 Key 轮换\n\n\n运维与数据\n新增数据库 reset 与自定义布尔开关批量保存，便于清理与批处理\n修复奖项成员快照在部分路径下的赋值顺序问题\n\n\n文档\n修正目录锚点与奖项说明细节\n\n\n\n\n提交记录（v1.4.0，共 7 条）\n\n\ncde6154 2025-12-17 docs: 修正目录锚点与补充奖项说明\n47a45f0 2025-12-17 feat: 支持数据库 reset 与 flag 批量保存\n0a7abf4 2025-12-18 fix: 修正奖项成员快照赋值顺序\n9e0fde6 2025-12-18 feat: 增加 AI 证书识别与多 Provider 支持\ne70fa2c 2025-12-18 fix: 优化 AI 证书按钮与模型输入兼容性\nc0d2912 2025-12-18 fix: 优化 AI 密钥表格内容居中显示\n8a7c285 2025-12-18 refactor: 拆分 AI 设置表单结构\n\n\n\nv1.3.1 (2025-12-17)\n荣誉成员快照 &#x2F; 可选入库\n荣誉成员改为快照模型：荣誉始终保存 member_name，可选绑定成员库 member_id，成员库变更&#x2F;停用不影响历史荣誉显示\n录入页每个成员卡片新增“加入成员库”勾选（默认关闭），不入库时仅保存姓名；总览&#x2F;仪表盘&#x2F;导入导出同步适配\n\n\n性能&#x2F;体验\n页面引入懒加载占位页，并在启动后分批后台预热，显著降低首屏初始化压力\n专业&#x2F;学校搜索与仪表盘数据加载迁移到线程池异步执行，减少输入与切页时的 UI 阻塞\n页面切换时仅在可见页面运行刷新&#x2F;轮询定时器，修复“每 5 秒卡一下”的卡顿问题\n控制台日志格式更清晰（时间+等级对齐，可选颜色），过滤第三方提示信息，Windows 启动脚本成功退出不再强制暂停\n\n\n数据安全\n备份改用 SQLite backup() 快照生成，避免 WAL 模式下直接复制 awards.db 可能导致的不一致\n\n\n稳定性\n修复 run_in_thread() 线程池任务回调偶发丢失（worker 生命周期过短导致未回调）\n修复部分类型标注在运行时导入触发 NameError 的问题（提升对不同 Python 版本的兼容性）\n\n\nMCP\n附件读取工具返回信息更准确，并跟随设置页配置的附件目录工作（修改目录后重启 MCP 生效）\n\n\n工程化\n规范化版本号管理，统一从 pyproject.toml 读取，窗口标题显示版本号\n\n\n文档\n修正 README 段落缩进与更新日志结构，补齐各版本提交记录\n完善 MCP&#x2F;AI 接入与本地安全说明（仅本地使用，保持绑定 127.0.0.1）\n\n\n\n\n提交记录（v1.3.1，共 7 条）\n\n\n1bb7c41 2025-12-17 feat: 荣誉成员支持快照与可选入库\n1ae5479 2025-12-17 feat: 优化页面加载与错误处理，提升性能\nac8cc5c 2025-12-17 feat: 优化日志输出与懒加载页面体验\n25041a0 2025-12-17 chore: 规范化版本号管理 (v1.3.1)\nf6b55c3 2025-12-17 feat: 优化荣誉成员快照与页面性能\nef15694 2025-12-17 docs: 修正 README.md 段落缩进与更新日志\n4ed0e17 2025-12-17 docs: 完善 MCP&#x2F;AI 接入与安全说明\n\n\n\nv1.3.0 (2025-12-16)\nMCP 接入\n新增本地 MCP 服务（stdio&#x2F;SSE），默认只读；支持敏感信息脱敏与附件读取限额\n新增可选 Web 控制台（Gradio），用于本机调试 MCP 输出（无登录，仅本地）\n设置页集成 MCP 管理（随软件启动、端口&#x2F;权限&#x2F;脱敏配置、日志入口、Web 依赖一键安装&#x2F;更新）\n\n\n工程化与结构\nMCP 相关代码整理到 src/mcp/，统一模块命名与脚本入口（certificate-mcp &#x2F; certificate-mcp-web）\nMCP 进程与 Web 控制台运行日志落盘（logs/mcp_sse.log、logs/mcp_web.log、logs/mcp_web_install.log）\n\n\n细节修复\n修复导入模板与设置页布局细节，优化 MCP 说明与使用指引\n\n\n\n\n提交记录（v1.3.0，共 5 条）\n\n\nf6086cd 2025-12-16 feat: 集成 MCP 服务及本地 Web 控制台\n2ed061f 2025-12-16 feat: 增强 MCP 进程管理与敏感信息脱敏\n493d310 2025-12-16 feat: 优化 MCP 说明与 Web 控制台操作\n5a2a907 2025-12-16 refactor: MCP 相关模块目录结构调整与功能优化\n35f397c 2025-12-16 chore: 更新版本号至 1.3.0 并补充更新日志\n\n\n\nv1.2.0 (2025-12-14)\n新增：自定义布尔开关（CustomFlag &#x2F; AwardFlagValue）及与荣誉记录关联\n新增：设置页开关管理界面（改名、启用、默认值、排序、删除双重确认）\n增强：录入页&#x2F;导入导出支持开关值读写，统计与相关逻辑同步完善\n\n\n提交记录（v1.2.0，共 1 条）\n\n\n86f6d01 2025-12-14 feat: 增加自定义布尔开关及荣誉关联\n\n\n\nv1.1.0 (2025-12-09 ~ 2025-12-10)\n新增：批量管理（全选&#x2F;反选&#x2F;全不选）与成员排序优化\n新增：荣誉&#x2F;成员全文检索（FTS5）与导入流程优化\n增强：附件去重（含按奖项限定）与备份&#x2F;恢复体验优化\n增强：主窗口导航快捷键、自动备份选项、LOGO 与文档说明完善\n\n\n提交记录（v1.1.0，共 15 条）\n\n\n3c1aa2f 2025-12-09 feat: 批量管理与成员排序功能优化\ndf74008 2025-12-09 feat: 批量管理支持全选&#x2F;反选&#x2F;全不选\n8848538 2025-12-09 refactor: 优化最新荣誉查询逻辑\nc18bc0e 2025-12-09 feat: 学校与专业导入及数据模板完善\ncf09d34 2025-12-10 feat: 附件去重与备份恢复功能优化\n2c7ad87 2025-12-10 feat: 附件查重支持按奖项限定\n193a4cb 2025-12-10 feat: 增加主窗口导航快捷键与备份自动备份选项\n661c30e 2025-12-10 feat: 荣誉与成员全文搜索及导入优化\n85a4fe7 2025-12-10 feat: 更新 LOGO 与设置&#x2F;搜索功能说明\n3de33e0 2025-12-10 docs: 优化 README LOGO 展示布局\n67a5bc6 2025-12-10 docs: 优化 README 顶部布局与徽章展示\n15b3aed 2025-12-10 docs: 完善数据模型与目录说明\n901b405 2025-12-10 docs: 修正 README 顶部打字动画内容编码\nb3616d7 2025-12-10 docs: 完善数据模型说明并删除测试脚本\nb530069 2025-12-10 chore: 更新 .gitignore 及 AGENTS.md 数据目录说明\n\n\n\nv1.0.1 (2025-12-04 ~ 2025-12-07)\n体验优化：表单&#x2F;仪表盘&#x2F;列表 UI 大量调整，表格迁移至 QTableView 并支持居中显示\n主题&#x2F;性能：浅色表格修复、深色背景调整、减少模糊特效避免掉帧、动画更顺滑\n数据能力：专业库 Excel 导入与统计展示、附件表格支持拖拽添加\n工程化：依赖管理切换为 pyproject.toml + uv，集成 Ruff&#x2F;Pyright；构建系统切换为 setuptools\n稳定性：支持信号中断安全退出，修复字体重置、总览页附件显示等问题\n\n\n提交记录（v1.0.1，共 61 条）\n\n\ne0c1b33 2025-12-04 修复操作细节\n6e90000 2025-12-04 逻辑优化\n1b492fd 2025-12-04 无更新\nef0b2d4 2025-12-04 Remove docs folder\n75a6902 2025-12-04 feat: 添加文档导入功能和邮箱自动生成\n55bc0fd 2025-12-04 修复小BUG\n5297fcf 2025-12-04 修复小BUG\na29a915 2025-12-05 修复总览页不显示附件的BUG\n68318b7 2025-12-05 优化体验\n7176bd5 2025-12-05 加入关于页\nf4fa0fd 2025-12-05 提供个人信息模板\ndc4161a 2025-12-05 更新排序功能\n584f049 2025-12-05 更新文本\na8c8af5 2025-12-05 更新细节\n05d60b1 2025-12-05 RM更新\n85f6fe9 2025-12-05 RM更新\n3260af5 2025-12-05 fix: 移除模糊特效防止掉帧\n9b25efa 2025-12-05 fix: 优化备份目录配置容错处理\nc751e23 2025-12-05 feat: 支持logo随主题切换\n69d383d 2025-12-05 fix: 防止动画中卡顿\n4729233 2025-12-05 refactor: 全面替换表格为QTableView并引入模型\nf2363bb 2025-12-05 refactor: 优化表单与仪表盘UI及交互\n93537a2 2025-12-05 refactor: 表单控件统一为qfluentwidgets组件\nbe6c61a 2025-12-05 refactor: 统一成员卡片样式为QSS卡片属性\na80e672 2025-12-05 refactor: 隐藏日期选择器符号按钮\n79b65ae 2025-12-05 refactor: 优化搜索框与荣誉卡片样式\n48a3e17 2025-12-05 refactor: 设置全局字体避免警告\ndbc5819 2025-12-05 fix: 修复字体重置的问题\nf61e75c 2025-12-05 fix: 移除弹窗模糊特效防止掉帧\n958aea2 2025-12-05 chore: 切换依赖管理为 pyproject.toml+uv\n6afce89 2025-12-05 refactor: 移除表情符号并优化注释\n49358ff 2025-12-05 refactor: 精简注释与优化代码结构\n6ee169e 2025-12-05 chore: 调整ruff配置项位置\n2d9fe94 2025-12-05 refactor: 统一导航方法为navigate_to\nc79858a 2025-12-05 style: 统一代码风格与格式优化\n893226f 2025-12-05 refactor: 优化类型导入与异常处理\n6905e1a 2025-12-05 refactor: 统一文件操作与类型注解优化\n4fb64e9 2025-12-05 docs: 重命名 agents.md 至 AGENTS.md\na348921 2025-12-06 docs: 更新 AI 开发指南\nb3ea343 2025-12-06 docs: 更新数据模型与依赖说明\n19096b8 2025-12-06 chore: 移除 ruff 配置中的 PL 规则\n775c69c 2025-12-06 refactor: 精简条件表达式与移除无用Tag相关方法\nc17746a 2025-12-06 feat: 集成 Pyright 类型检查支持\n330c982 2025-12-06 refactor: 适配 PySide6 新版 API 与类型注解优化\n139ab0d 2025-12-06 refactor: 移除 future annotations 导入\n66d29cc 2025-12-06 refactor: 优化页面初始化与导航栏注册\n8e93328 2025-12-06 feat: 优化页面切换动画\n1bba145 2025-12-06 style: 调整深色主题主背景色\n7756c10 2025-12-06 fix: 修复表格亮色模式\n6c048e0 2025-12-06 feat: 支持信号中断安全退出\na91ebd1 2025-12-06 feat: 真正的 Fluent Design 切换动画\n57bef83 2025-12-06 Merge pull request #1 from zetaloop&#x2F;refactorxx\n20e1a66 2025-12-07 chore: 启动脚本增加虚拟环境激活\n7d6b279 2025-12-07 chore: 格式化依赖配置与部分代码结构\na235df8 2025-12-07 chore: 切换构建系统为 setuptools\n2eeb63e 2025-12-07 feat: 附件表格支持拖拽添加文件\ne526e91 2025-12-07 feat: 表格内容居中显示\n27755da 2025-12-07 refactor: 优化类型导入与依赖\n07d3ccc 2025-12-07 feat: 专业库支持 Excel 导入与统计展示\nda71f6d 2025-12-07 refactor: 专业库导入脚本迁移与优化\n61d99e9 2025-12-07 refactor: 优化 test_majors.py 导入与格式\n\n\n\nv1.0.0 (2025-12-02 ~ 2025-12-03)\n初版完成：基础页面、主题样式与主要组件搭建\n文档：引入 AGENTS.md，为 AI&#x2F;自动化开发提供项目导航与规范\n\n\n提交记录（v1.0.0，共 10 条）\n\n\ne30a773 2025-12-02 V1.0 创建\n81e6477 2025-12-02 添加主题样式和页面组件功能\n27071ef 2025-12-02 Clean up: remove unused files and configure .gitignore for sensitive data\n2643a2d 2025-12-02 chore: remove .codemap from version control\n9d38507 2025-12-02 更新细节\n85d8e2f 2025-12-03 feat: implement comprehensive code improvements\ncd2214b 2025-12-03 细节修复\na9a6fc9 2025-12-03 细节修复\nca924ab 2025-12-03 大版本V1.0完成\n5d6f019 2025-12-03 创建agents.md为AI开发提供便利\n\n\n\n\n📈 Star History\n \n   \n   \n   \n \n\n\n\n🤝 如何贡献非常欢迎您的贡献！请遵循以下流程：\n\nFork 本仓库\n创建特性分支 (git checkout -b feature/AmazingFeature)\n提交更改 (git commit -m &#39;Add some AmazingFeature&#39;)\n推送到分支 (git push origin feature/AmazingFeature)\n提交 Pull Request\n\n\n📄 许可证本项目基于 MIT License 开源。\n\n\n  \n    Author: RE-TikaRa |\n    Powered by: PySide6 & QFluentWidgets\n  \n  \n  \n    \n      \n    \n    \n      \n    \n  \n\n","categories":["Project"],"tags":["Project"]},{"url":"/Blog/posts/0/","content":"DesktopTimer | 桌面计时器\n   \n      \n   \n   \n      \n   \n   \n      \n   \n   \n      \n   \n   \n      \n   \n\n\n\n\n   \n\n\nDesktopTimer | 桌面计时器\n\n\n基于 PyQt6 的轻量级桌面计时器，支持正计时/倒计时/时钟模式，系统托盘、快捷键、音效与闪烁提醒、多语言（中/英）以及丰富的外观自定义；\n\n\n\n\n  下载最新版本 •\n  查看源码 •\n  报告 Bug •\n  提出新特性\n\n\n\n本 README 同时面向“用户”和“开发者”，上来就想用的看“快速开始”，想参与开发的看“开发者指南”。\n\n\n🚀 快速开始（用户）\n支持系统：Windows 10&#x2F;11（x64）\n推荐环境：Python 3.13（仅源码运行需用到），普通用户可直接使用安装包或便携版\n\n\n安装程序（建议）\n\n\n前往 Releases 下载 DesktopTimer-Setup.exe\n双击安装，按向导完成；从开始菜单或桌面快捷方式启动\n\n\n便携版\n\n\n下载 DesktopTimer.zip → 解压 → 直接运行 DesktopTimer.exe\n\n\n从源码运行（开发者）\n\n\n克隆仓库并安装依赖后运行 main.py（见下文“开发者指南”）\n\n\n✨ 功能一览\n⏰ 三种计时：正计时、倒计时、时钟（12&#x2F;24 小时制、可选“秒&#x2F;日期”）\n🔔 提醒方式：自定义音效（可调音量）、系统 Beep、窗口闪烁、托盘气泡、Windows 通知（可开关）\n🌐 双语言：中文 &#x2F; English 一键切换\n🎯 预设管理：设置页支持自定义&#x2F;排序&#x2F;搜索&#x2F;多选删除倒计时预设，排序方式可记忆，可为中&#x2F;英文界面分别命名并同步托盘快捷菜单\n🎨 外观：字体&#x2F;字号、颜色、圆角、透明度、夜读模式、窗口尺寸、主题（浅&#x2F;深&#x2F;跟随系统）\n🧰 系统托盘：暂停&#x2F;继续、重置、模式切换、倒计时预设（含自定义单次输入）、显示&#x2F;隐藏、锁定&#x2F;解锁、打开设置、退出\n🔒 窗口锁定：固定位置并可启用“点击穿透”\n⌨️ 快捷键：常用操作一键直达\n🖥️ 全屏模式：F11 一键切换，简拍&#x2F;展示更方便\n\n\n🧭 使用说明（核心操作）\n设置倒计时：在设置页输入小时&#x2F;分钟&#x2F;秒，或托盘菜单选择预设&#x2F;自定义单次倒计时\n开始&#x2F;暂停&#x2F;继续：托盘菜单或快捷键 Ctrl+Space；也可在设置中启用“启动自动开始”\n重置计时：托盘菜单或快捷键 Ctrl+R\n窗口锁定：托盘菜单或 Ctrl+L（锁定后支持点击穿透）\n切换模式：设置页或托盘“模式切换”菜单\n显示&#x2F;隐藏：托盘菜单或 Ctrl+H\n配置保存：所有设置自动保存至 settings/timer_settings.json\n\n⌨️ 快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+Space\n暂停&#x2F;继续\n\n\nCtrl+R\n重置\n\n\nCtrl+H\n显示&#x2F;隐藏窗口\n\n\nCtrl+L\n锁定&#x2F;解锁窗口\n\n\nCtrl+,\n打开设置\n\n\nF11\n全屏&#x2F;退出全屏\n\n\n\n🛠️ 开发者指南开发环境要求\nPython 3.13\nWindows 10&#x2F;11\n依赖管理：UV\n注：如需 Qt Designer 等工具，可另行安装 pyqt6-tools（与项目运行依赖无关）。\n\n\n\n源码运行# 克隆与进入目录git clone https://github.com/RE-TikaRa/DesktopTimer.gitcd DesktopTimer# 安装依赖uv sync# 运行uv run python main.py# 如需调试日志，可在运行前设置环境变量# PowerShell$env:DESKTOPTIMER_DEBUG=1# CMDset DESKTOPTIMER_DEBUG=1\n\n打包为可执行文件# 打包需要安装开发依赖uv sync --devuv run python -m PyInstaller DesktopTimer.spec --noconfirm\n打包完成后生成 dist/DesktopTimer.exe。请将 img/、lang/、sounds/ 一并放入 dist/ 目录。\n也可直接使用内置脚本一键完成清理、打包、复制资源与压缩：\ntools\\pyinstaller.bat\n\n文件结构DesktopTimer/├── main.py           # 程序入口├── /module/          # 拆分逻辑（app/窗口/配置等）│   ├── __init__.py│   ├── app.py│   ├── constants.py│   ├── localization.py│   ├── paths.py│   ├── settings_dialog.py│   └── timer_window.py├── DesktopTimer.spec          # PyInstaller 配置├── pyproject.toml             # UV 项目配置├── uv.lock                    # UV 锁文件├── requirements.txt           # Python 依赖（历史/兼容）├── README.md                  # 项目说明├── tools/                     # 构建/打包脚本├── /img/                      # 图标资源│   ├── timer_icon.ico│   └── ALP_STUDIO-logo-full.svg├── /lang/                     # 语言包│   ├── zh_CN.json│   └── en_US.json├── /sounds/                   # 提醒音├── /settings/                 # 用户运行时配置│   └── timer_settings.json├── /build/                    # 临时构建文件└── /dist/                     # 打包输出\n\n架构与实现要点\ni18n：多语言加载（lang&#x2F;*.json）\nSettingsDialog：设置对话框（外观&#x2F;模式&#x2F;预设&#x2F;通用&#x2F;关于）\nTimerWindow：主窗口&#x2F;计时&#x2F;托盘&#x2F;提醒&#x2F;快捷键（含模式切换菜单、倒计时预设与自定义单次输入）\n路径管理：自动识别开发&#x2F;打包环境，动态定位资源\n配置管理：JSON 持久化，包含版本兼容处理\n\n要点：使用 sys.frozen 识别打包环境；相对路径存储确保可移植；QTimer&#x2F;QMediaPlayer&#x2F;QSystemTrayIcon 组合\n\n📦 打包与发布\n使用 DesktopTimer.spec 进行 onefile 打包，输出 dist/DesktopTimer.exe\n将 img/、lang/、sounds/ 复制到 dist/ 下，确保资源可用\n可使用 Inno Setup 生成安装程序（参考 setup/SetUp.iss）\n\n\n❓ 常见问题（FAQ）\n打包后没有声音&#x2F;语言不生效？\n\n请确认已将 img/、lang/、sounds/ 整个目录复制到 dist/。\n\n\n托盘图标不显示&#x2F;找不到？\n\n检查系统托盘的“隐藏的图标”区域；确保 Explorer 正常；程序最小化到托盘时可通过 Ctrl+H 显示&#x2F;隐藏。\n\n\n锁定后无法操作窗口怎么办？\n\n使用快捷键 Ctrl+L 解锁，或通过系统托盘菜单解锁。\n\n\n源码运行报依赖错误？\n\n重新执行 uv sync，确保网络正常。\n若提示 Python 版本不匹配，请确认项目使用 Python 3.13。\n\n\n打包后资源路径异常？\n\n本项目已兼容 sys.frozen 场景；若自定义了运行目录，请保持资源与可执行文件同级。\n\n\nDesktopTimer.egg-info/ 是什么？\n\n这是 setuptools 构建产生的元数据目录，可在发布包或清理时忽略&#x2F;删除。\n\n\n切换语言后界面没变化？\n\n语言下拉框一旦切换就会立即应用到主窗口与托盘；若仍看到旧语言，可确认设置文件是否可写或查看日志输出。\n\n\n\n\n🧭 开发路线图✅ 已完成功能\n正计时&#x2F;倒计时&#x2F;时钟三种模式\n系统托盘常驻与快捷操作\n多种提醒方式（音效&#x2F;闪烁&#x2F;通知）\n中英文双语支持\n外观完全自定义\n快捷键支持\n番茄钟快捷预设\n窗口锁定功能（位置固定 + 点击穿透）\n快捷键自定义\n托盘模式切换与即席自定义倒计时\n预设支持中英文双描述，可在创建时同步填写\n\n📌 计划中的功能\n结束提醒增强：音量、循环次数、渐入渐出；播放列表&#x2F;多音频轮播\nWindows 原生通知按钮（如“再来 5 分钟”“停止”）\n托盘与主题：暗&#x2F;亮主题托盘图标，自定义图标包\n设置管理：设置导出&#x2F;导入备份，一键恢复默认\n自动更新：检查 Releases 新版本并提示下载\n开机自启动（用户可选）\n多语言扩展：支持更多语言（日文、韩文等）\n可视化窗口滑块：为字体&#x2F;窗口大小提供滑块+“恢复默认”按钮，并显示实时数值\n全屏专用主题：进入全屏时可使用独立的背景&#x2F;文字&#x2F;透明度样式\n自定义快捷预设：允许用户在设置中增删 Pomodoro 预设并同步到托盘&#x2F;右键菜单\n配置导入&#x2F;导出：一键备份或应用 settings/*.json，方便在不同设备间迁移\n预设导入&#x2F;导出能力（JSON 备份&#x2F;恢复）\n预设列表排序、搜索或分组功能\n语言切换提示（关闭设置前提醒“需点击应用&#x2F;确定”）\n设置中添加调试日志开关（无需依赖环境变量）\n更易用的预设多语言编辑视图（统一列表，可批量维护）\n替换 win10toast 或移除其中的 pkg_resources 依赖以适配未来环境\n\n\n🧩 使用到的技术栈\nPyQt6 - GUI 框架\nPyQt6-Fluent-Widgets - Fluent 风格组件库（设置页 UI）\nPyInstaller - 打包工具\nwin10toast - Windows 通知（可选）\nInno Setup - 安装程序制作\n\n\n🤝 贡献指南欢迎通过 Issues 或 Pull Requests 参与贡献！\n如何参与开源项目\nFork 本仓库\n新建分支：git checkout -b feature/your-feature\n提交改动：git commit -m &quot;feat: your message&quot;\n推送分支：git push origin feature/your-feature\n发起 Pull Request\n\n\n🔖 版本控制项目使用 Git 管理版本；发布版本在 Releases&#x2F;Tags 标注。\n\n👤 作者TikaRa📧 邮箱：163mail@re-TikaRa.fun🌐 个人网站：https://re-tikara.fun🐙 GitHub：https://github.com/RE-TikaRa/DesktopTimer📺 B 站主页：https://space.bilibili.com/374412219\n\n📄 版权说明本项目采用 GNU GPL v3 或更高版本。\n允许：自由使用、修改与再发布（包含商用），需保留版权与许可声明，并在发布衍生作品时继续采用 GPL v3 或更高版本。\n要求：发布二进制时需同时提供对应源码；不得移除许可证文本。\n完整条款参见仓库中的 LICENSE 文件。\n\n🙏 鸣谢\nPyQt6 - 提供强大的 GUI 框架\nPyInstaller - Python 打包为可执行文件\nQt - 跨平台 GUI 框架\nInno Setup - Windows 安装程序制作工具\nShields.io - 项目徽章\nGitHub Pages - 文档托管\n\n","categories":["Project"]},{"title":"第七章——函数 第三节——无返回值的函数的一般调用形式","url":"/Blog/posts/d0d12044/","content":"无返回值的调用形式函数名(实际参数列表) ; // 分号是必不可少的\n\n函数调用执行流程&emsp;&emsp;其实与有返回值的调用形式一样，只是最后没有“return(表达式)”\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第七章——函数 第二节——有返回值的函数的一般调用形式","url":"/Blog/posts/11577315/","content":"有返回值函数的调用形式函数名 （实际参数列表）\n&emsp;&emsp;    调用的结果是获得一个返回值，该返回值可以参加相应类型的计算。\n函数调用的过程\n首先为被调用函数的所有形参分配内存，再计算实际参数的值，再一一对应地赋给相应的形参（对于无参函数，不做这项工作）。\n然后进行函数体，为函数说明部分定义的变量分配存储空间，再依次执行函数体中的可执行语句。\n当执行到return语句时，计算返回值，收回本函数中定义的变量所占用的存储空间，对于static类型的变量，其空间不收回），返回主调函数继续执行。\n\n函数调用的语法要求\n调用函数时，函数名必须与所调用的函数名字完全一致。\n实参的个数必须与形参一致。\nC语言规定，函数必须先定义后调用。\n\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第七章——函数 第一节——函数定义和返回值","url":"/Blog/posts/4049614e/","content":"一、函数定义：你的专属工具说明书函数定义就像写一份工具说明书。比如你发明了一个“自动榨果汁机”（函数），说明书需要写清楚：\n\n功能：能榨什么水果（参数类型，比如苹果、橙子）\n步骤：怎么操作（函数体里的代码）\n结果：最后产出什么（返回值类型，比如果汁）\n\n代码例子：\n// 函数定义：榨汁机说明书int juice_maker(int apples, int oranges) &#123;  // 苹果和橙子的数量是参数    int total = apples * 10 + oranges * 15; // 榨汁过程（函数体）    return total; // 返回值：果汁毫升数&#125;\n类比：就像你告诉朋友：“用2个苹果+3个橙子榨汁，能得到210+315&#x3D;65ml果汁”，这个公式就是你的“函数”。\n\n一般格式函数类型 函数名(形参类型说明表)// 函数名必须合法，既不可以使用系统关键字&#123;    说明部分    语句部分&#125;\n\n有参函数（现代写法）int max(int a, int b)// 两个形参必须分开指明类型，int max(int a, b)是错误的&#123;    int z;    z=a&gt;b?a:b;    return z;&#125;\n\n\n无参函数写法一void print_menu()&#123;    printf(&quot;1. 菜单\\n&quot;);&#125;\n写法二void print_menu(void)&#123;    printf(&quot;1. 菜单\\n&quot;);&#125;\n\n空函数void nothing()&#123;    // 是空的哦~什么也不用写    // 如果确定是个空函数的话    // 虽然加上也不会报错    // 但是加了是一个多余的写法，亓翎不推荐&#125;\n\n\n古早的传统写法函数类型 函数名(形参表)形参类型说明&#123;    说明部分    语句部分&#125;\n示例-有参函数int max(a , b)int a, int b;&#123;    int z;    z=a&gt;b?a:b;    return z;&#125;\n\n\n二、返回值：任务完成后的“结果反馈”返回值就像快递员送完包裹后给你的签收单。比如：\n\n有返回值：快递员说“已送达，签收了！”（比如返回果汁毫升数）\n无返回值（void）：快递员放下包裹就走，不说话（比如一个打印菜单的函数）\n\n\n返回语句形式return(表达式);return 表达式;return;// 这三种写法全是对的，但是我个人喜欢第二种\n\n代码例子：\n// 有返回值函数：计算两个数的最大值int max(int a, int b) &#123;    if (a &gt; b)         return a;  // 如果a大，返回a    else         return b;  // 否则返回b&#125;\n类比：相当于老师批改考试，最后给你打分（返回值）告诉你考得怎么样。\n\n功能&emsp;&emsp;功能：使程序控制从被调用函数返回到调用函数中，同时把返值带给调用函数。\n\n函数返回值类型&emsp;&emsp;定义在函数开头的函数类型，一般有如下几种：\n\nint：返回整数（比如计算结果）\nvoid：无返回值（比如打印菜单）\nchar：返回字符（比如输入的字母）\ndouble：返回小数（比如计算结果）\n\n\n几点说明\n函数中可有多个return语句\n若无return语句，遇}时，自动返回调用函数\n若函数类型与return语句中表达式值的类型不一致，按前者为准，自动转换——函数调用转换\n要注意void型函数\n\n\n关于在void型函数中使用return&emsp;&emsp;在C语言中，void 类型的函数可以使用 return 语句，但有一些注意事项和潜在问题需要了解。\n1. void 函数中的 return 是合法的&emsp;&emsp;void 类型的函数表示该函数不返回任何值。在这种情况下，return 可以用于提前终止函数的执行，而不需要返回值。例如：\nvoid print_message(int flag)&#123;    if (flag == 0) &#123;        return;         // 直接结束函数，后面的输出也不会输出哦        // 无论是几层嵌套的，都会直接截断，后面的直接不执行        // 呀注意它和break不一样的    &#125;    printf(&quot;Flag is not zero.\\n&quot;);&#125;\n\n&emsp;&emsp;在这个例子中，如果 flag 的值为 0，函数会在 return 处直接退出，不会执行后续的代码。\n\n2. return 后不能跟随表达式&emsp;&emsp;在 void 函数中，return 语句后面不能跟随任何表达式或值，否则会导致编译错误。例如：\nvoid example_function(void)&#123;    return 42; // 错误！void 函数不能返回值&#125;\n\n&emsp;&emsp;上述代码会导致编译器报错，因为 void 类型的函数不允许返回任何值。\n\n3. 潜在问题&emsp;&emsp;虽然在 void 函数中使用 return 是合法的，但在某些情况下可能会引发问题或误解：\na. 过度使用 return 导致代码难以维护&emsp;&emsp;如果在一个函数中频繁使用 return，可能会使代码逻辑变得复杂且难以阅读。例如：\nvoid complex_function(int value)&#123;    if (value &lt; 0) &#123;        return;    &#125;    if (value == 0) &#123;        return;    &#125;    if (value &gt; 100) &#123;        return;    &#125;    printf(&quot;Value is valid: %d\\n&quot;, value);&#125;\n\n&emsp;&emsp;这种写法虽然功能上没有问题，但由于存在多个 return 语句，可能会使代码逻辑变得分散，难以追踪程序的执行路径。\nb. 遗漏必要的清理操作&emsp;&emsp;如果函数中有资源分配（如动态内存分配、文件打开等），过早使用 return 可能会导致资源泄漏。例如：\nvoid resource_leak_example(void)&#123;    FILE *file = fopen(&quot;example.txt&quot;, &quot;r&quot;);    if (file == NULL) &#123;        return; // 直接返回，未关闭文件    &#125;    // 正常处理文件    fclose(file);&#125;\n\n&emsp;&emsp;在这个例子中，如果 fopen 返回 NULL，函数会直接通过 return 退出，导致文件指针未被正确关闭，从而可能引发资源泄漏。\n\n三、常见误区：没有return会怎样？&emsp;&emsp;特别提醒：如果函数没有return语句，遇到}时会自动返回，但返回值不确定。这就像：\n\n做实验没写结论，老师直接合上实验本——结果可能被误判为0分，也可能随机给个值（取决于编译器）。\n\n错误示范：\nint add(int a, int b) &#123;    int result = a + b;  // 计算结果存在变量里    // 没有return语句！&#125;\n&emsp;&emsp;这会导致调用者拿到一个“未知的结果”，就像你问AI问题，它突然说：“嗯……忘了告诉你答案”。\n\n四、类型不匹配怎么办？系统自动“翻译”如果函数声明返回整数（int），但实际返回小数（比如return 3.14;），系统会自动转换成整数（3）。就像：\n\n用美元付款，但找零给的是人民币——系统帮你“汇率转换”，但可能损失精度。\n\n\n五、为什么函数定义和返回值重要？函数定义和返回值对应的知识点是编程的“骨架”：\n\n模块化思维：把复杂问题拆成小工具（函数），比如把做蛋糕拆成“打蛋器”、“烤箱”等函数\n数据流动：参数是输入，返回值是输出，构成完整的“数据生产线”\n调试基础：理解返回值机制才能排查“为什么函数没返回预期结果”的问题\n\n现实案例：某银行系统有个利息计算器函数，因忘记写return，导致所有储户利息显示为0，引发客诉——这就是函数定义和返回值知识点踩坑的典型反例。\n\n总结：函数就像“魔法盒子”\n定义函数：写说明书（参数+过程+结果）\n返回值：给使用者一个明确的反馈\n注意事项：别让盒子空手回来，类型要匹配，否则系统会“好心帮倒忙”\n\n&emsp;&emsp;掌握函数定义和返回值，就像学会搭积木的第一块基石，后面才能堆出更复杂的程序高楼！\n\n考点总结C语言函数定义的一般形式存储类型说明符 函数返回值类型 函数名（类型名 形参1，类型名 形参2，类型名 形参n）&#123;    说明部分    执行部分&#125;\n存储类型说明符&emsp;&emsp;在C语言中，存储类型说明符（Storage Class Specifier）用于定义变量或函数的存储方式、作用域（scope）和生命周期（lifetime）。当提到“说明该函数是内部函数还是外部函数”时，主要涉及两个关键字：static 和 extern。\n\n1. 内部函数（Internal Function）\n使用 static 关键字修饰的函数被称为内部函数。\n内部函数的作用域被限制在定义它的源文件中，其他文件无法访问该函数。\n这种方式可以避免函数名冲突，尤其是在大型项目中。\n\n示例：// 文件1: file1.cstatic void internal_function(void) &#123;    printf(&quot;This is an internal function.\\n&quot;);&#125;void call_internal_function(void) &#123;    internal_function(); // 可以调用，因为它们在同一个文件中&#125;\n\n// 文件2: file2.cextern void call_internal_function(void); // 声明外部函数void try_to_call_internal_function(void) &#123;    // internal_function(); // 错误！无法访问 file1.c 中的内部函数    call_internal_function(); // 正确！可以通过暴露的接口调用&#125;\n\n在这个例子中：\n\ninternal_function 是一个内部函数，只能在 file1.c 中使用。\n其他文件（如 file2.c）无法直接调用 internal_function。\n\n\n2. 外部函数（External Function）\n默认情况下，函数是外部函数，即可以在其他文件中通过 extern 关键字引用。\n外部函数的作用域跨越多个源文件，允许不同文件之间的函数调用。\n\n示例：// 文件1: file1.cvoid external_function(void) &#123;    printf(&quot;This is an external function.\\n&quot;);&#125;\n\n// 文件2: file2.cextern void external_function(void); // 声明外部函数void call_external_function(void) &#123;    external_function(); // 正确！可以调用 file1.c 中的外部函数&#125;\n\n在这个例子中：\n\nexternal_function 是一个外部函数，默认情况下可以在其他文件中通过 extern 引用并调用。\n\n\n3. 总结对比\n\n\n特性\n内部函数 (static)\n外部函数 (默认或 extern)\n\n\n\n作用域\n仅限于定义它的源文件\n跨越多个源文件\n\n\n声明方式\n使用 static 关键字修饰\n不需要额外修饰（默认为外部函数）\n\n\n用途\n避免函数名冲突，封装实现细节\n在多个文件之间共享函数功能\n\n\n是否需要 extern\n不需要\n在其他文件中需要 extern 声明\n\n\n\n4. 实际应用建议\n如果某个函数只在当前源文件中使用，建议将其声明为 static，以减少全局命名空间污染，提高代码的可维护性。\n如果某个函数需要在多个文件中共享，则不需要使用 static，而是通过头文件（.h 文件）声明并导出该函数。\n\n其余几点说明\n函数返回值的类型是用来说明该函数返回值的类型，如果没有返回值，则其类型说明符应该为void。\n函数名和形式参数都是由用户命名的标识符。在同一程序中，函数名必须唯一，形参名只要在同一函数中唯一即可，可以与其它函数中的变量重名。\n若省略了函数返回值的类型默认为int型。\n形参可以省略，称为无参函数。在调用时不用参数。\n函数体中，除形参外，用到的其它变量必须在说明部分进行定义，且可以和其它函数中的变量重名。\n\n函数的返回值return 语句一般形式return(表达式);return 表达式;return;\n\n\nreturn语句中表达式的值就是所求的函数值，且其类型必须与函数首部所说明的类型一致，若类型不一致，则由系统自动转换为函数值的类型。\n在程序执行到return语句时，流程就返回到调用该函数处，并带回函数值。在同一个函数体内，可以在多处return语句。\nreturn语句也可以不含表达式。此时，它只是使流程返回到调用函数，并没有确定的函数值。\n函数体内也可以没有reture语句，程序就一直执行到函数末尾，然后返回到调用函数，此时也没有确定的函数值带回。\n\n","tags":["C Language"]},{"title":"LaTeX学习日志01-前期准备","url":"/Blog/posts/828fd9e/","content":"前言LaTeX 是基于 TeX 的排版系统，用纯文本加命令写作，排版统一且可复用。它会编译为高质量 PDF，尤其适合公式、参考文献和长文档，也便于后期统一调整格式。写作时可更专注内容，把样式交给工具处理。本文记录在 Windows 11 上使用 Tectonic + VS Code + LaTeX Workshop 的前期准备流程。\n◆❖◆\n\n准备清单\nTectonic（LaTeX 引擎）\nVS Code\nLaTeX Workshop 插件\n环境变量 Path（用于命令行调用）\n\n◆❖◆\n\n安装 Tectonic\n打开 Tectonic 官网，点击 Install Tectonic 0.15.0 进入安装页面。\n\n\n\n我更推荐在 GitHub Release 下载。点击 find the latest released binaries on GitHub 进入发行页。\n\n\n\n在发布页找到 Assets。\n\n\n\nWindows 11 x64 建议下载 tectonic-0.15.0-x86_64-pc-windows-msvc.zip（官方 MSVC 原生构建，兼容性最好）。\n\n\n\n解压后将 tectonic.exe 放到固定路径，例如 C:\\Tectonic。\n把该路径加入系统环境变量 Path。\n\n\n\n（可选）命令行验证：tectonic --version。\n\n◆❖◆\n\n安装 VS Code 与 LaTeX Workshop在 VS Code 扩展中搜索并安装 LaTeX Workshop 插件。\n\n安装完成后，使用快捷键 Ctrl+Shift+P 打开用户设置（JSON）。\n\n◆❖◆\n\n配置 LaTeX Workshop找到下面类似的配置，没有的话可以直接复制并按需调整。注意 JSON 语法，不确定就发给 AI 帮你检查。\n&#123;  &quot;workbench.editorAssociations&quot;: &#123;    &quot;*.pdf&quot;: &quot;latex-workshop-pdf-hook&quot;  &#125;,  &quot;latex-workshop.intellisense.biblatexJSON.replace&quot;: &#123;&#125;,  &quot;latex-workshop.latex.tools&quot;: [    &#123;      &quot;name&quot;: &quot;tectonic&quot;,      &quot;command&quot;: &quot;tectonic&quot;,      &quot;args&quot;: [        &quot;--synctex&quot;,        &quot;--keep-logs&quot;,        &quot;--print&quot;,        &quot;%DOC%.tex&quot;      ],      &quot;env&quot;: &#123;&#125;    &#125;  ],  &quot;latex-workshop.latex.recipes&quot;: [    &#123;      &quot;name&quot;: &quot;tectonic&quot;,      &quot;tools&quot;: [&quot;tectonic&quot;]    &#125;  ],  &quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,  &quot;[latex]&quot;: &#123;    &quot;editor.formatOnSave&quot;: false  &#125;,  &quot;latex-workshop.latex.autoBuild.run&quot;: &quot;onSave&quot;,  &quot;latex-workshop.latex.autoBuild.interval&quot;: 500&#125;\n\n完成后保存即可。之后保存 .tex 文件会自动调用 Tectonic 编译，并在 VS Code 内部预览 PDF。\n","categories":["Latex"],"tags":["LaTeX"]},{"title":"第七章——函数 预读节——C程序结构函数","url":"/Blog/posts/e38903bc/","content":"C语言程序结构\n一个C语言程序可以包含多个源程序文件。\n一个源程序文件中可以包含多个函数。\nC语言程序有且仅有一个主函数main作为程序的入口。\n函数是C语言程序的基本单位。\n程序执行从main()函数开始，在main()函数中结束。\n程序只会执行在main()函数中定义的内容，其他函数需要通过调用的方式执行。\n函数之间不能嵌套定义。\n函数之间可以嵌套调用。\n\nC语言程序基本结构展示\nC语言函数分类1.从用户角度\n标准函数（库函数）：由系统提供\n用户自定义函数\n\n2.从函数形式\n无参函数\n有参函数\n\n库函数（标准函数）&emsp;&emsp;系统提供的已设计好的函数\n使用库函数应注意\n函数功能\n函数参数的数目和顺序，及各个参数的意义和类型\n函数的返回值的意义和类型\n需要使用的包含文件\n调用库函数时，必须要使用#include &lt;头文件名.h&gt;\n标准库函数的调用形式：函数名(参数表)\n\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第七章——函数 第四节——函数的递归调用","url":"/Blog/posts/c0079169/","content":"递归调用的定义&emsp;&emsp;函数直接或间接的调用自身叫函数的递归调用。\n示例#include &lt;stdio.h&gt;// 递归函数：计算n的阶乘int factorial(int n) &#123;    // 终止条件：当n为0或1时直接返回1    if (n == 0 || n == 1) &#123;        return 1;  // 基本情况：0! = 1! = 1    &#125; else &#123;        // 递归调用：n! = n * (n-1)!        // 程序执行路径分解（以n=3为例）：        // 1. factorial(3) -&gt; 3 * factorial(2)        // 2. factorial(2) -&gt; 2 * factorial(1)        // 3. factorial(1) -&gt; 返回1（触发终止条件）        // 4. 回溯计算：2*1=2 -&gt; 3*2=6        return n * factorial(n - 1);    &#125;&#125;int main() &#123;    int num = 5;  // 设置输入数值        // 调用递归函数并输出结果    // 执行过程分解：    // factorial(5) -&gt; 5 * factorial(4)    //              -&gt; 5 * 4 * factorial(3)    //              -&gt; 5 * 4 * 3 * factorial(2)    //              -&gt; 5 * 4 * 3 * 2 * factorial(1)    //              -&gt; 5 * 4 * 3 * 2 * 1 = 120    printf(&quot;Factorial of %d is %d\\n&quot;, num, factorial(num));        return 0;&#125;\n流程展示流程展示\n几点说明\nC编译系统对递归函数的自调用次数没有限制\n每调用函数一次，在内存堆栈区分配空间，用于存放函数变量、返回值等信息，所以递归次数过多，可能引起堆栈溢出\n\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第七章——函数 第六节——调用函数和被调用函数之间的数据传递","url":"/Blog/posts/abddebca/","content":"数据传递的三种方式\n实参和形参之间的数据传递\n值传递方式\n方式：函数调用时,为形参分配单元,并将实参的值复制到形参中；调用结束，形参单元被释放，实参单元仍保留并维持原值\n特点：\n形参与实参占用不同的内存单元\n单向传递，即用户不可能在函数中改变对应实参的值\n\n\n\n\n\n\n通过return语句把函数值返回调用函数\n通过全局变量。（不提倡）\n\n\n形参和实参\n形式参数：定义函数时函数名后面括号中的变量名\n实际参数：调用函数时函数名后面括号中的表达式\n\n说明：\n实参必须有确定的值\n\n形参必须指定类型\n\n形参与实参类型一致，个数相同\n\n若形参与实参类型不一致，自动按形参类型转换———函数调用转换\n\n形参在函数被调用前不占内存;函数调用时为形参分配内存；调用结束，内存释放\n\n\n\n地址传递方式&emsp;&emsp;函数调用时，将数据的存储地址作为参数传递给形参。\n特点\n形参与实参占用同样的存储单元\n“双向”传递\n实参和形参必须是地址常量或变量\n\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第七章——函数 第五节——函数的声明","url":"/Blog/posts/88d469c7/","content":"除主函数外，对于用户定义的函数要“先定义，后使用”。&emsp;&emsp;函数说明的一般形式：\n类型名  函数名(参数类型1, 参数类型2, ...)\n示例double  add (double,double)//也可以与普通变量一起出现在定义语句中double x,y,add(double a,double b);\n函数说明的位置\n可在所有函数的外部，被调用之前说明函数\n在调用函数内部说明，只能在该函数内部才能被识别\n\n\n后记&emsp;&emsp;关于声明和定义是完全不同的操作，示例如下：\n// 函数声明double add(double, double);// 主函数int main() &#123;    double x = 3.5, y = 4.2;    printf(&quot;%.2f + %.2f = %.2f\\n&quot;, x, y, add(x, y));    return 0;&#125;// 函数定义double add(double a, double b) &#123;    return a + b;&#125;","tags":["C Language"]},{"title":"第七章——函数 第零节——前言","url":"/Blog/posts/a7eeb4a5/","content":"第七章 函数之法——编程的模块化之道核心能力修炼：掌握三大函数秘术通过本章修炼，你将获得：\n\n破解函数定义的”魔法盒咒语”\n掌握参数传递的”数据桥梁”\n领悟返回值的”结果通道”\n参悟函数声明的”契约精神”\n驯服递归调用的”分形秘法”\n\n知识脉络一、函数三要素\n定义仪式：函数名+参数列表+函数体的三位一体\n参数传递：形参如门户，实参似信使的数据流通法则\n返回机制：结果输出的单行道（return语句的玄机）\n\n二、控制玄机\n作用域法则：局部变量的城堡与全局变量的王国\n递归分形：俄罗斯套娃般的自我调用艺术\n声明契约：头文件中的函数宣言\n\n三、实战应用场\n代码复用：一次编写，四处调用的魔法\n模块拆分：将大问题分解为小函数的庖丁解牛术\n库函数调用：善用标准库的瑞士军刀\n调试隔离：通过函数模块定位问题的探针法\n\n修炼心法&emsp;&emsp;建议用”黑箱思维”观察函数功能，重点参悟参数传递的值拷贝特性。特别注意函数设计的单一职责原则，警惕函数膨胀症。善用注释标注函数功能，调试时可采用printf探针法逐层验证。递归调用需把握基准情形和递归步进两个关键要素。\n","categories":["C_Language","第七章——函数"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第七节——赋值表达式的求值规则","url":"/Blog/posts/d316f5f1/","content":"赋值运算&emsp;&emsp;赋值符号“&#x3D;”就是赋值运算符，它的作用是将一个表达式的值赋给一个变量。赋值运算符的一般形式为：\n变量名 = 表达式a = 3;b = a + 5;c = sum(a, b);\n&emsp;&emsp;如果表达式值的类型，与被赋值变量的类型不一致，但都是数值型或字符型时，系统自动地将表达式的值转换成被赋值变量的数据类型，然后再赋值给变量.\n\n几点说明\n赋值运算符的优先级只高于逗号运算符，比其它的运算符优先级都低，且具有自右向左的结合性。\n赋值运算符不是数学中的“等于号”，而是进行“赋予”操作。\n表达式x&#x3D;y读作“将y的值赋给变量x”而不读作”x等于y“\n赋值运算符左边只能是变量，不能是常量或是表达式。如a+b&#x3D;c就是错误的。\n赋值运算符右边也可以是赋值表达式。如a&#x3D;b&#x3D;7+1,而a&#x3D;7+1&#x3D;b则是错误的。\n“&#x3D;”视作运算符，a&#x3D;19是一个表达式，C语言规定最左边变量中所得到的新值就是赋值表达式的值。\n\n\n复合赋值表达式&emsp;&emsp;复合赋值运算符是由赋值运算符之前再加一个双目运算符构成的。一般格式为：&emsp;&emsp;此表达式等价于：变量  &#x3D;  变量  双目运算符（表达式）&emsp;&emsp;当表达式为简单表达式时，表达式外的一对圆括号才可缺省，否则可能出错。\n&emsp;&emsp;例如：\na += 5; // 等价于 a = a + 5;a -= 5; // 等价于 a = a - 5;y *= x + 6; // 等价于 y = y * (x + 6);\n说明\n结合方向：赋值运算符的结合方向是自右向左。\n左侧必须是变量，不能是常量或者表达式。\n赋值转换规则：使赋值号右边表达式值自动转换成其左边变量的类型。\n赋值表达式的值与变量值相等,且可嵌套，例如：\n\na=b=c=5  //表达式值为5，a,b,c值为5a=(b=5)  //b=5;a=5a=5+(c=6)  //表达式值11，c=6,a=11a=(b=4)+(c=6)  //表达式值10，a=10,b=4,c=6a=(b=10)/(c=2)  //表达式值5，a=5,b=10,c=2\n\n\n赋值运算中的类型转换&emsp;&emsp;   在C语言的赋值表达式中，赋值号右边的值先转换成与左边的变量相同的类型，然后进行赋值。\n注意\n当赋值号左边的变量为短整型，右边的值为长整型时，短整型变量只能接受长整型数据低位上的两个字节的数据，高位上的数据将丢失。也就是说，右边的值不能超过短整型的数值范围。即长整型假设4字节，共有32位，短整型假设2字节，共16位，那么短整型只接受32位的后一半，低16位上的数据，高16位直接丢失。\n当赋值号左边的变量为无符号整型，右边的值为有符号整型时，则把内存中的内容原样复制。右边数据的范围不应超出左边变量可以接受的数据范围。同时要注意，这时负数将转换为正数。\n当赋值号左边的变量为有符号整型，右边的值为无符号整型时，复制的机制同上，这时，若符号位为1，将按负数处理。\n\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第一节——C程序设计的初步知识","url":"/Blog/posts/e6bd15ca/","content":"一、第一个程序 Hello, World!&emsp;&emsp;“Hello, World!”不仅是编程教学的起点，更是连接技术、文化与历史的纽带。它见证了编程语言的演变、开发工具的进步，以及程序员社区的集体智慧。正如前人所述：“所有编程者学习编程的第一步就在于此”，它的地位无可替代，是每位开发者共同的“编程成人礼”。既如此，让我们来看看 C 语言中的第一步要如何编写。\n#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello,World!&quot;);    /*This is your first C Program*/&#125;\n&emsp;&emsp; 此时控制台中会输出如下内容\n二、参数解释&emsp;&emsp; 我们来逐行解释一下这个基本的程序：\n1. #include&lt;stdio.h&gt;\n作用：像“借工具”一样，引入一个叫 stdio.h 的工具包。其中 #include&lt; &gt; 这种系列叫做预处理命令\n比喻：假设你要做一道菜，但厨房里没有锅，这时候你必须先去工具间拿锅。#include&lt;stdio.h&gt; 就像“去工具间拿锅”，其中 #include&lt; &gt; 表示你需要去拿一个锅，stdio.h 是用来干什么的锅，它告诉你程序需要一些基本的工具（比如输出文字到屏幕的功能）。\n为什么需要它？因为 printf（后面会讲）是这个工具包里的一个工具，没有它，计算机就不知道 printf 是什么。\n\n\n2. int main()\n作用：告诉计算机“我的程序从这里开始执行”。\n比喻：这是你写的故事的第一章，也是唯一一章。计算机总是从这里开始读你的程序。\n分解解释：\nint：表示这个“章节”最终会告诉计算机一个整数（比如 0 表示成功，1 表示失败）。\nmain：这是章节的名字，所有 C 程序都必须有一个叫 main 的章节，否则计算机不知道从哪里开始。\n()：暂时不用管，可以理解为“章节的开关”。\n\n\n\n\n3. { 和 }\n作用：包裹代码块，告诉计算机“这部分代码属于 main 章节”。\n比喻：{ 是“打开章节的开关”，} 是“关上开关”。所有写在中间的代码都会在程序运行时执行。\n例子：  int main() &#123; // 开关打开    // 这里的代码会被执行&#125; // 开关关闭\n\n\n4. printf(&quot;Hello,World!&quot;);\n作用：让计算机在屏幕上显示文字。\n比喻：这是你在屏幕上“写一句话”的命令。printf 是一个预定义的“写字工具”，就像打印机一样。\n分解解释：\nprintf：工具的名字，来自刚才的 stdio.h 工具包。\n(&quot;Hello,World!&quot;)：告诉 printf 要写的内容是什么，用双引号括起来。\n;：表示这条命令结束，就像句号一样。没有它，计算机就会迷糊！\n\n\n\n\n5. /*This is your first C Program*/\n作用：写注释（不会影响程序运行）。\n比喻：这是给程序员自己或别人看的“便签纸”，计算机完全忽略它。\n为什么需要注释？比如你写了一段复杂的代码，过几天忘了自己写的是什么，注释就是提醒自己或别人：“这里我做了什么”。\n\n\n6. return 0;\n作用：告诉计算机“程序执行完毕，结果是成功”。\n比喻：这是你在故事的最后一页写“故事结束”，并告诉读者“结局是好的”。\n为什么是 0？  \n在 C 语言中，return 0; 表示程序成功结束。  \n如果程序出错了，可以返回其他数字（比如 return 1; 表示出错）。\n\n\n\n\n整个程序的执行流程\n计算机打开你的程序，先读 #include&lt;stdio.h&gt;，准备好工具包里的工具。\n进入 main() 章节，开始执行里面的代码。\n执行 printf(&quot;Hello,World!&quot;);，在屏幕上显示 Hello,World!。\n执行 return 0;，告诉计算机“任务完成，结果是成功”。\n程序结束。\n\n\n常见问题解答\n为什么要有 #include&lt;stdio.h&gt;？因为 printf 不是 C 语言的“内置功能”，必须通过 #include 借用工具包里的工具才能使用。\n\n为什么 main 必须写成 int main()？  \n\nint 表示这个函数最终会返回一个整数（比如 0）。  \nmain 是程序的入口点，必须这样写，否则计算机不知道从哪里开始。\n\n\n注释可以写在哪里？可以写在代码的任何地方，但必须用 /* 和 */ 包裹，或者用 // 写单行注释（比如 // 这是我的注释）。\n\n为什么要有分号 ;？分号是 C 语言的“句号”，告诉计算机“这条命令结束了”。没有它，计算机就会迷糊，报错。\n\n\n\n三、格式特点1. 习惯上用小写字母，对大小写敏感&emsp;&emsp;即在 C 语言程序中，大写的 ADD 和小写的 add 和混合写的 Add是不同的东西\n\n2. 不使用行号，无程序行概念在 VSC 中，我们可以看到，在我们编辑的代码的左侧，有这样一些数字&emsp;&emsp;这些数字表示 行号，行号主要用于定位代码位置（比如调试时报错会提示错误行号），但它本身不影响程序的执行逻辑。比如，我们可以把程序全部写在一行里面，如下：\n#include&lt;stdio.h&gt;int main()&#123;printf(&quot;test&quot;);return 0;&#125;\n&emsp;&emsp;写出超级长的一行，C 语言也可以执行。因为，C语言的执行顺序完全由代码的语法结构（如函数、语句、控制结构）决定，而不是行号。但是对于人类程序员来说，这要是看功能的话只能去找{}和；了，非常头大，所以我们才要去分行写，即使他没有程序行的概念。&emsp;&emsp;没有程序行这一点与行号相对应，比如经典的 BASIC 编程，作为一种直译式的编程语言，在完成编写后不须经由编译及连结等手续即可执行。他就必须严格按照一行只有一条语句，或者每行代码必须严格对应一个“程序行”，否则会报错。例如\n10 PRINT &quot;HELLO&quot; &#x27; 第10行 20 GOTO 10 &#x27; 第20行\n&emsp;&emsp;这里的行号是语言本身的语法组成部分，程序会严格按照行号顺序执行。&emsp;&emsp;而我们的C语言的语句可以跨多行书写，也可以在一行中写多条语句（用分号分隔）。例如：\nint a = 10 + //这条语句跨两行 20; // 也是可以执行的 printf(&quot;Hi&quot;); printf(&quot;World&quot;); // 一行写两条语句（用分号分隔）\n&emsp;&emsp;C语言以语句为单位，而不是“程序行”。只要语句的语法正确（如以分号结尾），代码如何换行无关紧要。所以你甚至可以整一堆花活\n\n3. 可使用空行和空格&emsp;&emsp; 先看如下实例：\n#include &lt;stdio.h&gt;int main() &#123;\t// 定义变量\tint a = 10;\tint b = 20;\tint sum;\t\t// 计算和\tsum = a + b;\t\t// 输出结果\tprintf(&quot;The sum of %d and %d is %d\\n&quot;, a, b, sum); \treturn 0; &#125;\n&emsp;&emsp;我们把它放在 VSC 里面看看行号&emsp;&emsp;我们可以清晰地看到第 2、8、11、14 行都是没有东西的，而我们的 a&#x3D;10 或者 Printf 里面每个词之间加了一个空格。我们运行之后得到如下输出：\nThe sum of 10 and 20 is 30\n&emsp;&emsp;可以看到依旧可以正常运行。所以可以得出如下结论：\n\n空行的使用：\n\n在变量定义、计算逻辑和输出结果之间插入空行，将代码划分为清晰的逻辑块。\n作用：通过视觉分隔增强代码结构，便于快速理解功能模块。\n\n\n空格的使用：\n\n赋值语句：int a = 10; 中在 = 两侧添加空格，使语法更易读。\n函数调用：printf(&quot;...&quot;) 的参数间（如 , a, b, sum）通过空格分隔，减少视觉混乱。\n作用：通过合理间距提升代码的可读性，减少语法理解成本。\n\n\n\n\n4. 常用锯齿形书写格式&emsp;&emsp;锯齿形示例如下\n#include &lt;stdio.h&gt;  int main() &#123;    for (int i = 1; i &lt;= 3; i++) &#123;        printf(&quot;Outer loop iteration: %d\\n&quot;, i);          for (int j = 1; j &lt;= 2; j++) &#123;            printf(&quot;  Inner loop iteration: %d\\n&quot;, j);        &#125;    &#125;      return 0;&#125;\n&emsp;&emsp;“锯齿形书写格式”通常指通过代码缩进形成的层次化结构，每一层代码向右缩进，形成类似“锯齿”的视觉效果。这种格式能清晰展示代码的嵌套关系，提升可读性。我们通常第一层级顶格，第二层级用一个 TAB 或者 4 个空格，第三层级两个 TAB 或者 8 个空格，以此类推的形成一层一层的结构。不过我更习惯 TAB，谁会去没事按空格呢。\n\n四、结构特点1. 函数与主函数\n程序组成C 语言程序由一个或多个函数组成，每个函数负责特定任务。示例：  \nvoid printHello() &#123; printf(&quot;Hello, World!\\n&quot;); &#125;  // 辅助函数\n\n主函数唯一性程序必须且只能有一个主函数 main()，它是程序的入口点。示例：  \nint main() &#123; ... &#125;  // 必须存在且唯一\n\n执行流程程序从 main() 开始执行，其他函数通过嵌套调用执行。完整示例：  \n#include &lt;stdio.h&gt;void printHello() &#123; printf(&quot;Hello, World!\\n&quot;); &#125;int main() &#123;    printHello();  // 调用辅助函数    return 0;&#125;\n\n\n2. 程序语句\n语句定义C 程序由语句构成，每条语句执行一个操作。  \n分号终止符每条语句必须以分号 ; 结尾。示例：  int a = 5;         // 变量声明与初始化a = a + 1;         // 表达式语句printf(&quot;%d\\n&quot;, a); // 函数调用语句\n\n\n3. 注释\n注释语法使用 /* ... */ 表示多行注释，不能嵌套。  \n编译忽略注释内容在编译时会被忽略，不生成代码。示例：  #include &lt;stdio.h&gt;int main() &#123;    /* 这是多行注释，不会被编译 */    int x = 10;  // 单行注释（// 语法也可用）    printf(&quot;x = %d\\n&quot;, x);    return 0;&#125;\n\n\n4. 预编译命令预编译命令以 # 开头，用于在编译前对代码进行处理（如包含头文件、定义宏等）。以下是常见预编译命令及示例：\n\n1. #include作用：包含头文件，引入外部函数、宏定义或类型声明。示例：  \n#include &lt;stdio.h&gt;      // 包含标准输入输出库（系统头文件）#include &quot;myheader.h&quot;   // 包含用户自定义的头文件（需提供路径）\n\n\n2. #define作用：定义宏（常量或代码片段）。示例：  \n#define PI 3.14159      // 定义常量宏#define SQUARE(x) (x * x)  // 定义函数式宏int area = PI * SQUARE(radius);  // 使用宏计算面积\n\n\n3. 条件编译命令用于根据条件编译不同代码块，常见命令包括：  \n\n#ifdef &#x2F; #ifndef：检查宏是否定义。  \n#if &#x2F; #elif &#x2F; #else：根据条件判断。  \n#endif：结束条件编译。\n\n示例：  \n#ifdef DEBUG  // 如果定义了DEBUG宏    printf(&quot;Debug mode: value = %d\\n&quot;, value);#else    // 无DEBUG宏时的代码#endif#if VERSION == 2  // 根据版本号选择代码    printf(&quot;Version 2\\n&quot;);#elif VERSION == 3    printf(&quot;Version 3\\n&quot;);#else    printf(&quot;Unknown version\\n&quot;);#endif\n","tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第三节——C语言基本数据类型及其定义规则","url":"/Blog/posts/fcadce25/","content":"一、常量&emsp;&emsp;在生活中，我们常常会有一些不需要去更改的数值，比如说一天，我们知道他就是 24 小时，比如说 1 小时，他就绝对是 60 分钟，诸如此类的。像这种在程序运行时不会改变的值，我们称作常量。\n1. 定义&emsp;&emsp;程序运行时其值不能改变的量（即常数）\n2. 分类- 符号常量&emsp;&emsp;由用户用标识符所定义的常量，称为符号常量\n\n格式：#define      符号常量&emsp;&emsp; 常量\n\n#define PI 3.14159//定义一个PI常量为3.14159\n\n一般使用大写字母作为常量名\n是宏定义预处理命令，不是C语句\n\n- 直接常量\n整型常量  \n实型常量  \n字符常量 \n字符串常量&emsp;&emsp; 接下来我们分别来讲一下直接常量\n\n\n二、整型常量（整常数）1. 形式&emsp;&emsp;一般来说，整型常量我们有如下三种类型，分别对应不同的进制\n\n十进制整数：由数字0~9和正负号表示.如 123,-456,0\n八进制整数：由数字0开头,后跟数字0~7表示.如0123,011\n十六进制整数：由0x开头,后跟09,af,A~F表示. 如0x123,0Xff\n\n&emsp;&emsp; 对于进制之间的相互转换此处不做教学，兴趣的可以自己学学。&emsp;&emsp; 其中十进制整数有正负，而八进制，十六进制没有正负，仅能以正数存在。\n2. 类型\n根据其值所在范围确定其数据类型\n在整常量后加字母l或L，认为它是long int 型常量\n\n\n补充：整数在内存中的存储形式&emsp;&emsp; 基于在计算机中，存储数据均是以 0 和 1 的二进制作为基准。此时，存储正数很好理解，比如 5，以八位二进制为主，表示为0000 0101，但是负数就比较有意思了，比如-5，就不能单纯的表示为**-0000 0101**。\n&emsp;&emsp;此时我们引入两个新的概念， 有符号整数 和 无符号整数。\n\n有符号整数：最高位是符号位（0是正，1是负）。\n无符号整数：所有位都是数值，没有符号位。\n\n&emsp;&emsp;然后，我们表示负数的话，需要基于有符号整数，再度引入一个概念叫做补码。\n\n补码的简单规则：\n先写出正数的二进制（比如5是 0000 0101）。\n全部取反（0变1，1变0）→ 1111 1010。\n加1 → 1111 1011。这就是-5 的补码\n\n\n\n&emsp;&emsp;这样设计的好处就是，可以直接用加法电路计算正负数，计算机处理起来更方便。&emsp;&emsp; 此时再来分别看一下 有符号整数 和 无符号整数。\n\n正数：比如 5 → 0000 0101\n负数：比如 -5 → 1111 1011\n最大正数（无符号）：所有位都是 1 → 1111 1111 → 255（因为 2⁸ -1 &#x3D; 255）。\n最大负数（有符号，最高位0 是正，1 是负）：最高位是 1，其他为 0 → 1000 0000 → -128（因为 2⁷ &#x3D; 128）。&emsp;&emsp; 总结就是，计算机用0和1的开关组合表示数字，正数直接存，负数用“补码”存，内存里存的是二进制，具体数值要看类型（有符号&#x2F;无符号）和位数。所以比较有意思的就是，在不指明类型的情况下，有可能-1&#x3D;65535.\n\n\n三、C语言基本数据类型及其定义规则1. 常量在生活中，我们常常会有一些不需要去更改的数值，比如说一天有24小时，1小时等于60分钟。在程序中这些固定值就叫做常量。\n#define PI 3.14159  // 符号常量示例int main() &#123;    printf(&quot;圆周率大约是：%.5f\\n&quot;, PI);    return 0;&#125;\n\n1.1 分类\n符号常量：用#define定义的常量，如上面的PI\n字面常量：直接写出的数字或字符，如123、3.14、&#39;A&#39;\n\n1.2 注意事项\n常量一旦定义就不能修改\n建议使用全大写字母命名常量（约定俗成）\n\n2. 变量与常量相对的是变量，它的值可以在程序运行过程中改变。\nint age = 20;        // 整型变量float price = 9.99f;   // 单精度浮点数char grade = &#x27;B&#x27;;      // 字符型变量int main() &#123;    printf(&quot;年龄：%d\\n&quot;, age);    printf(&quot;价格：%.2f\\n&quot;, price);    printf(&quot;等级：%c\\n&quot;, grade);        // 修改变量值    age = 21;    printf(&quot;明年年龄：%d\\n&quot;, age);        return 0;&#125;\n\n2.1 数据类型C语言中有以下常用基本数据类型：\n\n\n\n类型\n关键字\n典型用途\n\n\n\n整型\nint\n存储整数\n\n\n浮点型\nfloat&#x2F;double\n存储小数\n\n\n字符型\nchar\n存储单个字符\n\n\n无值型\nvoid\n表示没有类型\n\n\n2.2 变量命名规则\n只能使用字母、数字和下划线\n首字符不能是数字\n区分大小写（age和Age不同）\n不能使用关键字（如int、return等）\n推荐使用有意义的名字（如studentName而不是x）\n\n\n四、实型常量（实数或浮点数）1. 表示形式\n十进制数形式：（必须有小数点） 如0.123, .123, 123.0, 0.0, 123.\n指数形式：（e或E之前必须有数字；指数必须为整数）如12.3e3 ,123E2, 1.23e-4\n\n2. 实型常量的类型&emsp;&emsp;在 C 语言中，象是类似于 3.14，0.5 之类的数字，默认会是 double 的类型，如下\ndouble d = 3.14; // 3.14 默认是 double 类型，直接赋值给 double 变量没问题。 float f = 3.14; // 错误！虽然可以编译，但 3.14 是 double，赋值给 float 可能导致精度丢失，编译器会警告。\n&emsp;&emsp;如果我们想明确为 float 型，则需如下定义：\nfloat f = 3.14f; //正确！`3.14f` 明确指定为 float 类型。 float g = 0.5F; //同样有效，`F` 和 `f` 效果相同。\n&emsp;&emsp;对于如何选择 double 和 float，需要看自己的精度需求\n\n\n\n特性\ndouble（默认）\nfloat（加 f/F）\n\n\n\n内存占用\n通常 8 字节\n通常 4 字节\n\n\n精度\n高（15-17 位有效数字）\n低（6-9 位有效数字）\n\n\n注意：在内存中，实数一律是以指数形式存储的&emsp;&emsp;实数（如 3.14、1.23e-4）在内存中以二进制科学计数法的形式存储，即 符号位 + 指数部分 + 尾数部分。这种设计可以同时满足以下需求：\n\n表示极大或极小的数值（如天文数字或量子物理中的微小值）。\n节省存储空间（通过指数压缩数值范围）。\n平衡精度与范围（通过尾数位数控制有效数字）。\n\n\n&emsp;&emsp;以 3.14159 为例，分步说明其如何被转换为二进制指数形式并存储：\n1. 转换为二进制科学计数法\n十进制转换为二进制：  &emsp;&emsp;3.14159 的二进制表示为 11.001001000011111101101...（精确二进制可能无限长，但内存中只能存储有限位数）。\n\n规范化：  &emsp;&emsp;将二进制数写成 1.xxxxx… × 2^指数 的形式：  11.001001000011111101101…_{2} &#x3D;1.1001001000011111101101… _{2} ×2^{2} \n  &emsp;&emsp;规范化的目的是统一格式，确保尾数部分的二进制数在 [1.0, 2.0) 范围内（二进制中最高位隐含为 1，无需存储）。\n\n\n2. 分配内存空间（以 float 为例）\nfloat 类型：占 4字节（32位），按以下结构存储：\n\n符号位(1位) | 阶码(8位) | 尾数(23位)\n\n符号位（Sign）：  0 表示正数，1 表示负数。例如 3.14159 是正数 → 符号位为 0。\n\n阶码（Exponent，指数部分）：  &emsp;&emsp;将指数 2 加上一个偏移量（float 的偏移量是 127），得到 2 + 127 = 129，然后转换为二进制：\n  \n  129_{10} =10000001_{2} \n  \n  &emsp;&emsp;这样，指数部分存储为 `10000001`。\n  \n尾数（Mantissa，有效数字部分）：&emsp;&emsp;规范化后的二进制数 1.1001001000011111101101... 中，去掉前面隐含的 1，只存储小数点后的部分：\n  1001001000011111101101…→取前23位→10010010000111111011011\n\n\n&emsp;&emsp;尾数部分存储为 10010010000111111011011。\n3. 最终内存存储形式&emsp;&emsp;将符号位、阶码和尾数按顺序拼接：\n0(符号)∥10000001(阶码)∥10010010000111111011011(尾数)0(符号)∥10000001(阶码)∥10010010000111111011011(尾数)\n&emsp;&emsp;二进制表示：\n0100000011001001000011111101101101000000110010010000111111011011\n\n&emsp;&emsp;十六进制表示（方便阅读）：\n40490FD7_{16}\n\n计算机中存储整数不会出现误差，存储实型数往往存入误差。&emsp;&emsp; 从上面的存储方式可以看出来，小数的存储方式极其复杂，并且会有一定的舍弃，这一部分舍弃也就造就了计算机在存储实型数据是会产生误差，而我们的整数因为只需要将其转换后便可以存储，所以并不会出现误差。\n\n三、字符常量1. 定义&emsp;&emsp;用单引号括起来的单个普通字符或转义字符，例如 &#39;a&#39;、&#39;C&#39;、&#39;7&#39;、&#39;\\n&#39; 等等，包括大小写字母，数字，标点符号，特殊符号，转义字符。\n2. 字符常量的值&emsp;&emsp;该字符的ASCII码值，在 ASCII 表中，每个字符都有对应的码值。在内存中以 ASCII码 的形式存储为整数（占1个字节）。例如 &#39;A&#39; 的ASCII码是 65，&#39;0&#39; 是 48。\n3. 转义字符&emsp;&emsp;反斜线后面跟一个字符或一个代码值表示，用来表示一些不可见或特殊功能的字符。部分举例如下：\n\n\n\n转义字符\n含义\nASCII码\n\n\n\n&#39;\\n&#39;\n换行符\n10\n\n\n&#39;\\t&#39;\n制表符（横向跳格）\n9\n\n\n&#39;\\r&#39;\n回车符\n13\n\n\n&#39;\\b&#39;\n退格符\n8\n\n\n&#39;\\&#39;&#39;\n单引号 &#39;\n39\n\n\n‘&quot;‘&#96;\n双引号 &quot;\n34\n\n\n&#39;\\\\&#39;\n反斜杠 \\\n92\n\n\n&#39;\\0&#39;\n空字符（结束符）\n0\n\n\n4. 非法的字符常量使用双引号&emsp;&emsp;”A” 是字符串常量，不是字符常量。\n多个字符&emsp;&emsp;’AB’ 是非法的，单引号内只能有一个字符。\n缺少反斜杠的转义字符&emsp;&emsp;如果想表示单引号  &#39;，必须写成  &#39;\\&#39;&#39;，而不是 &#39;（否则单引号会被当作结束符）。\n\n四、字符串常量1. 定义&emsp;&emsp;用双引号(“”)括起来的字符序列，在之前的字符常量中，仅能表示单个字符，而字符串常量能表示好多，比如”ASDFGHJK”\n2.存储&emsp;&emsp;每个字符串尾自动加一个 \\0 作为字符串结束标志&emsp;&emsp; 以存储一个 Hello 为例\n\n\n\nH\nE\nL\nL\nO\n\\0\n\n\n\n0\n0\n0\n0\n0\n0\n\n\n&emsp;&emsp; 同时，字符串常量也可以是空串，即什么都没有 &quot; &quot;，在内存中为\n\n\n\n\\0\n\n\n\n0\n\n\n&emsp;&emsp; 字符串常量和字符常量也是有区别的，比如字符常量 &#39;a&#39; 和字符串常量 &quot;a&quot;，在内存中如下：\n\n\n\n字符常量\n字符串常量\n\n\n\na\na \\0\n\n\n\n五、变量&emsp;&emsp;变量，看名字就可以看出来，他与常量不同，是可以变化的一个值。\n1. 概念&emsp;&emsp;其值可以改变的量\n2. 特点\n变量初始化：在C语言中，变量是需要初始化的，因为变量在存储时，需要从内存单元中获取到值，而我们的内存并不会真正意义上的“删除”，只是去“覆盖”，所以说当我们的变量没有初始化时，那从内存中读到的值就可能是一些无用的杂乱数据，会对程序的运行造成影响，因此我们需要对变量进行初始化。\n\n变量的使用：变量的使用必须遵守“先定义后使用” 的规则，如下：\n\n\n// 定义方法一int main01()&#123;    int a , b , c;    a = 10;    b = 20;    c = a + b;    printf(&quot;%d + %d = %d&quot;, a , b , c);    return 0;&#125;//定义方法二int main02()&#123;    int a = 10;    int b = 20;    int c = a + b;    printf(&quot;%d + %d = %d&quot;, a , b , c);    return 0;&#125;\n&emsp;&emsp;两种写法的区别是分不分行，作用上相同，我个人是习惯，如果变量在三个一下，使用第二种写法，如果变量超过三个，使用第一种写法。（前提是变量类型相同）\n3. 变量定义的位置&emsp;&emsp;变量一般来说按照如上写法写，但是不排除有特殊情况（比如临时需要一个）\n\n六、整型变量\n整型变量，即整数类型变量，占字节数随机器的不同而不同，一般只占一个机器字（机器字：即CPU一次能处理的二进制数据的位数，由寄存器和数据总线宽度决定。如32位CPU，则机器字一次只能处理32位的二进制数据，换算之后也就是四字节，同样的，64位CPU，则机器字一次只能处理64位的二进制数据，换算之后也就是8字节）。\n在整型变量中，共有三种数据类型，分别是：short、int、long。三者在范围上：short &le; int &le; long。\n在不同机器上，三个类型范围有所不同。具体的我们可以使用sizeof函数来查看。sizeof函数用于获取 数据类型 或 变量 在内存中所占的 字节数。\n\n\n七、实型变量&emsp;&emsp;说完整形，我们来说说实型变量（我习惯叫浮点型，从python那边带过来的习惯了，有时候我可能会把实型叫浮点型，但是为了避免混淆，还是叫实型变量）。实型变量共有两种类型，分别是：float、double。\n\nfloat：float类型占4个字节，float类型在计算机中占4个字节，float类型在计算机中的存储方式就是小数点后保留6位，也就是6位小数。\ndouble：double类型占8个字节，double类型在计算机中占8个字节，double类型在计算机中的存储方式就是小数点后保留15位，也就是15位小数。\n\n&emsp;&emsp;两种类型输出如下：\n#include &lt;stdio.h&gt;int main()&#123;    float a = 10.123456789;    double b = 10.123456789;    printf(&quot;float a = %f\\n&quot;, a);    printf(&quot;double b = %f\\n&quot;, b);    return 0;&#125;\n&emsp;&emsp;输出结果为：\nfloat a = 10.123457double b = 10.123457\n&emsp;&emsp;这时候有个疑问就是，为什么输出的float a &#x3D; 10.123457，而double b也是等于10.123457呢？在此我们还要注意一个就是我们在使用printf函数时，要考虑到占位符%f的精度，默认情况下，%f的精度只有6位小数，我们要是想输出高i精度的数据，则需要对占位符进行修改，比如：%.10f，这种类型的格式化输出表示输出10位小数。\n\n八、字符型变量&emsp;&emsp;字符变量，也叫字符型变量，在C语言中，字符变量通常存储的是字符的ASCII码值，而ASCII码值是数字，只占一个字节，所以其实可以与int数据之间进行运算，举例如下：\n#include &lt;stdio.h&gt;int main()&#123;    char a = &#x27;a&#x27;;    printf(&quot;a = %d\\n&quot;, a);    return 0;&#125;\n&emsp;&emsp;输出结果为：\na = 97\n&emsp;&emsp;基于此，我们便有以下玩法：\n#include &lt;stdio.h&gt;int main()&#123;    char a = &#x27;a&#x27;;    int b = 30;    int x = a + b;    int y = ‘！’ + b + a;    printf(&quot;a = %d\\n&quot;, a);    printf(&quot;b = %d\\n&quot;, b);    printf(&quot;x = %d\\n&quot;, x);    printf(&quot;y = %d\\n&quot;, y);    return 0;&#125;\n&emsp;&emsp;输出结果为：\na = 97b = 30x = 127y = 160\n&emsp;&emsp;不仅仅是与int型相加，更好玩的还有float和double型相加。我们逐个来讲：\nchar与float相加\n1. 类型转换规则当 char 和 float 进行运算时，会发生以下隐式类型转换：\n\nchar → int：char 是整数类型（1字节），先被提升为 int（4字节）。\nint → float：提升后的 int 再被转换为 float（4字节），因为 float 的优先级高于 int。\n运算结果类型为 float：最终运算结果以 float 类型存储。\n\n\n2. 具体示例示例 1：char 与 float 相加#include &lt;stdio.h&gt;int main() &#123;    char c = &#x27;A&#x27;;      // ASCII码值为 65    float f = 3.14f;    float result = c + f;  // char -&gt; int -&gt; float    printf(&quot;Result: %f\\n&quot;, result);  // 输出 68.140000    return 0;&#125;\n解释：\n\nc 的 ASCII 码值为 65。\n65 被提升为 int 类型（65），再转换为 float 类型（65.0）。\n65.0 + 3.14 &#x3D; 68.14，结果存储为 float 类型。\n\n\n示例 2：有符号 char 的负值#include &lt;stdio.h&gt;int main() &#123;    signed char c = -10;  // 有符号 char 的负值    float f = 2.5f;    float result = c + f;  // -10 -&gt; -10.0 -&gt; -7.5    printf(&quot;Result: %f\\n&quot;, result);  // 输出 -7.500000    return 0;&#125;\n解释：\n\n有符号 char 的 -10 被提升为 int 类型（-10），再转换为 float 类型（-10.0）。\n-10.0 + 2.5 &#x3D; -7.5，结果为 float 类型。\n\n\n3. 注意事项(1) 无符号 char 的转换如果 char 是 unsigned char，其范围为 0~255，转换规则类似：\nunsigned char c = 200;  // 无符号 char 的最大值为 255float f = 50.5f;float result = c + f;    // 200 -&gt; 200.0 -&gt; 250.5printf(&quot;Result: %f\\n&quot;, result);  // 输出 250.500000\n\n(2) 精度问题虽然 char 的范围较小（-128127 或 0255），但 float 的精度足够表示这些整数，因此不会出现精度损失。但如果 char 的值通过复杂计算得到，需注意浮点数的舍入误差：\nfloat a = 0.1f;float b = 0.2f;char c = &#x27;A&#x27;;  // 65float result = a + b + c;  // 0.3 + 65.0 = 65.3printf(&quot;Result: %f\\n&quot;, result);  // 输出 65.300003（可能因舍入误差略有偏差）\n\n(3) 避免直接比较由于浮点数的精度问题，不建议直接用 == 比较 char 和 float 的值：\nchar c = &#x27;A&#x27;;  // 65float f = 65.0f;if (c == f) &#123;  // 实际比较的是 65.0f == 65.0f，结果为真    printf(&quot;Equal\\n&quot;);&#125;\n但注意：如果 f 是通过计算得到的近似值（如 f = 65.000001），比较结果可能为假。\n\n4. 显式类型转换为了代码的清晰性，可以显式转换 char 为 float：\nchar c = &#x27;B&#x27;;  // ASCII码值为 66float f = 1.5f;float result = (float)c + f;  // 66.0 + 1.5 = 67.5printf(&quot;Result: %f\\n&quot;, result);  // 输出 67.500000\n\n\nchar与double相加\n1. 类型转换规则当 char 与 double 相加时，会发生以下隐式类型转换：\n\nchar → int：char 是整数类型（1字节），先被提升为 int（4字节）。\nint → double：提升后的 int 再被转换为 double（8字节），因为 double 的优先级高于 int。\n运算结果类型为 double：最终运算结果以 double 类型存储。\n\n\n2. 示例代码示例 1：基本运算#include &lt;stdio.h&gt;int main() &#123;    char c = &#x27;A&#x27;;      // ASCII码值为 65    double d = 3.14;    double result = c + d;  // char -&gt; int -&gt; double    printf(&quot;Result: %f\\n&quot;, result);  // 输出 68.140000    return 0;&#125;\n解释：\n\nc 的 ASCII 码值为 65。\n65 被提升为 int 类型（65），再转换为 double 类型（65.0）。\n65.0 + 3.14 &#x3D; 68.14，结果存储为 double 类型。\n\n\n示例 2：无符号 char 的负值#include &lt;stdio.h&gt;int main() &#123;    signed char c = -10;  // 有符号 char 的负值    double d = 2.5;    double result = c + d;  // -10 -&gt; -10.0 -&gt; -7.5    printf(&quot;Result: %f\\n&quot;, result);  // 输出 -7.500000    return 0;&#125;\n解释：\n\n有符号 char 的 -10 被提升为 int 类型（-10），再转换为 double 类型（-10.0）。\n-10.0 + 2.5 &#x3D; -7.5，结果为 double 类型。\n\n\n3. 注意事项(1) 无符号 char 的转换如果 char 是 unsigned char，其范围为 0~255，转换规则类似：\nunsigned char c = 200;  // 无符号 char 的最大值为 255double d = 50.5;double result = c + d;    // 200 -&gt; 200.0 -&gt; 250.5printf(&quot;Result: %f\\n&quot;, result);  // 输出 250.500000\n\n(2) 精度问题虽然 char 的范围较小（-128127 或 0255），但 double 的精度足够表示这些整数，因此不会出现精度损失。但如果 char 的值通过复杂计算得到，需注意浮点数的舍入误差：\ndouble a = 0.1;double b = 0.2;char c = &#x27;A&#x27;;  // 65double result = a + b + c;  // 0.3 + 65.0 = 65.3printf(&quot;Result: %f\\n&quot;, result);  // 输出 65.300003（可能因舍入误差略有偏差）\n\n(3) 避免直接比较由于浮点数的精度问题，不建议直接用 == 比较 char 和 double 的值：\nchar c = &#x27;A&#x27;;  // 65double d = 65.0;if (c == d) &#123;  // 实际比较的是 65.0 == 65.0，结果为真    printf(&quot;Equal\\n&quot;);&#125;\n但注意：如果 d 是通过计算得到的近似值（如 d = 65.000001），比较结果可能为假。\n\n4. 显式类型转换为了代码的清晰性，可以显式转换 char 为 double：\nchar c = &#x27;B&#x27;;  // ASCII码值为 66double d = 1.5;double result = (double)c + d;  // 66.0 + 1.5 = 67.5printf(&quot;Result: %f\\n&quot;, result);  // 输出 67.500000\n\n\n总结&emsp;&emsp;虽然说这种玩法好玩，但实际开发中，应该避免这种做法。，因为要考虑到精度，还有遵循隐式类型转换规则，其实也是个很麻烦的东西。\n\n&emsp;&emsp;需要注意的是，没有字符串变量，用字符数组存放一整串的那种 \n","tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第六节——算术运算符的优先级顺序","url":"/Blog/posts/81e6655b/","content":"算术运算符的优先级&emsp;&emsp;一般来说，算术运算符的优先级顺序如下：\n\n\n\n类型\n常见运算符\n优先级\n\n\n\n\n()\n最高\n\n\n单目\n++, –\n其次\n\n\n双目\n+ , - , % , &#x2F; , *\n再次\n\n\n三目\n?:\n最后\n\n\n&emsp;&emsp;此处优先级类似于我们常说的“先乘除后加减”这种顺序\n算术运算符和圆括号的结合性&emsp;&emsp;所谓结合性是指，当一个操作数两侧的运算符具有相同的优先级时，该操作数是先与左边的运算符结合，还是先与右边的运算符结合。\n&emsp;&emsp;自左至右的结合方向，称为左结合性。反之，称为右结合性。&emsp;&emsp;结合性是Ｃ语言的独有概念。&emsp;&emsp;除 单目运算符、赋值运算符和条件运算符 是右结合性外，其它运算符都是左结合性。\n&emsp;&emsp;例如，算术运算符的结合方向是“自左至右”，即：&emsp;&emsp;在执行“a – b + c”时，变量b先与减号结合，执行“a - b”；&emsp;&emsp;然后再执行加c的运算。\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第二节——标识符的命名规则","url":"/Blog/posts/7913860b/","content":"一、什么是标识符说到标识符，一般来说，能大概理解，但是不知道实质。但是，当我们将标识符换种说法——名称，应该就会好理解一点。名称可以用来干什么，名称可以给一个东西进行标记，比如箱子，瓶子这种。而标识符，就是用来标识变量、符号常量、函数、数组、类型、标号以及一些具有专门含义的有效字符序列。\n\n二、标识符的分类1. 关键字数据类型关键字 - 12个\n\n\n名称\n作用\n\n\n\nchar\n声明字符型变量（通常占1字节）。\n\n\nshort\n声明短整型变量（通常占2字节）。\n\n\nint\n声明基本整型变量（通常占4字节）。\n\n\nlong\n声明长整型变量（通常占4或8字节，取决于系统）。\n\n\nfloat\n声明单精度浮点型变量（占4字节）。\n\n\ndouble\n声明双精度浮点型变量（占8字节）。\n\n\nsigned\n声明有符号类型变量（默认整型为signed）。\n\n\nunsigned\n声明无符号类型变量（只能存储非负数）。\n\n\nstruct\n定义结构体（struct）类型。\n\n\nunion\n定义共用体（union）类型，同一内存区域存储不同成员。\n\n\nenum\n定义枚举类型（enum），用符号名表示整数值。\n\n\nvoid\n表示“无类型”，用于函数无返回值、无参数或空指针。\n\n\n控制语句关键字 - 12个\n\n\n名称\n作用\n\n\n\nif\n条件判断语句，执行分支代码（与else配合使用）。\n\n\nelse\n与if配合，表示条件不满足时的分支。\n\n\nswitch\n多路分支语句，根据表达式值选择执行不同case。\n\n\ncase\nswitch语句中的分支标签，匹配值后执行代码。\n\n\ndefault\nswitch语句中的默认分支（当无匹配case时执行）。\n\n\nfor\n循环语句，通过初始化、条件和迭代表达式控制循环。\n\n\nwhile\n循环语句，重复执行代码块直到条件不满足。\n\n\ndo...while\n循环语句，先执行代码块再检查条件（至少执行一次）。\n\n\nbreak\n跳出当前循环或switch语句。\n\n\ncontinue\n跳过当前循环迭代，直接进入下一轮循环。\n\n\ngoto\n无条件跳转到程序中带标签的语句（不推荐频繁使用）。\n\n\nreturn\n从函数中返回，并可携带返回值（若函数类型非void）。\n\n\n存储类型关键字 - 4个\n\n\n名称\n作用\n\n\n\nauto\n声明自动变量（默认类型，通常省略，存储在栈中，生命周期为作用域内）。\n\n\nextern\n声明变量或函数在其他文件中定义（用于引用外部定义的全局变量或函数）。\n\n\nregister\n建议编译器将变量存入寄存器（提高访问速度，但现代编译器较少依赖此关键字）。\n\n\nstatic\n声明静态变量：局部静态变量保留值，全局静态变量仅在本文件可见。\n\n\n其它关键字 - 4个\n\n\n名称\n作用\n\n\n\nconst\n声明常量，值不可修改（如const int MAX = 10;）。\n\n\nsizeof\n计算数据类型或变量的内存占用字节数（如sizeof(int)或sizeof(var)）。\n\n\ntypedef\n为类型定义别名（如typedef long long LL;）。\n\n\nvolatile\n声明变量可能被外部隐含修改（禁用编译器优化，如硬件寄存器或中断变量）。\n\n\n2. 预定义标识符&emsp;&emsp;一般指C语言提供的库函数名和编译预处理命令。比如常用的 printf 等等，这些名称是固定的用途，不可以在用来干别的。\n3. 用户标识符&emsp;&emsp;在编程时，需要用户给一些变量、函数、数组等命名，这类由用户根据需要自定义的标识符称为用户标识符。\n\n三、命名标识符的规范1. 组成\n只能由字母、数字、下划线组成，并且第一个字符必须是字母或者下划线\n大小写十分敏感，Sum，SUM，sum 是三个变量！\n不能使用之前提到的关键字\n\n2. 长度&emsp;&emsp;虽然我们现在的 VSC 理论上变量长度可以达到 1 K 字符以上，但是为了兼容旧平台等，所以建议不要超过 31 个字符。\n3. 命名原则\n一般要求是见到变量名字就要知道这个变量是干什么的\n不要用容易混淆的字符，比如网上很火的大写 I 和小写 l 之类的那种奇怪的东西\n\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第五节——常见算术运算符的使用","url":"/Blog/posts/64c569a5/","content":"常见算术运算符在C语言中，我们常见的算术运算符及其作用如下表所示：\n算术运算符一览\n\n\n运算符\n名称\n示例\n说明\n\n\n\n+\n加法\na + b\n计算两个数的和\n\n\n-\n减法\na - b\n计算两个数的差\n\n\n*\n乘法\na * b\n计算两个数的积\n\n\n/\n除法\na / b\n计算两个数的商（整数除法会舍去小数部分）\n\n\n%\n取模\na % b\n返回两个数相除的余数（仅适用于整数）\n\n\n++\n自增\na++ 或 ++a\n将变量的值增加1\n\n\n--\n自减\na-- 或 --a\n将变量的值减少1\n\n\n示例代码#include &lt;stdio.h&gt;int main() &#123;    int a = 10, b = 3;        printf(&quot;加法: %d + %d = %d\\n&quot;, a, b, a + b);    printf(&quot;减法: %d - %d = %d\\n&quot;, a, b, a - b);    printf(&quot;乘法: %d * %d = %d\\n&quot;, a, b, a * b);    printf(&quot;除法: %d / %d = %d\\n&quot;, a, b, a / b);  // 整数除法    printf(&quot;取模: %d %% %d = %d\\n&quot;, a, b, a % b);        float c = 10.0f, d = 3.0f;    printf(&quot;浮点除法: %.1f / %.1f = %.2f\\n&quot;, c, d, c / d);        int e = 5;    printf(&quot;自增前: %d\\n&quot;, e);    printf(&quot;自增后: %d\\n&quot;, e++);    printf(&quot;再次查看: %d\\n&quot;, e);        return 0;&#125;\n\n注意事项\n整数除法：当两个整数相除时，结果会被截断为整数部分（例如 10 / 3 的结果是 3）。\n浮点数除法：如果希望得到精确的小数结果，至少有一个操作数应为浮点类型。\n取模运算符 %：只能用于整数类型的操作数。\n自增&#x2F;自减运算符：++a 是先自增再使用，a++ 是先使用再自增。\n\n\n常见运算符&emsp;&emsp;在C语言中，我们常见的有以下这几类算术运算符，在其中分别起着不同的作用。\n\n\n\n\n类型\n算术符\n\n\n\n算术运算符\n+  -  *  &#x2F;  %  ++  --\n\n\n关系运算符\n&lt;  &lt;&#x3D;   &#x3D;&#x3D;   &gt;   &gt;&#x3D;   !&#x3D;\n\n\n逻辑运算符\n!  &amp;&amp;  ||\n\n\n位运算符\n&lt;&lt;   &gt;&gt;   ~  |  ^  &amp;\n\n\n赋值运算符\n&#x3D; 及其扩展\n\n\n条件运算符\n?:\n\n\n逗号运算符\n,\n\n\n指针运算符\n*  &amp;\n\n\n求字节数\nsizeof\n\n\n强制类型转换\n(类型)\n\n\n分量运算符\n.  -&gt;\n\n\n下标运算符\n[]\n\n\n其它\n() -\n\n\n\n注意事项&emsp;&emsp;在学习运算符时应注意：\n\n运算符的功能\n与运算量的关系\n要求运算量个数\n要求运算量类型\n\n\n运算符的优先级别\n结合方向\n结果的类型\n\n&emsp;&emsp;接下来基础讲解一下。\n知识点1. 基本的算术运算符有：\n+ ： 加法\n- ： 减法或取负\n* ： 乘法\n&#x2F; ： 除法\n% ： 取余\n\n2. 关于除法运算 &#x2F;&emsp;&emsp;C语言规定：两个整数相除，其商为整数，小数部分舍弃。也就是说，若除数和被除数均为整数，那么只保留商的整数部分，如下：\n# include &lt;stdio.h&gt;int a = 10,b = 3;int c = a / b;printf(&quot;%d&quot;, c);return 0;\n\n&emsp;&emsp;上面这段示例代码中，a &#x2F; b 的结果为 3，而不是 3.333333…。因为a与b均是整数，所以商为整数，但是当把a或者b定义为浮点数时，结果就不同了。\n# include &lt;stdio.h&gt;int main()&#123;    float a = 10.0;    int b = 3;    float c = a / b;    printf(&quot;%f&quot;, c);    return 0;&#125;\n\n&emsp;&emsp;这时，输出的结果便是3.333333，因为我们有一个我们有一个浮点数，所以结果也是浮点数。\n3. 关于求余数运算%&emsp;&emsp;取余运算在C语言中，要求%两边的数据类型均是整型数据。如下所示：\n\n5 % 2 &#x3D; 1 （√）\n-5 % 2 &#x3D; -1 （√）\n1 % 10 &#x3D; 1 （√）\n5 % 1 &#x3D; 0 （√）\n5.5 % 2 (×)\n\n4. 关于两边运算数类型不一致&emsp;&emsp;系统将自动进行按照优先级转换，使两边一致后运算。详细请参照上一节。\n5. 运算精度&emsp;&emsp;所有的实型数的运算均是以双精度方式进行，若是单精度，则在末尾处添0，转换为双精度。\n6. 算数表达式的概念（1）表达式的概念&emsp;&emsp;用运算符和括号将运算对象（常量、变量和函数等）连接起来的、符合Ｃ语言语法规则的式子，称为表达式。\n（2）算术表达式的概念&emsp;&emsp;算术表达式是表达式的一种，它将运算对象（常量、变量和函数等）连接起来，并使用运算符进行运算，得到一个结果。\n&emsp;&emsp;例如： \na = 3 + 6 * 9；b = (x + y) / 2 - 1;\n\n7. 强制类型转换表达式&emsp;&emsp;在C语言中，我们可以使用强制类型转换表达式将一个数据类型转换为另一个数据类型。转换格式为：\n(类型名)(表达式)(double) (a)  //等价于(double) a (int) (x+y)(float) a + b  //需要注意这个，只会强制转换前面的a，相当于(float) (a) + b(float)(a + b)  //这个才是整体转换a+b的值为float\n\n&emsp;&emsp;注意：强制转换类型得到的是一个所需类型的中间量，原表达式类型并不发生变化。例如，(double)a 只是将变量a的值转换成一个double型的中间量，其数据类型并未转换成double型。\n","tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第九节——自加、自减运算符","url":"/Blog/posts/2c0afa58/","content":"自加运算符++、自减运算符–&emsp;&emsp;i++（或者i–），一般叫做后置自加（或自减），我更习惯叫作自增，表示在使用该表达式之后，将表达式值+1，或者-1。&emsp;&emsp;++i（或者–i），一般叫做前置自加（或自减），表示在使用该表达式之前，将表达式值+1，或者-1。\n&emsp;&emsp;个人记忆方法，++（或–）在前，就先+1（或者-1），然后使用这个值。++（或–）在后，就先使用这个值，然后+1（或者-1）。\n说明\n++和–仅适用于变量（整型，实型，字符型）和指针，不能用于常量和表达式。\n++和–运算符的结合方向是至右向左。\n\n考点\n自增、自减运算符只能用于变量，不能用于常量和表达式。5++、–(a+b)等都是非法的。\n自增、自减运算符和其它运算符混合使用时，其结合性为：至右向左。\n自增、自减运算符，无论作为前缀（++a，–a）还是后缀（ a ++， a –）运算符，对于变量本身来说自增1或自减1都具有相同的效果，但对表达式来说却有着不同的值。\n\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第四节——基本数据类型转换","url":"/Blog/posts/e4dc0678/","content":"隐式转换&emsp;&emsp;个人理解隐式转换仅仅是在你不声明的情况下将数据类型进行转换的一种方式，是编译器的一种操作。\n\n运算转换：&emsp;&emsp;即不同数据之间进行运算时，如下：\n#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    float b = 20.5;    float c = a + b;    printf(&quot;%f&quot;, c ) ;    return 0;&#125;\n&emsp;&emsp;运行结果如下：\n30.500000\n&emsp;&emsp;在这个过程中，我们首先定义一个int型变量a，赋值为10，然后定义一个float型变量b，赋值为20.5，将float型变量c赋值为a+b，在运算时，编译器首先会将int型变量a转换为float型，然后与同类型变量b相加输出结果，并将其赋值给float型变量c。\n赋值转换：&emsp;&emsp;把一个值赋给与其不同的变量时，如下：\n#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    float b = a;    printf(&quot;%f&quot;, b ) ;    return 0;&#125;\n\n&emsp;&emsp;运行结果如下:\n10.000000\n\n&emsp;&emsp;在这个过程中，我们首先定义一个int型变量a，赋值为10，然后定义一个float型变量b，将int型变量a赋值给float型变量b，编译器首先会将int型变量a转换为float型，然后赋值给float型变量b，输出结果。\n输出转换：&emsp;&emsp;在输出时将格式转换为指定格式，如下：\n#include &lt;stdio.h&gt;int main()&#123;    char a = &#x27;B&#x27;;    printf(&quot;%d&quot;, a ) ;    return 0;&#125;\n\n&emsp;&emsp;运行结果如下：\n66\n&emsp;&emsp;上述代码在执行时，，首先定义一个字符变量a,，在执行输出时，将字符变量a转换为整型变量，然后输出结果。这一过程就是输出转化。\n\n形参与实参&emsp;&emsp;在讲解下一个过程之前，我们需要了解“实参”和“形参”这两个概念。这两个概念我们在后期会经常使用，要对他们有大致的了解。\n形参：定义：&emsp;&emsp;形参是函数定义时在函数头部声明的参数，用于接收调用函数时传入的实际值。它们是函数接口的一部分，定义了函数需要哪些输入数据。\n特点：\n占位符作用：形参在函数定义时只是一个占位符，不占用内存空间，直到函数被调用时才会分配存储空间。\n局部性：形参的作用域仅限于函数内部，函数执行结束后，形参的存储空间会被释放。\n值传递：在C语言中，形参默认是通过值传递（Call by Value）接收实参的值。这意味着形参是实参的副本，对形参的修改不会影响实参。\n类型匹配：形参的类型必须与实参的类型兼容，否则可能导致隐式类型转换或编译错误。\n\n示例：#include&lt;stdio.h&gt;void test(int a,int b) //此时a和b就是形参&#123;    int c = a + b;    return c;&#125;int main()&#123;    int x , y;    int c = test(x ,y);&#125;\n\n实参：定义&emsp;&emsp;实参是函数调用时传递给函数的具体值或表达式。它们是函数执行所需的实际数据。\n特点：\n来源：实参可以是常量、变量、表达式，甚至是其他函数的返回值。\n单向传递：实参的值被传递给形参，但形参的修改不会影响实参（除非通过指针传递地址）。\n类型匹配：实参的类型必须与形参的类型兼容，否则可能导致不可预期的结果。\n\n示例：#include&lt;stdio.h&gt;int main() &#123;    int x = 5, y = 10;  // x和y是实参    swap(x, y);         // 调用swap函数时，x和y作为实参传递    return 0;&#125;\n\n实参和形参的关系值传递&emsp;&emsp;在C语言中，函数参数默认是按值传递的。这意味着实参的值会被复制到形参中，形参和实参是两个独立的变量，存储在不同的内存位置。下面这个例子将会详细给你讲解：\n#include &lt;stdio.h&gt;void swap(int a, int b)&#123;    int temp = a;    a = b;    b = temp;    printf(&quot;Inside swap function: a = %d, b = %d\\n&quot;, a, b);&#125;int main()&#123;    int x = 5, y = 10;    printf(&quot;Before swap: x = %d, y = %d\\n&quot;, x, y);    swap(x, y);    printf(&quot;After swap: x = %d, y = %d\\n&quot;, x, y);    return 0;&#125;\n\n&emsp;&emsp;在上面这段代码中，函数swap()有两个参数，分别是int a 和 int b。这两个参数就是形参，而我们在main()中定义的 int x， int y是实参，而我们在main()中调用swap()函数时，将X和Y的值传递给a和b。形参相当于只是个用来占位的替身，实际上是实参在起作用。这个过程也就是形参和实参相当重要的一个特点：值传递\n地址传递&emsp;&emsp;如果需要让函数修改实参的值，可以通过传递变量的地址（指针）来实现。此时，形参是一个指针，指向实参的内存地址。指针这一块我们在这里大致举例即可，后面会详细讲解。\nvoid increment(int *a) &#123;    (*a) += 1;  // 通过指针修改实参的值    printf(&quot;Inside function: %d\\n&quot;, *a);&#125;int main() &#123;    int x = 5;    increment(&amp;x);  // 传递x的地址    printf(&quot;Outside function: %d\\n&quot;, x);  // x的值变为6    return 0;&#125;\n&emsp;&emsp;在这个例子中，函数increment()的参数是一个指针，指向一个int类型的变量。在函数中，通过指针修改实参的值。然后，在main()中，我们调用increment()函数，并传递x的地址。这样，函数修改了x的值，并返回了修改后的值。\n\n&emsp;&emsp;形参实参大致讲解到这，让我们继续回到隐式转换。\n\n函数调用转换：&emsp;&emsp;函数调用转换是指，当函数调用时，编译器会根据函数的参数和返回值类型，将实参转换为形参的类型。如下：\n#include &lt;stdio.h&gt;int add(int a, int b)&#123;    int c = a + b;    return c;&#125;int main()&#123;    char x = &#x27;A&#x27;, y = &#x27;B&#x27;;    int z = add(x, y);    printf(&quot;%d&quot;, z);    return 0;&#125;\n&emsp;&emsp;在这个例子中，函数add()的参数是int型，返回值也是int型。在main()中，定义了三个变量x，y，z，并调用add()函数，将字符变量x和y作为实参传递给add()函数。编译器会根据函数的参数和返回值类型，将x和y转换为int型，然后调用add()函数，将转换后的实参传递给形参a和b。函数add()返回一个int型结果，将结果赋给z。最后，输出z的值。\n\n运算转换规则&emsp;&emsp;以上就是C语言中基本的隐式转换，我们可以总结出运算转换的规则如下：不同类型的数据运算时先自动转换为同一类型，然后在执行其余步骤。\n\n不同数据类型之间转换顺序&emsp;&emsp;在这幅图中，横向的箭头是一定会执行的转换，纵向的箭头是不同类型之间执行的转换，同时，低位会向高位转换。例如：\nchar ch;int i;float f;double d;ch/i + f*d - (f+i)\n&emsp;&emsp;这一过程中，因为char型的ch一定会转换为int型，所以会先将ch转换为int型，然后float型的f一定转换给double型，转换完后，在运算时因为存在最高的double，所以int会向高位转换给double，所以最后输出的就是double。\n\n\n显式转换&emsp;&emsp;显式转换（又叫强制转换），是我们常用的一种方式。\n一般形式：(类型名)(表达式)\n\n&emsp;&emsp;比如：\nint a = 10;float b = (float)a;printf(&quot;%f&quot;,b);\n&emsp;&emsp;在上述代码中，我们把int型变量a强制转换为float型变量b，并输出b的值。\n说明：&emsp;&emsp;强制转换得到所需类型的中间变量，原变量不变。（在转换过程中，常伴有精度损失等问题，常发生在较高类型转换为较低类型时）\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第一章——程序设计基本概念 第一节——各种“程序”的概念","url":"/Blog/posts/a942ac92/","content":"一、程序&emsp;&emsp; 什么是程序？人们常说，我们仿佛是上帝创造的 NPC，只会机械的重复着毫无意义的动作, 毫无思想的执行着一条条预设的指令，完成衬托着那些主角的成功。同样的，人们把需要用计算机完成的工作写成一条条指令，并把这些指令存储在预定的内存中，当人们给出执行命令后，计算机就按指令顺序自动进行操作。这些可以连续执行的一条条指令的集合称为“程序”。\n\n二、程序设计语言的发展2.1 机器语言&emsp;&emsp; 一切的开始，都是 0 与 1 的交汇。因为组成电子逻辑的电门仅有通过和不通过两种判断。于是人们将计算机的运算用 01 来编写，自此，将 100110011101 这种专门让机器执行的指令码叫做机器语言。\n2.2 汇编语言&emsp;&emsp; 在编写程序时，人脑作为仅有 10 bit &#x2F;s 交换流的低数据流单线程的处理器，当然没办法记下数量庞大的 01 字符串来执行类似于相加相减等操作，别说更复杂的的运算。所以汇编语言便应运而生。用助记符来代表系统指令与计算机硬件直接交互，比如，相加我们用 ADD 来表示相加等等。\n2.3 高级语言&emsp;&emsp; 高级语言分为两大部分，第一部分时面向对象，第二部分是面向过程。高级语言是比汇编语言更抽象的存在，其在思维逻辑上，与机器语言和汇编语言更符合人类的思维方式。同时它可以将开发者的思维聚焦到具体问题的软件逻辑而非协调底层硬件。高级语言更接近人类语言，通常使用词法和语法结构，使程序更易读、更易写。高级语言通过编译器或解释器转换为机器码，让计算机能够理解并执行这些指令。\n2.3.1 面向对象语言&emsp;&emsp; 面向对象语言这一块更偏向于让谁来完成工作，类比于团队合作，面向对象语言关注于把一件事情下分给各个部门，然后各个部门协同完成一件工作。其中代表语言如 Python，Java 等。\n2.3.2 面向过程语言&emsp;&emsp; 面向过程语言更偏向于步骤，像是写教程，第一步要干什么，第二步要干什么，将一份工作拆分为一块一块，分步完成。\n2.3.3 两种面向的区别&emsp;&emsp; 总而言之，面向过程是 「怎么做」，面向对象是 「谁来做」 。就像单独旅行 vs 跟团游，一个要自己安排所有步骤，一个把任务分配给导游&#x2F;司机&#x2F;酒店各司其职。\n2.4 三种语言的区别&emsp;&emsp; 其中机器语言和汇编语言更偏向于让机器读，人的理解比较低，而高级语言则更偏向让人理解，机器的部分由编译器等等来执行\n\n三、程序间的转换&emsp;&emsp; 我们的高级语言通过编译才能转化为机器语言，而汇编语言需用通过汇编才可以转为机器语言。&emsp;&emsp; 通常情况下，我们的源程序，如件.c文件，. cpp 文需要先编译为. obj文件，然后链接各种库，最后封装才能成为一个可执行文件. exe。其中. obj 文件和. exe 文件都是二进制文件。&emsp;&emsp;需要注意的是，.obj和.exe虽然都是二进制文件，但是可以直接运行的仅有.exe，.obj文件是编译后的目标文件，需要通过链接器（linker）与其他目标文件或库文件链接，生成最终的可执行文件（如 .Exe），才能在操作系统上运行。&emsp;&emsp;然后，在编译过程中，像是注释之类的非执行语句，会被编译器直接跳过，不会被转换为二进制语句，而只有二进制语句才会被转换为二进制的机器指令。&emsp;&emsp; C语言程序有两种执行方式，分别是编译执行和解释执行。这个有关于机器的不过多解释。\n\n本小节总结一、程序的定义程序本质\n由一系列可连续执行的指令组成，存储在内存中，计算机按顺序自动执行这些指令完成特定任务。\n\n\n二、程序设计语言的发展2.1 机器语言\n特点：  \n由二进制代码（0 和 1）直接编写，是计算机唯一能直接执行的指令。\n示例：100110011101。\n\n\n局限性：  \n对人类极不友好，难以记忆和编写复杂逻辑。\n\n\n\n2.2 汇编语言\n特点：  \n用助记符（如 ADD 表示相加）代替机器指令，与硬件直接交互。\n示例：MOV AX, BX。\n\n\n优势：  \n比机器语言更易读，但仍依赖硬件知识。\n\n\n\n2.3 高级语言\n核心特点：  \n抽象层次高，接近人类自然语言，聚焦问题逻辑而非硬件细节。\n需通过编译器或解释器转换为机器码。\n\n\n分类：  \n面向对象语言（如 Java、Python）：  \n关注“谁来做”，将任务分配给不同对象协作完成（类似团队分工）。\n\n\n面向过程语言（如 C）：  \n关注“怎么做”，按步骤拆解任务（类似写教程分步操作）。\n\n\n\n\n与底层语言的区别：  \n机器&#x2F;汇编语言：机器易读，人类难理解。\n高级语言：人类易读写，机器需编译后执行。\n\n\n\n\n三、程序间的转换编译流程\n高级语言 → 机器语言：源文件（如 .c）→ 编译器 → 目标文件（.obj）→ 链接库文件 → 可执行文件（.exe）。\n\n文件类型说明\n.obj 和 .exe 均为二进制文件，机器仅可直接执行.exe。\n\n\n四、核心对比总结\n\n\n语言类型\n特点\n示例指令\n适用场景\n\n\n\n机器语言\n二进制代码，机器直接执行\n10101010\n底层硬件操作\n\n\n汇编语言\n助记符替代机器指令\nADD AX, BX\n硬件驱动、性能优化\n\n\n高级语言\n人类易读写，需编译后执行\nprint(&quot;Hello&quot;)\n软件开发、复杂逻辑实现\n\n\n","categories":["C_Language","第一章——程序设计基本概念"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第零节——前言","url":"/Blog/posts/4f6c8e97/","content":"第二章 前言咱们先来认识C语言的“ABC”——就像学英语要从26个字母开始一样，编程也要掌握基本要素。\n从Hello World开始本章开篇就带大家写最经典的“Hello World”程序。别看它只会打印一句话，这可是每个程序员的成人礼！通过这个小程序，我们会认识C语言的基本框架。\n完整示例🌰：\n#include &lt;stdio.h&gt;  // 引入输入输出库int main() &#123;        // 主函数入口    printf(&quot;Hello, World!\\n&quot;);  // 输出问候语    return 0;       // 返回成功状态&#125;\n\n数据的身份证接着要认识C语言里的数据类型，就像给不同种类的数据发“身份证”：\n\n整数用int（比如年龄）\n小数用float&#x2F;double（比如价格）\n字符用char（比如等级）\n\n代码示例🌰：\nint age = 20;            // 定义整型变量float price = 19.99f;     // 定义单精度浮点数char grade = &#x27;A&#x27;;         // 定义字符型\n\n还会学到怎么给这些数据起名字（变量命名规则），以及如何定义常量——那些程序里不能变的“铁规矩”。\n运算的秘密最后会揭秘各种运算符，包括加减乘除这些基础操作，还有自增自减这种C语言特色技巧。重点理解运算优先级，就像知道先穿袜子再穿鞋一样重要！\n优先级对比🌰：\nint a = 5 + 3 * 2;      // 先乘后加 结果=11\nint b = (5 + 3) * 2;    // 加号优先 结果=16\n\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第二章——C程序设计的初步知识 第八节——逗号表达式的运算规则","url":"/Blog/posts/4d851016/","content":"形式&emsp;&emsp;一般来说，形式类似于：表达式1,表达式2,表达式n\n结合性&emsp;&emsp;从左向右\n优先级&emsp;&emsp;所有运算符中，逗号的优先级最低\n表达式的值&emsp;&emsp;逗号表达式的值是最后一个表达式的值。\n考点\n逗号运算符的结合性为从左到右。，先计算表达式1，最后计算表达式n，最后一个表达式的值即为该逗号表达式的值。\n逗号运算符在所有运算符中，优先级最低。\n\n","categories":["C_Language","第二章——C程序设计的初步知识"],"tags":["C Language"]},{"title":"第一章——程序设计基本概念 第三节——结构化程序设计和模块化结构","url":"/Blog/posts/bf2a0d0e/","content":"一、三大模块化结构&emsp;&emsp; 在 C 语言中，我们主要学习使用如下几种结构：\n1. 顺序结构&emsp;&emsp;像是正常步骤说明一样，一条一条，一步一步执行，没有分支，没有转移的结构。结构如下：\n2. 选择结构选择其实就是根据不同的条件执行不同分支下的语句，执行后将结果继续向下或者跳出。\n3. 循环结构&emsp;&emsp; 循环结构和选择结构不一样的是，循环结构当条件为真时进入循环，一直到条件不成立。用选择结构写循环结构相当于好多层嵌套。\n二、模块化结构&emsp;&emsp;模块化结构就象是我们第一节讲过的面向对象语言，将任务按照各个部门所擅长的职能拆分下去，然后各部门按照团队擅长的部分继续拆分，团队按照成员继续拆分，直到拆分成每个任务都可以由每个人超级简单的完成。此时这些完成任务的单位个体的人就是一个个模块，用很多小小的简单的模块整体协调完成整个任务这种做法就是模块化方法，由一个个功能模块构成的程序结构为模块化结构。\n","categories":["C_Language","第一章——程序设计基本概念"],"tags":["C Language"]},{"title":"第一章——程序设计基本概念 第二节——算法的特性","url":"/Blog/posts/bf46c037/","content":"一、什么是算法？&emsp;&emsp; 说到算法，比较陌生。那要是说起解题思路，会不会比较好理解一点？假设。我们此时有一个，十分明确的题目，我们脑海中自然会产生第一步，第二步，第三步……以此类推的一个整体有限的解题步骤。此时这些解题步骤就可以被称作算法。这时你应该就可以想到，算法实质上就是为了解决某个特定问题而采取的确定且有限的步骤。\n二、算法的特性\n有穷性：一个算法包含的步骤是有限的。即在若干个步骤后结束，并且每一步都在合理时间内完成\n确定性：算法中每一条指令必须有确切的含义，不能有二义性，对于相同的输入必能得出相同的执行结果。\n可行性：算法中指定的操作，都可以通过已经验证可以实现的基本运算执行有限次后实现。\n必须有零个或多个输入：算法都是用来处理数据对象的，通常情况下这些数据对象需要通过输入来得到。\n必须有一个或多个输出：算法的目的是为了求解。这些“解”只有通过输出得到。\n\n三、如何评价算法&emsp;&emsp; 对于算法一般有如下几个要求：\n\n必须正确\n必须高效（即占用内存空间少，所需运行时间短）\n\n&emsp;&emsp; 于是便有了如下两个维度：\n\n时间复杂度\n空间复杂度\n\n","categories":["C_Language","第一章——程序设计基本概念"],"tags":["C Language"]},{"title":"第三章——顺序结构 第三节——数据输入","url":"/Blog/posts/6d92a9d2/","content":"字符输入函数\n格式：getchar()\n功能：从键盘读取一个字符\n返回值：正常，返回读取的代码值；错误，返回EOF(-1)\n\n格式输入函数\n格式：scanf(“格式控制串”,地址表)\n功能：按指定格式从键盘读入数据，存入地址表指定的存储单元中，并且按回车结束\n返回值：正常，返回输入项个数\n地址表：变量的地址，常用取地址运算符&amp;\n格式字符：d , i , o , x , u , c , s , f , e\n\n附加格式说明符（修饰符）\n\n\n修饰符\n功能\n\n\n\nh\n用于d, o, x前，指定输入为short型整数\n\n\nl\n用于d, o, x前，指定输入为long型整数 用于e, f前，指定输入为double型实数\n\n\nm\n指定输入数据宽度，遇空格或不可转换字符则结束\n\n\n*\n抑制符，指定输入项读入后不赋给变量\n\n\n输入分隔符的指定\n一般以空格、TAB、回车键作为分隔符\n其他字符做分隔符：格式串中两个格式符之间插入即可\n\nscanf(&quot;%d%d&quot;, &amp;a, &amp;b); // 在这种情况下，scanf()会自动跳过空格、TAB、回车键等空白字符的输入，也就是将其当作分隔符scanf(&quot;%d , %d&quot;, &amp;a, &amp;b); // 输入分隔符为逗号scanf(&quot;%d;%d&quot;, &amp;a, &amp;b); // 输入分隔符为分号\n\n说明\n用 “%c” 格式符时，空格，转义字符均是有效字符输入\n输入数据时，遇到以下情况默认结束：\n遇到空格、TAB、回车键、换行符时结束输入\n遇宽度结束\n遇非法输入\n\n\n输入函数留下的“无用数据”，即输入数据后，输入缓冲区中剩余的数据，这些数据在输入缓冲区中，直到下次输入时才会被清空。\n\n解决办法：\n\n输入缓冲区中的数据清空，使用 fflush(stdin) 函数\n输入缓冲区中的数据清空，使用 getchar() 函数\n用格式串中空格或者 “%*c” 来抑制输入\n\n\n考点\n熟知各种格式字符的功能\nscanf函数中的输入项必须是“地址量”\n输入数据时，各个数据见可以用空格符、回车符或者Tab作为输入分隔符\n除了上述3中所述的分隔符外，还可以指定其他字符作为分隔符，但输入时要输入与之相同的字符\n对于结束的条件要熟知\n\n","tags":["C Language"]},{"title":"第三章——顺序结构 第四节——复合语句和空语句","url":"/Blog/posts/12ede399/","content":"语句&emsp;&emsp;在C语言中，语句是程序执行的基本单位，用于表示操作或控制流程，本节着重来讲复合语句和空语句。有如下几种分类：\n复合语句&emsp;&emsp;复合语句（Compound Statement）是 C 语言中由一对大括号 {} 包围的语句序列，其核心作用是将多条语句组合成一个逻辑整体，使其在语法上等价于单条语句。\n\n1. 复合语句的定义与语法\n语法结构：\n&#123;    语句1;    语句2;    ...    语句n;&#125;\n\n即使只有一条语句，也可以使用复合语句（虽然通常非必要）：&#123; printf(&quot;只有一条语句的复合语句\\n&quot;); &#125;\n\n\n特点：\n\n复合语句在语法上被视为一条语句，可以在需要单条语句的地方使用（如控制结构中）。\n复合语句的结尾不需要分号（}; 是错误的）。\n\n\n\n\n2. 复合语句的用途(1) 控制流语句中的语句块\n在 if、for、while 等控制结构中，复合语句用于定义当条件满足时应执行的多条语句。if (score &gt; 60) &#123;    printf(&quot;及格\\n&quot;);    printf(&quot;奖励小蛋糕\\n&quot;);&#125;\n\n若省略花括号：if (score &gt; 60)    printf(&quot;及格\\n&quot;);    printf(&quot;奖励小蛋糕\\n&quot;); // 总会执行！\n问题：第二条 printf 不再受 if 控制，无论条件是否满足都会执行。\n\n\n\n(2) 局部作用域\n复合语句内声明的变量具有 块级作用域（Block Scope），只能在该复合语句内访问。int main() &#123;    int x = 10;    &#123;        int y = 20; // 局部于内部复合语句        printf(&quot;x = %d, y = %d\\n&quot;, x, y);    &#125;    printf(&quot;x = %d\\n&quot;, x); // 正确    // printf(&quot;y = %d\\n&quot;, y); // 错误：y 作用域已结束    return 0;&#125;\n\n(3) 代码组织\n将相关语句组织在一起，形成逻辑单元，提高代码可读性。void example() &#123;    &#123;        int a = 5;        int b = 10;        printf(&quot;a + b = %d\\n&quot;, a + b);    &#125;    // a 和 b 无法在此处访问&#125;\n\n\n3. 复合语句的注意事项(1) 空复合语句\nC 语言允许空复合语句（即 {} 内无内容），但实际开发中几乎不会使用：&#123;&#125; // 空复合语句\n\n(2) 避免误用\n误加分号：在 if 或循环后误加分号会导致后续语句不受控制。if (x &gt; 0); // 错误：空语句被误认为是 if 的主体    printf(&quot;x is positive.\\n&quot;); // 总会执行\n修正方法：使用花括号明确代码块：if (x &gt; 0) &#123;    // 空语句占位&#125;\n\n(3) 变量作用域\n复合语句中定义的变量是 局部变量，仅在当前块内有效。int main() &#123;    int a = 5;    &#123;        int a = 10; // 隐藏外部的 a        printf(&quot;内部 a = %d\\n&quot;, a);    &#125;    printf(&quot;外部 a = %d\\n&quot;, a);    return 0;&#125;\n输出：内部 a = 10外部 a = 5\n\n\n4. 复合语句的典型示例(1) 在 if 语句中使用复合语句#include &lt;stdio.h&gt;int main() &#123;    int score = 85;    if (score &gt;= 60) &#123;        printf(&quot;恭喜你，通过了考试！\\n&quot;);        printf(&quot;你的分数是：%d\\n&quot;, score);    &#125; else &#123;        printf(&quot;很遗憾，你没有通过考试。\\n&quot;);    &#125;    return 0;&#125;\n\n(2) 在 for 循环中使用复合语句#include &lt;stdio.h&gt;int main() &#123;    for (int i = 1; i &lt;= 5; i++) &#123;        printf(&quot;%d &quot;, i);        if (i == 3) &#123;            printf(&quot;中间值\\n&quot;);        &#125;    &#125;    return 0;&#125;\n\n(3) 复合语句嵌套int main() &#123;    int x = 10;    &#123;        int y = 20;        &#123;            int z = 30;            printf(&quot;x = %d, y = %d, z = %d\\n&quot;, x, y, z);        &#125;        // z 无法在此处访问        printf(&quot;x = %d, y = %d\\n&quot;, x, y);    &#125;    // y 无法在此处访问    printf(&quot;x = %d\\n&quot;, x);    return 0;&#125;\n\n\n5. 总结\n\n\n特性\n说明\n\n\n\n语法\n由 {} 包围的语句序列\n\n\n作用\n组合多条语句为一个逻辑整体，管理作用域，提高代码可读性\n\n\n注意事项\n避免误加分号，注意变量作用域\n\n\n适用场景\n控制结构（if、for）、局部变量定义、代码组织\n\n\n\n6. 最佳实践\n始终使用花括号：即使控制结构中只有一条语句，也建议使用 {}，以避免逻辑错误。\nif (condition) &#123;    // 即使只有一条语句，也使用花括号    printf(&quot;Condition is true.\\n&quot;);&#125;\n\n明确作用域：通过嵌套复合语句管理变量生命周期，减少命名冲突。\n\n注释说明：在复杂代码中，为复合语句添加注释，说明其目的。\n\n\n\n空语句&emsp;&emsp;空语句（Empty Statement）是 C 语言中最简单的一种语句，由一个单独的分号 ; 构成。它不执行任何操作，但在语法上占位，确保程序结构的完整性。\n1. 空语句的定义&emsp;&emsp;空语句的语法形式为：\n&#123;    ;&#125;\n&emsp;&emsp;它表示程序执行到此处时，不进行任何操作。空语句常用于以下场景：\n\n2. 空语句的用途(1) 占位符&emsp;&emsp;当需要语法上的一条语句，但逻辑上不需要操作时，可以使用空语句作为占位符。例如：\nint main() &#123;    ; // 空语句，占位    return 0;&#125;\n\n(2) 控制循环或条件语句的结构\n空循环体：当循环体不需要执行任何操作时，可以用空语句。\n// 等待用户输入回车while (getchar() != &#x27;\\n&#x27;) ; // 循环体为空语句，保持持续输入状态\n\n条件语句中的占位：在某些条件下无需执行操作时。\nif (condition); // 条件为真时不执行任何操作else &#123;    printf(&quot;Condition is false.\\n&quot;);&#125;\n\n(3) 调试或临时占位&emsp;&emsp;在调试过程中，可以用空语句暂时替代未实现的功能：\nif (x &gt; 0)    ; // 暂时不需要操作else    printf(&quot;x is non-positive.\\n&quot;);\n\n(4) 避免语法错误&emsp;&emsp;在复杂的控制结构中，空语句可以避免语法错误。例如：\nwhile (condition) ; // 条件为真时循环但不执行任何操作\n\n\n3. 空语句的注意事项(1) 可读性与误用\n避免滥用：过度使用空语句可能导致代码难以理解。例如，在 if 语句后意外加分号，会导致后续代码块与 if 无关：if (x &gt; 0); // 错误：空语句被误认为是 if 的主体    printf(&quot;x is positive.\\n&quot;); // 总会执行\n修正方法：使用大括号 {} 明确代码块：if (x &gt; 0) &#123;    // 空语句占位&#125;\n\n(2) 编译器优化\n空语句通常会被编译器优化掉（如果没有任何副作用）。例如：void example() &#123;    ; // 单独的空语句    if (1) ; // if 分支的空语句&#125;\n编译器（如 GCC）会将这些空语句完全移除，不会生成任何指令。\n\n\n4. 空语句的典型示例(1) 空循环体#include &lt;stdio.h&gt;int main() &#123;    int i = 0;    while (i &lt; 10) i++; // 循环体为空语句    printf(&quot;i = %d\\n&quot;, i);    return 0;&#125;\n输出：\ni = 10\n\n(2) 条件判断中的空语句#include &lt;stdio.h&gt;int main() &#123;    int x = 5;    if (x &gt; 0)        ; // 条件为真时不执行任何操作    else        printf(&quot;x is non-positive.\\n&quot;);    return 0;&#125;\n\n(3) 占位符的合理使用#include &lt;stdio.h&gt;int main() &#123;    int a = 10;    if (a == 10)        ; // 占位，等待后续逻辑补充    else        printf(&quot;a is not 10.\\n&quot;);    return 0;&#125;\n\n\n5. 总结\n\n\n特性\n说明\n\n\n\n语法\n仅由一个分号 ; 构成\n\n\n作用\n语法占位、控制结构中的空操作、调试占位\n\n\n注意事项\n避免误用（如 if 后误加分号）、注意代码可读性\n\n\n编译器处理\n通常会被优化掉（无副作用时）\n\n\n适用场景\n空循环体、条件判断占位、调试占位\n\n\n\n6. 最佳实践\n明确意图：如果需要占位，可以添加注释说明目的：if (condition) // 暂时不需要操作    ;\n优先使用大括号：在控制流语句中，即使需要空操作，也建议使用大括号 {}：if (condition) &#123;    // 空操作&#125;\n\n&emsp;&emsp;通过合理使用空语句，可以简化代码逻辑，但需确保代码的可读性和维护性。\n\n后记&emsp;&emsp;基于C语言中所有的语句均是必须以“;”作为结束，如果只有一个分号，也会被当成一条语句，称之为“空语句”，执行时不产生任何动作。但是随意的加分号会导致程序逻辑上的错误，从而影响运行。\n","tags":["C Language"]},{"title":"第三章——顺序结构 第一节——赋值表达式与赋值语句","url":"/Blog/posts/44fd442a/","content":"赋值语句&emsp;&emsp;在赋值表达式的尾部加上一个“；”，又称为表达式语句。如下：\n\na&#x3D;b+c；–i；i++；a&#x3D;b&#x3D;c；a&#x3D;b,b&#x3D;c；\n\n\n考点\n赋值语句必须在最后出现分号，分号是语句中必不可少的部分。（就像是你有手机却没有电）\n任何赋值表达式都可以加上分号而成为赋值语句，C语言规定赋值号左边不能为常量或者表达式。\n\n","categories":["C_Language","第三章——顺序结构"],"tags":["C Language"]},{"title":"第三章——顺序结构 第零节——前言","url":"/Blog/posts/58106a64/","content":"第三章 前言这一章咱们要掌握程序的“基本功”——就像学功夫要先练马步一样重要。\n程序的三大招式还记得第一章说的三种基本结构吗？\n\n顺序结构：像排队买奶茶，一个接一个\n选择结构：遇到岔路口做选择（后面章节重点）\n循环结构：重复执行直到满足条件（后面章节重点）\n\n本章重点修炼第一种招式——顺序结构。虽然它看起来最简单，但却是所有复杂程序的基础。\n实战训练我们会学到：\n\n怎么让程序输出结果（printf的使用技巧）\n如何接收用户输入（scanf的正确打开方式）\n赋值语句的秘密（别搞混了&#x3D;和&#x3D;&#x3D;）\n复合语句的妙用（用{}把多条语句变成一个整体）\n\n代码示例🌰：\n#include &lt;stdio.h&gt;\n\nint main() {\n    int num1 = 5, num2 = 3;\n    int sum = num1 + num2;\n    \n    printf(&quot;第一个数：%d\\n&quot;, num1);\n    printf(&quot;第二个数：%d\\n&quot;, num2);\n    printf(&quot;两数之和：%d\\n&quot;, sum);\n    \n    // 复合语句示例\n    {\n        int temp = num1;\n        num1 = num2;\n        num2 = temp;\n        printf(&quot;交换后：num1=%d, num2=%d\\n&quot;, num1, num2);\n    }\n    \n    return 0;\n}\n\n","categories":["C_Language","第三章——顺序结构"],"tags":["C Language"]},{"title":"第一章——程序设计基本概念 第零节——前言","url":"/Blog/posts/c4ed765c/","content":"第一章 前言第一章的内容，我们先来了解一下C语言基础。想象一下，计算机就像个超级听话的机器人，它能按照我们写的指令一步步完成任务。这就是程序设计最核心的道理。\n程序是怎么来的？第一节会带咱们穿越时空，看看程序设计是怎么从0和1的二进制代码，慢慢变成现在咱们熟悉的C语言这种高级语言的。就像看老照片一样有趣！\n举个栗子🌰：\n#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;程序就是这么简单！\\n&quot;);    return 0;&#125;\n\n算法的秘密第二节要讲的算法，其实就是解决问题的套路。比如做菜要按步骤来，先切菜再下锅。算法也有几个特点：\n\n必须能在有限步骤内完成（别无限循环啊）\n每个步骤要明确不含糊\n能通过简单操作实现\n可能需要输入数据\n最重要的是要有输出结果\n\n举个简单算法🌰：\n计算1+2的步骤：1. 准备纸笔（初始化）2. 写下13. 加上24. 得到结果3\n\n编程三大招式第三节教咱们三个基本功：\n\n顺序招：像排队买奶茶，一个接一个按顺序执行\n选择变招：遇到岔路口，根据条件选不同路线（后续章节重点）\n循环连招：重复执行直到满足条件（后续章节重点）\n\n学完这章，你会对编程有个全景图式的认识。别担心，跟着我们一起探索，你会慢慢发现编程的乐趣！\n","categories":["C_Language","第一章——程序设计基本概念"],"tags":["C Language"]},{"title":"第三章——顺序结构 预读节——程序的三种基本结构","url":"/Blog/posts/9cbf58aa/","content":"程序的三种基本结构1. 结构化程序设计\n基本思想：任何程序都可以用三种基本结构表示，限制使用无条件转移语句（即goto）\n结构化程序：由三种基本结构反复嵌套构成的程序叫结构化程序\n优点：结构清晰，易读，提高程序设计质量和效率。\n\n2. 三种基本结构：顺序结构&emsp;&emsp;程序按顺序执行，每条指令都按顺序执行，直到程序结束。\n选择结构&emsp;&emsp;程序根据条件执行不同的指令。又分为二分支选择结构和三分支选择结构。\n二分支选择结构&emsp;&emsp;二分支选择结构：条件为真时执行A，条件为假时执行B。\n三分支选择结构&emsp;&emsp;三分支选择结构：条件为K1时执行A，条件为K2时执行B，条件为K3时执行C，以此类推。\n循环结构&emsp;&emsp;循环结构：又分为当型循环结构和直到型循环结构。\n当型循环结构&emsp;&emsp;当型循环结构：当条件为真时，循环执行A，当条件为假时，跳出循环。\n直到型循环结构&emsp;&emsp;直到型循环结构：当条件为假时，循环执行A，直到条件为真时，跳出循环。\n注：&emsp;&emsp;A,B,A1….An可以是一个简单语句，也可以是一个基本结构\n","categories":["C_Language","第三章——顺序结构"],"tags":["C Language"]},{"title":"第五章——循环结构 第一节——while语句和do...while结构","url":"/Blog/posts/d9e67466/","content":"一、while语句：谨慎派的「先问路再出发」1.1 基本语法与执行逻辑while(条件表达式) //此处的表达式不能为空，他是判断循环是否继续的条件&#123;    // 循环体语句组（条件为真时反复执行）    // 无论是单个语句还是多个语句均建议用&#123;&#125;包裹&#125;\n执行流程图：\n1.2 案例解析：1到100的累加和#include &lt;stdio.h&gt;int main() &#123;    int i = 1, sum = 0;  // 初始化循环变量和累加器    while(i &lt;= 100)     &#123;    // 条件判断        printf(&quot;第%d次循环：sum=%d + %d\\n&quot;, i, sum, i);  // 调试输出        sum += i;        // 累加操作        i++;             // 更新循环变量    &#125;    printf(&quot;最终结果：sum=%d\\n&quot;, sum);    return 0;&#125;\n调试输出示例：\n第1次循环：sum=0 + 1第2次循环：sum=1 + 2...第100次循环：sum=4950 + 100最终结果：sum=5050\n关键点：\n\n初始化：i=1 和 sum=0 必须在循环前完成。\n条件判断：i &lt;= 100 决定循环是否继续。\n更新变量：i++ 是循环终止的关键，否则会陷入死循环。\n\n1.3 常见错误与避坑指南\n\n\n错误类型\n错误代码\n修复方法\n\n\n\n死循环\nwhile(1) { ... }\n添加 break 或更新条件变量\n\n\n循环体不执行\nint i=2; while(i&lt;=1) {...}\n检查初始条件是否合理\n\n\n循环变量未更新\nwhile(i&lt;=100) { sum+=i; }\n在循环体内添加 i++\n\n\n1.4 真题实战：理解前置&#x2F;后置自增题目：以下代码输出什么？\nint k = 5;while(--k)     printf(&quot;%d&quot;, k -= 3);\n解析步骤：\n\n--k 先减1 → k=4，非0进入循环。\nk -= 3 → k=1，输出 1。\n再次 --k → k=0，循环终止。答案：输出 1。\n\n\n几个关键点\nwhile后的表达式，可以是C语言中任意合法的表达式，通常为关系表达式或逻辑表达式，但也可以是其它运算表达式。\n当表达式值的值为零时，表示条件为假；\n表达式值为非零时，表示条件为真。\n\n\n循环体可以是一条简单可执行语句，也可以是复合语句\n如果第一次计算时表达式的值就为0，则循环语句一次也不被执行，流程直接跳过while语句，执行下一条语句。\n\n\n二、do-while结构：实践派的「先出发再看路」2.1 基本语法与执行逻辑do &#123;    // 循环体（至少执行一次）&#125; while(条件表达式);  // 注意结尾分号！不能省略！！！！\n执行流程图：\n\n2.2 案例解析：ATM取款验证#include &lt;stdio.h&gt;int main() &#123;    int pin = 1234, input;    do     &#123;        printf(&quot;请输入4位数密码：&quot;);        scanf(&quot;%d&quot;, &amp;input);        if (input != pin)         &#123;            printf(&quot;密码错误，请重试！\\n&quot;);        &#125;    &#125;     while(input != pin);  // 至少执行一次    printf(&quot;验证成功！欢迎使用ATM。\\n&quot;);    return 0;&#125;\n运行示例：\n请输入4位数密码：1111密码错误，请重试！请输入4位数密码：1234验证成功！欢迎使用ATM。\n\n2.3 常见错误与避坑指南\n\n\n错误类型\n错误代码\n修复方法\n\n\n\n忘记分号\n} while(condition)\n补全分号 } while(condition);\n\n\n条件逻辑错误\n} while(1 == 2)\n修正条件表达式\n\n\n循环体未初始化\nint n; do { ... } while(...);\n给 n 赋初始值\n\n\n2.4 真题实战：后置自增陷阱题目：以下代码输出什么？\nint a = 7;while(a--)     printf(&quot;Loop &quot;);printf(&quot;a=%d&quot;, a);\n解析步骤：\n\na=7 进入循环，先执行 printf，后 a-- → a=6。\n循环直到 a=0 时，a-- 变为 -1，条件为假终止。\n最终 a=-1。答案：输出8次 Loop ，最后输出 a=-1。\n\n\n三、对比分析：while vs do-while\n\n\n特性\nwhile\ndo-while\n\n\n\n执行次数\n可能0次\n至少1次\n\n\n适用场景\n已知边界条件（如读文件EOF）\n需强制初始化（如游戏菜单）\n\n\n代码安全性\n需先验证条件\n易因条件错误执行无效操作\n\n\n典型比喻\n先查天气再出门\n先出门再看天气\n\n\n\n四、高级技巧与调试方法4.1 使用调试器观察变量变化\nGDB调试命令：gcc -g code.c -o codegdb ./codebreak main.c:5  # 在第5行设置断点run             # 启动程序step            # 单步执行print i         # 查看变量i的值\n\n4.2 用打印法追踪循环流程int i = 1;while(i &lt;= 3) &#123;    printf(&quot;[循环开始] i=%d\\n&quot;, i);    // 模拟复杂操作    printf(&quot;  执行操作...\\n&quot;);    i++;    printf(&quot;[循环结束] i=%d\\n\\n&quot;, i);&#125;\n输出：\n[循环开始] i=1  执行操作...[循环结束] i=2[循环开始] i=2  执行操作...[循环结束] i=3[循环开始] i=3  执行操作...[循环结束] i=4\n\n4.3 避免无限循环的终极技巧\n添加超限保护：int count = 0;while(条件) &#123;    // ...循环体...    if (count++ &gt; 1000) &#123;        printf(&quot;循环超限，强制退出！&quot;);        break;    &#125;&#125;\n\n\n五、总结：选择的艺术\n选while：当需要严格控制循环开始条件时（如读取文件直到EOF）。\n选do-while：当必须执行一次初始化操作时（如游戏菜单系统、输入验证）。\n\n\n🎯 记忆口诀：「先判断用while，保底执行用do-while」就像人生选择——审慎决策用 while，破釜沉舟用 do-while！\n\n","tags":["C Language"]},{"title":"第五章——循环结构 第三节——循环的嵌套","url":"/Blog/posts/900b5b04/","content":"一、什么是循环嵌套？定义：&emsp;&emsp;在一个循环体内部再包含另一个完整的循环结构，称为循环嵌套。  \n特点\n外层循环控制整体循环次数，内层循环负责具体操作。  \n执行流程：外层循环执行一次，内层循环需完整执行所有迭代，再回到外层循环继续下一次迭代。  \n组合形式：for、while、do-while可任意组合嵌套，例如：  for(...) &#123;          // 外层循环    while(...) &#123;    // 内层循环        // 循环体    &#125;&#125;\n\n\n二、执行流程图解以双重循环为例：  \n外层循环初始化 → 条件判断 → 条件为真      ↓  执行外层循环体（含内层循环）      ↓  内层循环初始化 → 条件判断 → 条件为真 → 执行内层循环体 → 更新内层变量 → 返回内层条件判断      ↓  内层循环结束 → 更新外层变量 → 返回外层条件判断  \n关键点：  \n\n内层循环必须在外层循环的一次迭代中完全执行完毕。  \n若内层循环未终止，外层循环无法进入下一次迭代。\n外层循环在逻辑上必须是完整的。\n\n\n三、经典案例解析案例1：打印星号金字塔#include &lt;stdio.h&gt;int main() &#123;    int i, j, k;    for(i = 0; i &lt; 4; i++) &#123;              // 控制行数        for(j = 0; j &lt; 3 - i; j++)             printf(&quot; &quot;);                  // 打印空格        for(k = 0; k &lt; 2*i + 1; k++)             printf(&quot;*&quot;);                  // 打印星号        printf(&quot;\\n&quot;);    &#125;&#125;\n输出：  \n   *    ***   *****  *******\n分析：  \n\n外层循环控制行数（4行）。  \n内层循环分两部分：  \n打印空格（数量随行数递减）。  \n打印星号（数量随行数递增）。\n\n\n\n\n案例2：判断素数#include &lt;stdio.h&gt;int main() &#123;    int n, i;    printf(&quot;请输入一个整数n：&quot;);    scanf(&quot;%d&quot;, &amp;n);    for(i = 2; i &lt; n; i++) &#123;              // 尝试除以2~n-1        if(n % i == 0) break;             // 若能整除，不是素数    &#125;    if(i == n)         printf(&quot;%d是素数。\\n&quot;, n);    else         printf(&quot;%d不是素数。\\n&quot;, n);&#125;\n分析：  \n\n外层循环遍历除数（2到n-1）。  \n内层逻辑（if判断）：若找到因数，立即跳出循环，无需继续检查。\n\n\n四、常见错误与避坑指南\n\n\n错误类型\n错误代码\n修复方法\n\n\n\n死循环\nfor(;;) { ... }\n添加 break 或更新条件变量\n\n\n循环变量作用域\nfor(int i=0; i&lt;10; i++)\n避免在循环外使用循环变量\n\n\n缩进逻辑混乱\n多层循环缩进不一致\n使用统一缩进规范（如每层加4空格）\n\n\nbreak误用\n在内层循环直接break外层\n使用标志位控制外层循环终止\n\n\n典型陷阱：  \nfor(int i = 0; i &lt; 3; i++) &#123;    for(int j = 0; j &lt; 3; j++) &#123;        if(i == 1 &amp;&amp; j == 1) break;  // 仅跳出内层循环！        printf(&quot;%d,%d\\n&quot;, i, j);    &#125;&#125;\n输出：  \n0,0  0,1  0,2  1,0  1,2  2,0  2,1  2,2  \n说明：break只能跳出当前所在的内层循环，外层循环继续执行。\n\n五、真题实战：理解嵌套循环的执行真题1：2007年4月计算机二级题题目：以下程序输出什么？  \nmain() &#123;    int i, j;    for(i = 1; i &lt; 4; i++) &#123;        for(j = i; j &lt; 4; j++)            printf(&quot;%d*%d=%d &quot;, i, j, i*j);        printf(&quot;\\n&quot;);    &#125;&#125;\n选项：A.  \n1*1=1 1*2=2 1*3=3  2*2=4 2*3=6  3*3=9  ```  B.  \n11&#x3D;1 12&#x3D;2 13&#x3D;321&#x3D;2 22&#x3D;4 23&#x3D;631&#x3D;3 32&#x3D;6 3*3&#x3D;9  \n**答案**：A  **解析**：  - 外层循环`i=1`时，内层`j=1→3`，输出`1*1=1`、`1*2=2`、`1*3=3`。  - 外层`i=2`时，内层`j=2→3`，输出`2*2=4`、`2*3=6`。  - 外层`i=3`时，内层`j=3`，输出`3*3=9`。---# 六、高级技巧与调试方法  ## 技巧1：使用标志位控制多层循环  ```cint found = 0;for(int i = 0; i &lt; 10; i++) &#123;    for(int j = 0; j &lt; 10; j++)     &#123;        if(condition)         &#123;            found = 1;            break;  // 跳出内层循环        &#125;    &#125;    if(found) break;  // 根据标志位跳出外层循环&#125;\n解读&emsp;&emsp;这段代码有点小小的绕，逐步来解释一下。\nint found = 0;  // 初始化标志位（0表示未找到目标）\n\n初始化阶段：创建found变量作为状态指示器，初始值为0表示尚未满足退出条件\n\nfor(int i = 0; i &lt; 10; i++) &#123;  // 外层循环控制器\n\n外层循环启动：i从0开始，循环10次（0-9），每次循环包含完整执行内层循环\n\nfor(int j = 0; j &lt; 10; j++) &#123;  // 内层循环控制器\n\n内层循环启动：j从0开始，每次外层循环执行时都会完整运行内层循环（最多10次）\n\nif(condition) &#123;  // 条件判断（实际应为具体条件表达式）\n\n条件检测：当遇到满足条件的case时（例如找到特定值），进入条件块\n\nfound = 1;  // 设置状态标志（1表示已找到目标）\n\n状态更新：将标志位置为1，通知外层循环需要提前终止\n\nbreak;  // 终止内层循环（仅跳出当前j循环）\n\n跳出内层：立即结束当前内层循环，继续执行外层循环的后续代码\n\n&#125;if(found) break;  // 检查到状态变化时跳出外层循环\n\n外层退出检查：当发现found变为1时，终止外层循环，完全退出双重循环结构\n\n执行流程示意图：\ni=0 → j=0→1→2...直到条件满足→found=1→break→外层检查found→break→程序继续     ↖条件不满足时继续        ↗i=1 → j=0→1→2...直到条件满足......\n\n典型应用场景：\n\n在二维数组中查找特定元素（如数字矩阵中找某个值）\n嵌套数据结构的遍历（如坐标网格的扫描）\n需要提前终止的双重循环场景（如密码破解尝试）\n\n设计特点分析：✅ 优点：\n\n符合C语言结构化编程规范\n明确的状态控制（标志位可见性好）\n可扩展性强（可添加其他退出条件）\n\n⚠️ 注意事项：\n\n需要保持标志位作用域正确（不能在函数间传递）\n条件判断必须具体有效（原代码中需替换为实际条件）\n多线程环境下需考虑原子操作（非本例场景）\n\n性能特征：\n\n最坏情况执行100次循环体（10×10）\n最早可在第一次迭代就终止（当condition在i&#x3D;0,j&#x3D;0时成立）\n空间复杂度O(1)（仅使用固定数量的变量）\n\n\n技巧2：打印调试信息追踪流程for(int i = 1; i &lt;= 2; i++) &#123;    printf(&quot;外层循环第%d次\\n&quot;, i);    for(int j = 1; j &lt;= 2; j++) &#123;        printf(&quot;  内层循环第%d次\\n&quot;, j);    &#125;&#125;\n输出：  \n外层循环第1次    内层循环第1次    内层循环第2次  外层循环第2次    内层循环第1次    内层循环第2次  \n\n\n七、总结：嵌套循环的哲学\n适用场景：  \n多维度数据处理（如矩阵运算）。  \n分层任务（如打印图形、批量验证素数）。\n\n\n核心原则：  \n先设计外层逻辑，再细化内层操作。  \n避免无限嵌套，超过3层应考虑拆分函数。\n\n\n记忆口诀：「外层控次数，内层做操作；break只跳一层，标志位助跳多层」。\n\n\n就像人生选择——单层循环是直线思维，嵌套循环则是立体规划！\n\n","tags":["C Language"]},{"title":"第三章——顺序结构 第二节——数据的输出","url":"/Blog/posts/1478262f/","content":"数据的输出在C语言中，我们有多种方式可以将数据输出到控制台。最常用的是 printf 函数和 putchar 函数。\n1. putchar 函数1.1 格式int putchar(int c);\n\n1.2 参数说明\nc：可以是字符常量、变量或表达式。\n\n1.3 功能\n将一个字符输出到显示屏。\n\n1.4 返回值\n正常情况下返回显示字符的ASCII码值（如 &#39;A&#39; 返回 65）。\n如果出错，返回 EOF（通常为 -1）。\n\n1.5 示例代码#include &lt;stdio.h&gt;int main() &#123;    char ch = &#x27;A&#x27;;    int ascii = 65;        printf(&quot;使用 putchar 输出字符: \\n&quot;);    putchar(ch);      // 输出字符 A    putchar(&#x27;\\n&#x27;);   // 换行    putchar(ascii);   // 同样输出 A    putchar(&#x27;\\n&#x27;);   // 换行        return 0;&#125;\n\n运行结果：\n使用 putchar 输出字符: AA\n\n1.6 说明\nputchar() 函数虽然参数是 int 类型，但实际上是用于输出字符\n当传入整型变量时，它会将其解释为其对应的 ASCII 码值\n本例中，65 对应的 ASCII 字符是 ‘A’，因此两个不同的输入方式产生了相同的输出结果\n\n\n2. printf 函数2.1 格式int printf(const char *format, ...);\n\n2.2 功能\n根据指定的格式字符串输出格式化的数据。\n\n2.3 常用格式化符号\n\n\n格式符\n类型\n示例\n\n\n\n%d\n十进制整数\nprintf(&quot;%d&quot;, 123);\n\n\n%f\n浮点数\nprintf(&quot;%f&quot;, 3.14);\n\n\n%c\n字符\nprintf(&quot;%c&quot;, &#39;A&#39;);\n\n\n%s\n字符串\nprintf(&quot;%s&quot;, &quot;Hello&quot;);\n\n\n%.2f\n保留两位小数\nprintf(&quot;%.2f&quot;, 3.14159);\n\n\n%x\n十六进制整数\nprintf(&quot;%x&quot;, 255);\n\n\n2.4 示例代码#include &lt;stdio.h&gt;int main() &#123;    int age = 20;    float price = 9.99f;    char grade = &#x27;B&#x27;;        printf(&quot;年龄：%d\\n&quot;, age);    printf(&quot;价格：%.2f\\n&quot;, price);    printf(&quot;等级：%c\\n&quot;, grade);    printf(&quot;十六进制：%x\\n&quot;, 255);        // 多个参数示例    printf(&quot;学生信息：姓名-%s，年龄-%d，成绩-%.1f\\n&quot;, &quot;张三&quot;, 18, 89.5);        return 0;&#125;\n\n运行结果：\n年龄：20价格：9.99等级：B十六进制：ff学生信息：姓名-张三，年龄-18，成绩-89.5\n\n2.5 格式化输出详解(1) 宽度控制int num = 42;printf(&quot;&#x27;%10d&#x27;\\n&quot;, num);   // 右对齐，总宽度为10printf(&quot;&#x27;%-10d&#x27;\\n&quot;, num);  // 左对齐，总宽度为10\n\n(2) 浮点数精度控制double pi = 3.1415926535;printf(&quot;%.3f\\n&quot;, pi);  // 输出 3.142（四舍五入）\n\n(3) 填充字符int num = 5;printf(&quot;%05d\\n&quot;, num);  // 用0填充空白，输出 00005\n\n\n3. 注意事项\nputchar 只能输出单个字符，适合简单的字符显示\nprintf 支持复杂的格式化输出，适合混合数据类型的输出\n使用 printf 时要注意格式字符串与参数类型的一致性，否则可能导致未定义行为\n常用格式符对应关系：\n%d 整数\n%f 浮点数\n%c 字符\n%s 字符串\n%% 输出百分号本身\n\n\n格式字符串中的普通字符会原样输出\n如果要输出百分号 %，需要写成 %%\n格式说明符的数量必须与输出项数量一致\n对于不匹配的格式说明符和参数，可能会导致不可预测的结果\nprintf 的返回值是实际输出的字符数，可用于后续计算\n\n","tags":["C Language"]},{"title":"第五章——循环结构 第二节——For语句及其延伸","url":"/Blog/posts/1b6c06df/","content":"🌟 for循环：循环世界的「时间管理大师」1.1 基本语法与执行逻辑for([变量初值]；[循环继续条件]；[循环变量增值]) &#123;    // 循环体语句组（条件为真时反复执行）&#125;\n执行流程图：\n\n（1）求解“变量赋初值”表达式。\n（2）求解“循环继续条件”表达式。如果其值非0，执行（3）；否则，转至（4）。\n（3）执行循环体语句组，并求解“循环变量增值”表达式，然后转向（2）。\n（4）执行for语句的下一条语句。\n\n&emsp;&emsp;for循环等价于\n表达式1;while(表达式2）&#123;    循环体；    表达式3&#125;\n1.2 案例：快递分拣员的终极考验场景：快递员需要分拣1到100号包裹，但遇到编号是质数的包裹时必须单独检查。  \n#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123;    for(int i = 2; i &lt;= 100; i++)     &#123;        int is_prime = 1;  // 标记是否为质数        for(int j = 2; j &lt;= sqrt(i); j++)         &#123;            if(i % j == 0)             &#123;                is_prime = 0;                break;  // 非质数直接跳出内层循环            &#125;        &#125;        if(is_prime)             printf(&quot;质数包裹：%d\\n&quot;, i);    &#125;    return 0;&#125;\n关键点：  \n\n双重循环：外层控制包裹编号，内层判断是否为质数。  \nbreak跳转：发现非质数立即跳出内层循环，提升效率。\n\n\n🚀 for循环的高级用法：多变量控制的艺术*2.1 案例：植物大战僵尸的「循环战术」场景：僵尸按行进攻，每行有5个僵尸，需逐个消灭并统计剩余僵尸数量。  \n#include &lt;stdio.h&gt;int main() &#123;    for(int row = 1, zombies = 5; row &lt;= 3; row++, zombies = 5) &#123;        printf(&quot;第%d波进攻！\\n&quot;, row);        for(; zombies &gt; 0; zombies--) &#123;            printf(&quot;击倒僵尸（剩余：%d）\\n&quot;, zombies - 1);        &#125;        printf(&quot;本波结束，刷新战场...\\n\\n&quot;);    &#125;    return 0;&#125;\n输出示例：  \n第1波进攻！  击倒僵尸（剩余：4）  击倒僵尸（剩余：3）  ...  本波结束，刷新战场...\n\n2.2 案例：时间沙漏的逆向计时场景：模拟火箭发射倒计时（从10到1），并在结束后输出“发射成功！”。  \n#include &lt;stdio.h&gt;int main() &#123;    for(int t = 10; t &gt;= 1; t--) &#123;        printf(&quot;倒计时：%d秒\\n&quot;, t);    &#125;    printf(&quot;🚀 发射成功！\\n&quot;);    return 0;&#125;\n\n\n⚠️ 常见错误与避坑指南\n\n\n错误类型\n错误代码\n修复方法\n\n\n\n死循环\nfor(;;) { ... }\n添加 break 或更新条件变量\n\n\n变量作用域错误\nfor(int i=0; i&lt;10; i++)\n避免在循环外使用循环变量\n\n\n表达式逻辑错误\nfor(i=0; i=10; i++)\n使用比较运算符而非赋值\n\n\n\n🧠 真题实战：理解for循环的本质4.1 真题1：变量作用域陷阱题目：以下代码输出什么？  \n#include &lt;stdio.h&gt;int main() &#123;    int i;    for(i = 0; i &lt; 5; i++);    printf(&quot;i=%d&quot;, i);&#125;\n解析：  \n\nfor后的分号导致循环体为空，i从0递增到5后终止循环。  \nprintf输出i=5。\n\n4.2 真题2：表达式省略的陷阱题目：以下代码输出什么？  \n#include &lt;stdio.h&gt;int main() &#123;    int i = 0;    for(; i &lt; 3;) &#123;        printf(&quot;%d &quot;, i++);    &#125;&#125;\n解析：  \n\n初始化和更新表达式被省略，需在循环体内手动更新i。  \n输出0 1 2。\n\n\n🎯 总结：for循环的哲学\n选for：当循环次数明确（如遍历数组、固定次数操作）或需要结构化控制时。  \n适用场景：已知边界条件、多变量控制、图形生成、算法实现（如排序、查找）。\n\n\n🎯 记忆口诀：「次数明确用for，结构紧凑控变量」就像人生选择——精确计划用for，动态调整用其他结构！\n\n\n几条算是比较正式的说明\n当循环体语句组仅由一条语句构成时，可以不使用复合语句形式（即可以不使用{ }）\n\n#include&lt;stdio.h&gt;main()&#123;  char  c;    for( ; (c=getchar())!=&#x27;\\n&#x27; ; )       printf(&quot;%c &quot;,c);        //此处可以不用&#123;&#125;围起来，但是，我喜欢！！围起来方便认！！       // 不围起来有时候会认错结构&#125;\n\n“循环变量赋初值”表达式，既可以是给循环变量赋初值的赋值表达式，也可以是与此无关的其它表达式（如逗号表达式）。\n\n例:main()&#123;    int  i,j,k;    for( i = 0 , j = 100 ; i &lt;= j ; i++ , j--)    &#123;        k=i+j;        printf(&quot;%d + %d = %d \\n&quot; , i , j , k);    &#125;&#125;\n\n“循环继续条件”部分是一个逻辑量，除一般的关系（或逻辑）表达式外，也允许是数值（或字符）表达式。\n\n\u000b\n例:#include &lt;stdio.h&gt;main()&#123;    int i , c;    for( i = 0 ; ( c = getchar() ) != &#x27;\\n&#x27; ; i += 3 )        printf(&quot;%c &quot;, i + c );&#125;\n\n\n几个考点\n变量赋初值表达式可以省略，但后面的分号不能省略，此时应在for语句之前给循环变量赋初值。\n如果省略循环继续条件，表示条件始终为真，循环将无终止。（又进入了死循环啊喂）\n如果省略变量赋初值表达式和循环变量增值表达式，此时完全等价于while语句。\nfor语句的循环语句可以是空语句，用来实现延时，但是后面的分号不能省略。\n\n","tags":["C Language"]},{"title":"第五章——循环结构 第零节——前言","url":"/Blog/posts/edbd7c58/","content":"第五章 循环之道——驾驭程序的永动机核心能力修炼：参悟三大循环秘术通过本章修炼，你将获得：\n\n破解while循环的”永动机关”咒语\n掌握do…while的”先斩后奏”心法\n领悟for循环的”三位一体”真言\n驯服嵌套循环的”九重天阵法”\n参悟break&#x2F;continue的”瞬移神通”\n\n知识脉络一、循环三重奏\nwhile循环：永不停歇的旋转门（先验型循环）\ndo…while循环：先开闸后验票的霓虹国地铁通道（后验型循环）\nfor循环：三位一体的时间控制器（初始化→条件→迭代）\n\n二、控制玄机\n嵌套艺术：外层如年轮，内层似日晷的套娃法则\nbreak破界：直通紧急出口的瞬间穿越\ncontinue跳转：跳过当前回合的特异功能\n\n三、实战应用场\n计数器：班级人数的点名系统\n数据验证：密码输入的三次机会机制\n定时任务：火箭发射的10秒倒计时\n模式匹配：字符串侦探的字符追踪\n\n修炼心法&emsp;&emsp;建议用”流程图思维”观察循环轨迹，重点参悟三种循环的适用场景差异。特别注意for循环三段式咒语的编写技巧，以及嵌套循环的层次控制要诀。警惕无限循环的”死锁”陷阱，善用调试器的单步追踪功能。\n","categories":["C_Language","第五章——循环结构"],"tags":["C Language"]},{"title":"第五章——循环结构 第五节——continue在循环结构中的应用","url":"/Blog/posts/5c3071d8/","content":"1. continue 是什么？——「跳过当次的按钮」&emsp;&emsp;想象你正在跳绳，突然手机响了。你不想停止运动，但也不想被打扰，于是按下“忽略”按钮，但是此时你又忘了这一组跳了多少，你索性直接不去管这一组剩下的内容，直接开始下一组的锻炼。&emsp;&emsp;核心功能：continue 就是这样的“忽略键”，在循环中遇到特定条件时，跳过当前这一轮的剩余代码，直接进入下一轮循环。  \n\n2. 单层循环中的应用：快递员的包裹筛选场景：快递员需要派送10个包裹，但编号为3和7的包裹是易碎品，需跳过检查，直接处理下一个。  \nfor(int 包裹编号 = 1; 包裹编号 &lt;= 10; 包裹编号++) &#123;    if(包裹编号 == 3 || 包裹编号 == 7) &#123;        printf(&quot;跳过易碎品包裹 %d，继续下一个。\\n&quot;, 包裹编号);        continue;  // 跳过当前包裹的检查    &#125;    printf(&quot;检查包裹 %d：正常。\\n&quot;, 包裹编号);&#125;\n输出：  \n检查包裹 1：正常。  检查包裹 2：正常。  跳过易碎品包裹 3，继续下一个。  检查包裹 4：正常。  ...  跳过易碎品包裹 7，继续下一个。  检查包裹 8：正常。  ...  \n总结：遇到特殊包裹就跳过检查，但整个派送流程继续执行。\n\n3. 嵌套循环中的行为：超市收银员的扫码挑战场景：超市收银员需要扫描20件商品，但第2排第3列的商品是赠品，需跳过计费，但继续扫描其他商品。  \nfor(int 排 = 1; 排 &lt;= 4; 排++) &#123;  // 4排货架    for(int 列 = 1; 列 &lt;= 5; 列++) &#123;  // 每排5个商品        if(排 == 2 &amp;&amp; 列 == 3) &#123;            printf(&quot;跳过赠品（%d排%d列），继续下一个。\\n&quot;, 排, 列);            continue;  // 仅跳出内层循环        &#125;        printf(&quot;扫描商品（%d排%d列）\\n&quot;, 排, 列);    &#125;&#125;\n输出：  \n扫描商品（1排1列）  ...  扫描商品（2排2列）  跳过赠品（2排3列），继续下一个。  扫描商品（2排4列）  ...  \n关键点：  \n\ncontinue 只影响最近的一层循环（这里是内层 列 循环），外层循环不受影响。  \n如果想跳出多层循环，需用标志变量或 goto（慎用）。\n\n\n4. 与 break 的对比：快递取件的两种选择\n\n\n场景\n动作\n代码实现\n结果\n\n\n\ncontinue\n找到包裹后继续检查其他柜子\ncontinue\n继续扫描后续格子\n\n\nbreak\n找到包裹后直接回家\nbreak\n完全终止搜索流程\n\n\n示例：  \nfor(int 柜子 = &#x27;A&#x27;; 柜子 &lt;= &#x27;C&#x27;; 柜子++) &#123;    for(int 格子 = 1; 格子 &lt;= 3; 格子++) &#123;        if(柜子 == &#x27;B&#x27; &amp;&amp; 格子 == 2) &#123;            printf(&quot;找到包裹！continue → 继续检查C区。\\n&quot;);            continue;  // 仅跳出内层循环        &#125;        if(柜子 == &#x27;B&#x27; &amp;&amp; 格子 == 2) &#123;            printf(&quot;找到包裹！break → 直接回家。\\n&quot;);            break;  // 跳出内层循环        &#125;    &#125;&#125;\n\n\n5. 注意事项：别踩这些坑！\n只能在循环中使用：如果写在 if 外单独使用，编译器会报错。  \nif(1)     continue;  // ❌ 错误！continue 必须在循环体内\n\n避免“穿透效应”：在 switch 中漏写 continue 会导致程序继续执行后续 case\n\n多层循环需谨慎：若想跳出多层循环，需用标志变量控制：  \nint 找到 = 0;for(...) &#123;    for(...) &#123;        if(条件) &#123;            找到 = 1;            continue;  // 仅跳出内层循环        &#125;    &#125;    if(找到) break;  // 再跳出外层循环&#125;\n\n\n6. 总结：continue 的哲学\n适用场景：  \n过滤无效数据（如跳过负数求和）。  \n简化逻辑（避免冗长的 if-else 嵌套）。\n\n\n记忆口诀：「continue 是跳过键，一层循环跳一层；多层需靠标志位，别在 if 乱跳圈！」\n\n&emsp;&emsp;就像人生选择——该跳过时就跳过，别纠结！（亓翎你怎么老是写这些奇奇怪怪的）\n","tags":["C Language"]},{"title":"第五章——循环结构 第四节——break在循环结构中的应用","url":"/Blog/posts/9c79d42/","content":"1. break 是什么？——「紧急逃生门」&emsp;&emsp;想象你在玩一个闯关游戏，突然遇到一个死循环的迷宫，每次走到某个路口就会重复绕圈。这时，你发动神祈技能，将自我瞬间传送到迷宫出口——这就是 break 的作用。核心功能：在循环中遇到特定条件时，立刻跳出整个循环，不再执行后续代码。  \n\n2. 生活场景举例：找钥匙的启示场景：你回家发现钥匙丢了，决定从背包的每一层夹层里找。  \n\n循环逻辑：遍历背包的每一层（循环体）。  \nbreak 条件：一旦在第三层找到钥匙，立刻停止搜索（break）。\n\nfor(int 层 = 1; 层 &lt;= 5; 层++) &#123;    if(层 == 3) &#123;  // 假设钥匙在第三层        printf(&quot;找到钥匙！结束搜索。\\n&quot;);        break;  // 跳出循环    &#125;    printf(&quot;在第%d层没找到...\\n&quot;, 层);&#125;\n输出：  \n在第1层没找到...  在第2层没找到...  找到钥匙！结束搜索。  \n总结：找到了就别再翻了，直接回家！\n\n3. 嵌套循环中的 break：快递取件的智慧场景：你去快递柜取包裹，需要遍历多个快递点，每个快递点有多个格子。  \n\n外层循环：遍历快递点（A区、B区、C区）。  \n内层循环：检查每个格子是否有你的包裹。  \nbreak 条件：一旦找到包裹，跳出内层循环，但继续检查下一个快递点（除非你也想退出外层循环，需要额外操作）。\n\nfor(int 区域 = &#x27;A&#x27;; 区域 &lt;= &#x27;C&#x27;; 区域++) &#123;    printf(&quot;检查 %c 区：\\n&quot;, 区域);    for(int 格子 = 1; 格子 &lt;= 3; 格子++) &#123;        if(区域 == &#x27;B&#x27; &amp;&amp; 格子 == 2) &#123;  // 假设包裹在 B 区 2 号格子            printf(&quot;找到包裹！结束当前区域搜索。\\n&quot;);            break;  // 仅跳出内层循环        &#125;        printf(&quot;  检查 %c 区 %d 号格子...没找到。\\n&quot;, 区域, 格子);    &#125;&#125;\n输出：  \n检查 A 区：    检查 A 区 1 号格子...没找到。    检查 A 区 2 号格子...没找到。    检查 A 区 3 号格子...没找到。  检查 B 区：    检查 B 区 1 号格子...没找到。  找到包裹！结束当前区域搜索。  检查 C 区：    检查 C 区 1 号格子...没找到。    检查 C 区 2 号格子...没找到。    检查 C 区 3 号格子...没找到。  \n总结：在 B 区找到包裹后，只跳出“检查格子”的循环，但依然会继续检查 C 区（除非你再加一个 break）。\n\n4. 注意事项：别踩这些坑！\n只能跳出一层循环：如果想跳出多层循环，可以用标志变量或 goto（但 goto 是邪修啊，慎用！）。  \nint 找到 = 0;for(...) &#123;    for(...) &#123;        if(找到包裹) &#123;            找到 = 1;            break;  // 仅跳出内层循环        &#125;    &#125;    if(找到) break;  // 再跳出外层循环&#125;\n\n必须用在循环或 switch 中：如果写在普通代码里，编译器会报错。  \nif(1) &#123;    break;  // ❌ 错误！break 不能在 if 中单独使用&#125;\n\n别忘记加 break，否则“穿透”：在 switch 中漏写 break 会导致程序继续执行后续 case\n\n\n\n5. 总结：break 的哲学\n适用场景：  \n搜索目标：找到即停（如查字典、找停车位）。  \n异常处理：遇到错误立即终止流程（如银行卡输错密码超过次数）。\n\n\n记忆口诀：「break 是紧急门，一层循环跳一层；多层需靠标志位，别在 if 乱开门！」\n\n&emsp;&emsp;就像人生选择——该止损时就止损，别犹豫！\n\n稍微正式一点的考点总结：\nbreak只能用在循环体内和switch语句体内。\nbreak能且只能跳出一层循环。\n如果要跳出多层循环，需要利用邪修goto的力量。\n\n","tags":["C Language"]},{"title":"第九章——数组 第一节——一维数组的定义与初始化","url":"/Blog/posts/c960dd98/","content":"数组&emsp;&emsp;数组是C语言所提供的最简单的构造类型。每个数组包含一组具有同一类型的变量，这些变量在内存中占有连续的存储单元。\n🎯 核心目标：掌握一维数组的定义规则、初始化方式及内存分配机制  \n\n一维数组的定义🔧 基本语法与规则类型名 数组名[整型常量表达式];\n示例代码如下：\nint a[5];\n\n定义三要素：  \n类型名（如 int, char）  \n数组名（合法标识符，如 a, score）  \n长度（常量表达式，如 5, N）\n\n\n\n📦 内存分配规则\n连续存储：数组元素在内存中占用连续空间  \n字节数计算：数组长度 * sizeof(元素类型)  \n地址特性：数组名是首地址常量，不可修改\n\n🚫 常见错误与避坑指南\n\n\n错误类型\n错误代码示例\n修复方法\n\n\n\n变量定义长度\nint n=5; int a[n];\n改为 int a[5];\n\n\n越界访问\na[5] = 10;（长度为5）\n确保下标范围 0到总长度-1，对于这个东西的个人理解就是超出范围了，数组是从0开始的，而我们习惯1开始\n\n\n非整型下标\nfloat a[3.5];\n下标必须为整型常量表达式\n\n\n\n一维数组的初始化✅ 初始化方式对比\n\n\n初始化类型\n语法示例\n内存效果\n\n\n\n完全初始化\nint a[5] = {1,2,3,4,5};\n全部元素赋初值\n\n\n部分初始化\nint a[5] = {1,2};\n未显式初始化的元素默认为0\n\n\n省略长度\nint a[] = {1,2,3};\n编译器自动推导长度为3\n\n\n静态数组默认值\nstatic int a[3];\n默认初始化为0\n\n\n🧠 关键点解析\n默认值规则：未初始化的局部数组元素值为随机数，静态数组默认为0  \n长度省略技巧：char c[] = {&#39;a&#39;}; 等价于 char c[1] = {&#39;a&#39;};  \n错误案例：int a[3] = {1,2,3,4}; ❌（初始值过多）\n\n\n说明\n数组不初始化，其元素值为随机数\n对static数组元素不赋初值，系统自动赋0\n部分元素赋初值，其余为0\n全部元素赋初值，可以不指定长度\n\n\n真题实战与调试技巧🧪 真题1（2005年4月）题目：以下能正确定义一维数组的选项是A. int a[5]={0,1,2,3,4,5};B. char a[]={&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;};C. char a={&#39;A&#39;,&#39;B&#39;,&#39;C&#39;};D. int a[5]=&quot;0123&quot;;  \n答案：B解析：  \n\nA选项初始值个数超过数组长度  \nC选项缺少数组定义符号[]  \nD选项字符串长度隐含+1（包含\\0），实际需长度为5\n\n\n🧪 真题2（数组越界陷阱）代码：  \nint a[3] = &#123;0&#125;; printf(&quot;%d&quot;, a[3]); // ❓输出什么？\n答案：输出随机值或导致崩溃解析：数组下标越界访问了未分配的内存  \n\n高级技巧与调试方法🔍 调试技巧：观察数组内存布局#include &lt;stdio.h&gt;int main() &#123;    int a[3] = &#123;0x11223344, 0x55667788, 0x99AABBCC&#125;;    for(int i=0; i&lt;3; i++) &#123;        printf(&quot;a[%d] 地址: %p 值: %x\\n&quot;, i, &amp;a[i], a[i]);    &#125;    return 0;&#125;\n输出示例（小端序机器）：  \na[0] 地址: 0061FF1C 值: 11223344  a[1] 地址: 0061FF20 值: 55667788  a[2] 地址: 0061FF24 值: 99AABBCC  \n结论：数组元素连续存储，地址递增  \n\n🎯 总结口诀数组定义三要素，连续存储按索引  初始化可省长度，静态默认零填充  越界访问风险高，调试打印看地址  真题多练避坑道，一维基础要打牢","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第九章——数组 第八节——通过建立行指针引用二维数组元素","url":"/Blog/posts/e1e1b6a3/","content":"&emsp;&emsp;若有以下定义\nint a[3][2],(*prt)[2]\n说明\n*号先与prt 结合，说明prt是指针变量\n然后*prt再与[2]结合，说明指针变量的基类型是包含2个元素的数组。3.＊prt的基类型与a相同所以：prt&#x3D;a是合法的赋值。prt+1相当于a+1相当于a[1]\n\n\n&emsp;&emsp;这里prt是一个指针变量，值可变，而a的值不可变。\n","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第九章——数组 第三节——指向数组的指针变量的运算","url":"/Blog/posts/8f65a35d/","content":"数组名&emsp;&emsp;数组名可认为是一个存放地址值的指针变量名\n注意：&emsp;&emsp;这个指针变量中的地址值不可改变，即不可以给数组名重新赋值！也可认为数组名是一个地址常量。\n&emsp;&emsp;例如：\nfloat a[10],*p,x;    a=&amp;x;    a++;// 以上写法均错误\n\n&emsp;&emsp;数组名是表示数组首地址的地址常量&emsp;&emsp;可以用对数组名加一个整数的办法，来依次表达上不同元素的地址。&emsp;&emsp;例：\nfloat a[10],*p,k;for(k=0;k&lt;10;k++)         p=a+k;\n\n\n指向数组的指针for(k=0;k&lt;10;k++)    scanf(“%d”,a+k);\n&emsp;&emsp;下面的语句功能均是从键盘读入数放入数组中\n//=====语句1=======//for(p=a,k=0;k&lt;10;k++)&#123;    scanf(“%d”,p);    p++;&#125;//=====语句2=======//for(p=a,k=0;k&lt;10;k++)    scanf(“%d”,p++)；//=====语句3=======//for(p=a;p-a&lt;10;p++)    scanf(“%d”,p);\n\n&emsp;&emsp;还可以通过移动指针逐个输出数组元素\nfloat a[10],*p,k;for(p=a,k=0;k&lt;10;k++)&#123;    printf(“%4d”,*p);    p++;&#125;// 其中，for循环中语句可以改成printf(“%4d”,*p++); // 整体可以是float a[10],*p;for(p=a;p-a&lt;10;p++)    printf(“%4d”,*p); \n考点&emsp;&emsp;在调用函数时，数组元素作为实参传递给形参，每个数组元素实际上代表内存中的一个存储单元，和普通变量一样，对应的形参必须是类型相同的变量。数组元素的值可以传递给对应的形参变量，在函数中只能对该变量进行操作，而不能直接引用对应的数组元素，更不可能在函数中改变对应数组元素的值。\n","tags":["C Language"]},{"title":"第九章——数组 第七节——通过地址引用二维数组","url":"/Blog/posts/f07b224/","content":"二维数组和数组元素的地址\nint  a[3][4],*p;\n\n二维数组a由若干个一维数组组成\na[3][4]可视为由a[0]，a[1], a[2]这三个元素组成。其中a[0] ，a[1], a[2]又是由四个整型数组成的一维数组，可用a[0][0]，a[0][1]等来引用a[0]中的某个元素，其它以此类推。\n一维数组名代表了一个不可变的地址常量，所以a[0] ，a[1], a[2]也代表了一个地址常量，其值依次为二维数组每行第一个元素的地址，基类型就是数组元素的类型。所以a[0]++是非法的，而a[0]+1表示第一行第二个元素，即a[0][1]\n指针p的基类型与a[i]相同，所以p&#x3D;a[i]是合法的。因为a[i]&#x3D;&#x3D;(a+i)，所以p&#x3D;(a+i)\n\n说明\n1 维：&amp; (a[i]) &#x3D; &amp; ( (a+i) ); 注意 &amp; 抵消，得 &amp;a[i] &#x3D; (a+i )\n2 维; &amp;(a[i][j]) &#x3D; (*(a+i) + j);\n\n\n二维数组名也是一个地址常量（可理解为一个行指针）\n二维数组名是一个存放地址常量的指针，其值为二维数组第一个元素的地址。\na的值和a[0][0]相同，不过基类型不同。a的基类型为具有4个整型元素的数组类型，即a+0的值与a[0]相同，a+1的值与a[1]相同。\na+1中的数值1是4＊2个字节\n赋值语句p=a；是不合法的，因为p和a的基类型不同。\n\n二维数组元素的地址&emsp;&emsp;元素的地址有以下几种表示方式：\n\n&amp;a[i][j]\na[i]+j\n*(a+i)+j\n&amp;a[0][0]+i*4+j\na[0]+4*i+j\n\n注意&emsp;&emsp;&amp;a [i][j]，a[i]都是基类型为int类型，而a的基类型为具有四个元素的一维数组，所以a+i*4+j是错误的。\n则数组a中的元素a[i][j]有以下五种表达方式：\na[i][j]\n(*(a+i))[j]\n*(a[i]+j)\n((a+i)+j)\n(&amp;a[0][0]+4i+j)\n\n&emsp;&emsp;以上均等价于\n\n&amp;a[i][j]\na[i]+j\n*(a+i)+j\n&amp;a[0][0]+i*4+j\na[0]+4*i+j\n\n","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第九章——数组 第二节——一维数组元素的应用","url":"/Blog/posts/acc1ea0a/","content":"一维数组的引用规定\n数组必须先定义，后使用\n只能逐个引用数组元素，不能整体引用\n对于字符数组可以整体输入输出\n\n#include &lt;stdio.h&gt;int main() &#123;    // 示例1：整型数组逐个使用    int numbers[3];    numbers[0] = 10;    numbers[1] = 20;    numbers[2] = 30;        printf(&quot;整型数组元素：\\n&quot;);    printf(&quot;numbers[0] = %d\\n&quot;, numbers[0]);    printf(&quot;numbers[1] = %d\\n&quot;, numbers[1]);    printf(&quot;numbers[2] = %d\\n&quot;, numbers[2]);    // 示例2：字符数组整体使用    char name[20];    printf(&quot;\\n请输入您的姓名：&quot;);    scanf(&quot;%s&quot;, name);  // 注意：字符数组作为参数时不需要&amp;    printf(&quot;您好，%s！\\n&quot;, name);    return 0;&#125;\n\n数组元素的表示形式：数组名[下标]\n其中：下标可以是常量或者整型表达式\n\n\n\n一维数组的引用方法通过数组名引用int a[5] = &#123;1, 2, 3, 4, 5&#125;;printf(&quot;%d\\n&quot;, a[0]);\n\n通过数组的首地址引用元素&emsp;&emsp;通过间接访问运算符*：引用地址所在存储单元。\na=&amp;a[0]*&amp;a[0]=*(a+0)=*a\n&emsp;&emsp;例如：以下语句的功能是逐个输出a数组元素中的值\nfor(k=0;k&lt;10;k++)    printf(“%d”,*(a+k));// 等价于for(k=0;k&lt;10;k++)    printf(“%d”,a[k]);\n\n通过指针引用一维数组元素float array[10],*p,k;p=a ;for(k=0;k&lt;10;k++)   printf(“%4d”,*(p+k));// 没有移动指针，等价于for(k=0;k&lt;10;k++)   printf(“%4d”, a[k]);\n\n用带下标的指针变量引用int *p,a[10],i;p=a;// 可以用以下三种表示a[i]的地址＆a[i]a+ip+i// 也可以用四种表达式来表示数组元素a[i]a[i]*(p+i)*(a+i)p[i]\n注意&emsp;&emsp;p[i]和 a[i]均可表示数组中的第i个元素，但是a和p有着明显的区别，a是不可变的，而p中的地址却是可以改变的。\n\na&#x3D;p , a++&emsp;&emsp;&emsp;&emsp;错误p++ ， p&#x3D;a ， p&#x3D;&amp;a[i]&emsp;&emsp;正确\n\n\n","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第九章——数组 第五节——二维数组的定义和初始化","url":"/Blog/posts/7f11a91f/","content":"二维数组的定义定义方式\n数据类型　数组名[常量表达式-表示行数][常量表达式-表示列数]；\n\n&emsp;&emsp;例如：\nint a[3][4];  float b[2][5];int c[2][3][4];int a[3,4]; // 此种表示方法是错误的\n数组元素的存放顺序\n前提：内存空间是一维等等\n二维数组：按照行序优化最快\n\n&emsp;&emsp;有如下二维数组\nint a[3][2]\n&emsp;&emsp;则矩阵为\n\n&emsp;&emsp;数组元素存放顺序为：\n二维数组的理解&emsp;&emsp;二维数组理解为二维矩阵，矩阵的元素存放顺序为行序优化，即先把第一行的元素一个一个存放，然后第二行，第三行，依次类推。\n二维数组的初始化分行初始化全部初始化&emsp;&emsp;有如下二维数组\nint a[2][3] = &#123;    &#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;\n&emsp;&emsp;将二维数组中的元素全部按行声明。\n部分初始化&emsp;&emsp;有如下二维数组\nint a[2][3] = &#123;    &#123;1,2&#125;,&#123;4&#125;&#125;;\n&emsp;&emsp;部分初始化，将数组的元素按行声明，剩余元素将初始化为0。\n第一维长度省略初始化&emsp;&emsp;关于这个，需要展开说说&emsp;&emsp;在C语言中，二维数组的分行初始化中省略第一维长度是指：在声明数组时，若通过初始化列表提供了所有元素的值，并且明确指定了第二维的长度，编译器会根据初始化列表中元素的总数和第二维的大小，自动推导出第一维的长度。这种省略方式使得代码更简洁，且避免了手动计算第一维的麻烦。\n\n具体规则\n必须指定第二维的长度例如：int arr[][3] = { ... };第二维的长度（这里是3）不能省略，因为编译器需要知道每行有多少个元素，才能正确分配内存并计算第一维的大小。\n\n初始化列表中元素的总数必须能被第二维的大小整除编译器会将初始化列表中的所有元素按行优先（row-major）的顺序填充到数组中，并根据每行的大小（第二维长度）计算出第一维的大小。例如：  \nint arr[][3] = &#123;1, 2, 3, 4, 5, 6&#125;; // 初始化列表有6个元素，第二维长度为3  // 第一维大小 = 6 / 3 = 2  // 等价于：int arr[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;\n\n分行初始化时，每行的元素数量可以少于第二维的大小如果某行的初始化元素少于第二维的大小，剩余元素会自动补零。例如：  \nint arr[][3] = &#123;&#123;1, 2&#125;, &#123;3&#125;&#125;;  // 等价于：int arr[2][3] = &#123;&#123;1, 2, 0&#125;, &#123;3, 0, 0&#125;&#125;;\n\n分行初始化时，每行的元素数量不能超过第二维的大小否则会导致初始化列表的元素数量超出数组容量，引发编译错误或未定义行为。例如：  \nint arr[][3] = &#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6&#125;&#125;; // 错误！第一行有4个元素，超过第二维大小3\n\n\n示例解析示例1：完整初始化int matrix[][4] = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125; &#125;;// 第一维大小 = 2（初始化列表总共有8个元素，每行4个）\n\n示例2：部分初始化int matrix[][4] = &#123; &#123;1, 2&#125;, &#123;3&#125; &#125;;// 第一维大小 = 2  // 等价于：&#123;&#123;1, 2, 0, 0&#125;, &#123;3, 0, 0, 0&#125;&#125;\n\n示例3：非分行初始化int matrix[][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;// 第一维大小 = 8 / 4 = 2  // 等价于：&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;&#125;\n\n\n注意事项\n第二维长度不可省略如果省略第二维长度，编译器无法推导出每行的元素数量，导致错误。  \nint arr[][] = &#123; &#123;1, 2&#125;, &#123;3, 4&#125; &#125;; // 错误！第二维长度不可省略\n\n避免越界风险如果初始化列表的元素数量不能被第二维大小整除，可能导致数组越界或未定义行为。  \nint arr[][3] = &#123;1, 2, 3, 4, 5&#125;; // 错误！5个元素无法被3整除\n\n代码可读性省略第一维长度时，建议通过注释或命名清晰表达数组的逻辑结构，以提高代码可读性。\n\n\n\n总结\n省略第一维长度：适用于初始化列表完整且第二维大小明确的场景。\n核心原理：编译器根据初始化列表的元素总数和第二维大小自动计算第一维长度。\n适用场景：适合数组元素固定且初始化列表已知的情况，例如静态配置表、矩阵等。\n\n通过这种方式，开发者可以更灵活地定义数组，减少手动计算维度的负担，同时保持代码的清晰性。\n按元素排列顺序初始化全部初始化&emsp;&emsp;有如下二维数组\nint a[2][3] = &#123;    1, 2, 3, 4, 5, 6&#125;;\n\n部分初始化&emsp;&emsp;有如下二维数组\nint a[2][3] = &#123;    &#123;1,2,4&#125;&#125;;\n&emsp;&emsp;部分初始化，将数组的元素按行声明，剩余元素将初始化为0。&emsp;&emsp;与分行不同的是，此处全部放在了第一行，因此第二行全是0\n第一位长度省略初始化&emsp;&emsp;详细和分行初始化差不多，但是依旧是，必须要有第二维的长度，然后所输入的内容，按列个数依次分行。\n","tags":["C Language"]},{"title":"第九章——数组 第六节——二维数组元素的一般引用","url":"/Blog/posts/30668c4d/","content":"二维数组元素的引用形式\n数组名[行索引][列索引]\n\n&emsp;&emsp;例如：\n double w[4][2];// 如下几种写法均正确//w[0][2]//w[i][j]//w[i+k][j+k]//====错误写法====//// w[0,2]// w[i j]// w(i+k)(j+k)","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第六章——字符型数据 拓展节02——字符串长度函数strlen","url":"/Blog/posts/db9cac41/","content":"字符串长度函数strlen\n字符串长度函数strlen\n格式：strlen(字符数组)\n功能：计算字符串长度\n返值：返回字符串实际长度，不包括‘\\0’在内\n\n题目示例\n例  对于以下字符串，strlen(s)的值为：（1）char  s[10]&#x3D;{‘A’,‘\\0’,‘B’,‘C’,‘\\0’,‘D’};（2）char  s[ ]&#x3D;“\\t\\v\\\\0will\\n”;（3）char  s[ ]&#x3D;“\\x69\\082\\n”; \n\n答案：\n1\n3\n1\n\n解析（1）char s[10] = {&#39;A&#39;, &#39;\\0&#39;, &#39;B&#39;, &#39;C&#39;, &#39;\\0&#39;, &#39;D&#39;};&emsp;&emsp;这是一个字符数组初始化，注意是 显式地列出每个字符，而不是使用字符串字面量初始化。\n数组内容如下：\n\n\n\n下标\n字符\n\n\n\n0\n‘A’\n\n\n1\n‘\\0’\n\n\n2\n‘B’\n\n\n3\n‘C’\n\n\n4\n‘\\0’\n\n\n5\n‘D’\n\n\n6\n‘\\0’（默认填充）\n\n\n7\n‘\\0’\n\n\n8\n‘\\0’\n\n\n9\n‘\\0’\n\n\n\nstrlen(s) 是从第一个字符开始计算，直到遇到第一个 \\0（空字符）为止。\n第一个 \\0 在下标为 1 的位置，所以 strlen(s) 只计算到 &#39;A&#39;。\n\n✅ 答案：strlen(s) = 1\n\n（2）char s[] = &quot;\\t\\v\\\\\\0will\\n&quot;;&emsp;&emsp;这是一个字符串字面量初始化。我们需要理解其中的转义字符：\n字符串内容为：\n\\t   --&gt; 水平制表符\\v   --&gt; 垂直制表符\\\\   --&gt; 一个反斜杠 \\\\0   --&gt; 空字符（字符串结束标志）w i l l \\n\n\n&emsp;&emsp;但注意：在字符串中，\\0 是字符串的终止符。也就是说，strlen(s) 遇到这个 \\0 就会停止。\n&emsp;&emsp;字符串实际内容如下（以可见形式表示）：\n\\t \\v \\\\ \\0 w i l l \\n\n\n\nstrlen(s) 会在遇到第一个 \\0 时停止。\n\\t, \\v, \\\\ 是三个有效字符，后面是 \\0。\n\n✅ 答案：strlen(s) = 3\n\n（3）char s[] = &quot;\\x69\\082\\n&quot;;&emsp;&emsp;继续解析这个字符串中的每个字符：\n\n\\x69 是十六进制转义字符，对应 ASCII 码值为 0x69 = 105，对应的字符是 &#39;i&#39;。\n\\0 是八进制转义字符，表示空字符。\n82 中的 8 不是一个合法的八进制数字（只能是 0~7），因此 \\08 被视为非法转义序列。\n\n&emsp;&emsp;但在 C 语言中，对于非法的八进制转义如 \\08，编译器通常会将 \\0 视为一个单独的空字符，然后把 8 当作普通字符处理。\n&emsp;&emsp;所以字符串的实际内容是：\ni \\0 8 2 \\n\n\n\nstrlen(s) 会在第一个 \\0 处停止。\n\n✅ 答案：strlen(s) = 1\n\n✅ 最终答案汇总：\n\n\n编号\nstrlen(s)\n\n\n\n（1）\n1\n\n\n（2）\n3\n\n\n（3）\n1\n\n\n","tags":["C Language"]},{"title":"第九章——数组 第四节——数组元素地址作为函数的参数","url":"/Blog/posts/c04484d4/","content":"数组元素地址作为实参&emsp;&emsp;数组元素地址作为实参时，对应的形参也应当是基类型相同的指针变量。&emsp;&emsp;    数组名作为实参，对应的形参就应当是一个指针变量，并且指针的基类型必须与数组的类型一致。在函数中可以通过此指针变量来引用调用函数中对应的数组元素，从而达到对调用函数中对应的数组元素进行操作而改变其中的值。\n说明\n当数组名作为实参时，对应的形参除了是指针外，还可以用另外两种形式。\n\narrin(int *a)arrin(int a[])arrin(int a[M])\n&emsp;&emsp;对于后两种形式，虽然说明的形式与数组的说明相同，但C编译程序都将a处理成第一种的指针形式。\n\n当传递数组名时，在被调用函数中也同样可以用数组元素的形式来引用调用函数中对应的数组元素。这种只是形式上的相似，并不是整个数组可以传递给被调用函数。\n在被调用函数中，并没有为与数组名对应的形参开辟一串连续的空间，只是开辟了一个指针变量的存储单元。在被调用函数中所引用的数组元素就是实参数组中的元素。调用函数只是把数组的首地址传递给了形参指针，仍是遵循按“值”传递。\n\n","categories":["C_Language","第九章——数组"],"tags":["C Language"]},{"title":"第六章——字符型数据 拓展节01——字符串的输入和输出","url":"/Blog/posts/b4c9a61e/","content":"函数gets和puts输入或输出一行字符串&emsp;&emsp;不是哥们，这多古早的函数了，还在讲？\n\n字符串输入函数gets\n格式：gets(字符数组)\n功能：从键盘输入一以回车结束的字符串放入字符数组中，并自动加‘\\0’\n说明：输入串长度应小于字符数组维数\n\n\n字符串输出函数puts\n格式：puts(字符数组)\n功能：向显示器输出字符串（输出完，换行）\n说明：字符数组必须以‘\\0’结束\n\n#include &lt;stdio.h&gt;int main( )&#123;    char string[80];    printf(“Input a string:”);    gets(string);    puts(string);&#125;\n输入:  How  are  you?输出:  How  are  you?  ","categories":["C_Language","第六章——字符型数据"],"tags":["C Language"]},{"title":"第九章——数组 第九节——二维数组名作为实参时函数的调用","url":"/Blog/posts/24f285f3/","content":"二维数组作实参&emsp;&emsp;当二维数组作实参时，形参必须是一个行指针变量。&emsp;&emsp;例如主函数中有以下定义和函数调用语句：\n#include &lt;stdio.h&gt;#define M  5#define N 3main()&#123;    double s[M][N];    …    fun(s);    …&#125;\n&emsp;&emsp;则fun的首部可以是：\n\nfun(double (*a)[N])\nfun(double a[M][N])\nfun(double a[][N])\n\n注意\n列下标不可少\n系统把a处理成一个行指针\n系统只为形参开辟一个存放地址的存储单元，而不是一系列单元\n\n\n指针数组名作实参&emsp;&emsp;当指针数组名作实参时，形参应当是一个指向指针的指针。&emsp;&emsp;若主函数中有以下定义和函数调用语句：\n#include &lt;stdio.h&gt;#define M  5#define N 3main()&#123;    double s[M][N]，*ps[M];    …    for(i=0;i&lt;M;i++)         p[i]=s[i];    fun(ps);    …&#125;\n&emsp;&emsp;则fun的首部可以是：\n\nfun(double *a[M])\nfun(double  *a[])\nfun(double  **a)\n\n","tags":["C Language"]},{"title":"第六章——字符型数据 拓展节03——其他字符串处理函数","url":"/Blog/posts/483c67a0/","content":"字符串连接函数strcat\n格式：strcat(字符数组1,字符数组2)\n功能：把字符数组2连到字符数组1后面\n返值：返回字符数组1的首地址\n说明：\n字符数组1必须足够大\n连接前,两串均以‘\\0’结束;连接后,串1的‘\\0’取消,新串最后加‘\\0’\n\n\n\n字符串拷贝函数strcpy\n格式：strcpy(字符数组1,字符串2)\n功能：将字符串2，拷贝到字符数组1中去\n返值：返回字符数组1的首地址\n说明：\n字符数组1必须足够大\n拷贝时‘\\0’一同拷贝\n不能使用赋值语句为一个字符数组赋值\n\n\n\n#include &lt;string.h&gt;// 标准字符串处理库，提供strcpy/strcat等函数#include &lt;stdio.h&gt;// 标准输入输出库，提供printf函数void main()&#123;     // 定义字符数组destination，容量25个字符（包含字符串结束符\\0）   char destination[25];      // 定义三个常量字符串：   // blank: 空格字符数组（包含&#x27; &#x27;和\\0）   // c: 存储字符串&quot;C++&quot;（3字符+1结束符）   // turbo: 存储字符串&quot;Turbo&quot;（5字符+1结束符）   char blank[] = &quot; &quot;, c[]= &quot;C++&quot;,turbo[] = &quot;Turbo&quot;;   // 将turbo数组内容复制到destination（覆盖原有内容）   // destination现在包含&quot;Turbo\\0&quot;   strcpy(destination, turbo);      // 将blank数组内容追加到destination末尾   // destination现在变为&quot;Turbo \\0&quot;   strcat(destination, blank);      // 将c数组内容追加到destination末尾   // 最终destination存储&quot;Turbo C++\\0&quot;   strcat(destination, c);  // 格式化输出字符串，%s会自动输出到\\0为止的内容  printf(&quot;%s\\n&quot;, destination);  // 输出结果：Turbo C++&#125;\n\n\n字符串比较函数strcmp\n格式：strcmp(字符串1,字符串2)\n功能：比较两个字符串\n比较规则：对两串从左向右逐个字符比较（ASCII码），直到遇到不同字符或‘\\0’为止\n返值：返回int型整数\na. 若字符串1&lt; 字符串2， 返回负整数\nb. 若字符串1&gt; 字符串2， 返回正整数\nc. 若字符串1&#x3D;&#x3D; 字符串2， 返回零\n\n\n说明：字符串比较不能用“&#x3D;&#x3D;”,必须用strcmp\n\n","tags":["C Language"]},{"title":"第六章——字符型数据 第一节——字符型常量的定义","url":"/Blog/posts/601c8c23/","content":"一、基本概念：字符型常量的定义1.1 什么是字符型常量？&emsp;&emsp;字符型常量是用单引号括起来的单个字符，代表 ASCII 字符集中的一个符号。例如：  \n&#x27;A&#x27;  &#x27;9&#x27;  &#x27; &#x27;  &#x27;!&#x27;  // 合法字符常量  \n核心规则：  \n\n单引号内只能包含一个字符（如 &#39;abc&#39; 非法）。  \n单引号与双引号意义不同（&quot;a&quot; 是字符串，非字符常量）。  \n字符常量在内存中占 1 字节，存储其 ASCII 码值。\n\n1.2 真题实战：字符常量的运算字符常量本质是整数（ASCII 码），可参与运算：例题：  \nchar ch = &#39;B&#39;;  \nprintf(&quot;%c %d&quot;, ch, ch);  \n\n输出：B 66（字符 B 的 ASCII 码为 66）  \n\n二、语法与陷阱：字符型常量的易错点2.1 常见错误汇总\n\n\n错误类型\n错误示例\n修复方法\n\n\n\n多字符常量\n&#39;abc&#39;\n拆分为多个字符常量\n\n\n混淆单双引号\n&quot;A&quot;\n改为 &#39;A&#39;\n\n\n忽略空格与转义\n&#39; &#39;（合法）\n空格符是有效常量\n\n\n超出 ASCII 范围\n&#39;\\x13&#39;（合法，十六进制写法）\n使用合法转义字符\n\n\n混淆大小写\nA和a\n注意大小写区分\n\n\n2.2 转义字符的特殊规则以反斜杠 \\ 开头的字符序列为转义字符：  \n\n合法示例：&#39;\\n&#39;（换行）、&#39;\\101&#39;（八进制 ASCII 码对应字符）。  \n非法示例：&#39;\\081&#39;（八进制含非法数字 8）。\n\n\n三、进阶应用：字符与字符串的对比3.1 字符常量 vs 字符串常量\n\n\n特性\n字符常量\n字符串常量\n\n\n\n引号类型\n单引号 &#39; &#39;\n双引号 &quot; &quot;\n\n\n内容容量\n仅限单字符\n可含多字符及 \\0 结束符\n\n\n内存占用\n1 字节\n字符数 + 1 字节（\\0）\n\n\n示例对比：  \nsizeof(&#39;A&#39;)   // 1 字节  \nsizeof(&quot;A&quot;)   // 2 字节（&#39;A&#39; + &#39;\\0&#39;）  \n\n3.2 真题实战：字符串长度计算char s[10] = {&#39;A&#39;, &#39;\\0&#39;, &#39;B&#39;, &#39;C&#39;};  \nprintf(&quot;%d&quot;, strlen(s));  // 输出 1（`\\0` 终止）  \n\n\n四、调试与实践：字符处理技巧4.1 使用 getchar 与 putchar\n输入：ch = getchar();（读取单个字符，含空格）。  \n输出：putchar(ch);（直接输出字符）。\n\n案例：过滤输入中的 &#39;0&#39;  \nchar ch;  \nwhile ((ch = getchar()) == &#39;0&#39;)  \n    printf(&quot;#&quot;);  \n\n结果：输入 000 会输出 ###。  \n4.2 字符数组与字符串函数\n拷贝：strcpy(dest, src);（需确保 dest 足够大）。  \n拼接：strcat(dest, src);（自动覆盖 \\0 并添加新结束符）。\n\n\n五、总结：选择的艺术\n字符常量：处理单字符时使用，注重 ASCII 码运算与转义逻辑。  \n字符串常量：需用字符数组存储，依赖 \\0 结束符与库函数操作。\n\n🎯 记忆口诀：“单引号字符，双引号字符串；转义字符看反斜，字符串尾藏 \\0！”  \n","tags":["C Language"]},{"title":"第六章——字符型数据 第三节——转义字符的定义","url":"/Blog/posts/5097cfee/","content":"转义字符详解1.1 转义字符的定义与特性转义字符是以 **反斜杠 \\ 开头** 的特殊字符序列，用于表示无法直接输入的字符（如换行符 \\n）或具有特殊含义的字符（如单引号 \\&#39;）\n核心规则：  \n\n转义字符 只代表一个字符（如 &#39;\\n&#39; 是单个换行符）。  \n八进制转义字符以 \\ 开头，后跟 **1~3位八进制数**（如 &#39;\\101&#39; 对应字符 &#39;A&#39;）\n十六进制转义字符以 \\x （x小写）开头，后跟 1~2位十六进制数（如 &#39;\\x13&#39; 合法，但 \\X13 非法）\n\n\n二、语法与陷阱：转义字符的合法性2.1 合法与非法形式对比\n\n\n类型\n合法示例\n非法示例\n错误原因\n\n\n\n八进制转义\n&#39;\\101&#39;（&#39;A&#39;）\n&#39;\\081&#39;\n八进制数中包含非法数字 8\n\n\n十六进制转义\n&#39;\\x13&#39;\n&#39;\\X13&#39;、&#39;0x13&#39;\n必须以小写 x 开头，不能用大写或 0x\n\n\n单字符限制\n&#39;\\n&#39;\n&#39;\\\\&#39;\n反斜杠需与后续字符组合成合法转义\n\n\n2.2 真题实战：判断合法字符常量题目：以下哪个是合法的字符常量？A. &#39;\\x13&#39;B. &#39;\\081&#39;C. &#39;65&#39;D. &quot;\\\\n&quot;  \n答案：A解析：  \n\nA 合法：\\x 后接两位十六进制数 1 和 3，对应 ASCII 码 19（控制字符）\nB 非法：八进制数 081 包含非法数字 8\nC 非法：单引号内只能包含一个字符，&#39;65&#39; 是两个字符\nD 非法：双引号包裹的是字符串，非字符常量\n\n\n三、进阶应用：转义字符的常见用途3.1 控制字符的表示\n换行符：&#39;\\n&#39;（ASCII 码 10）  \n回车符：&#39;\\r&#39;（ASCII 码 13）  \n制表符：&#39;\\t&#39;（ASCII 码 9）  \n空字符：&#39;\\0&#39;（字符串结束标志）\n\n3.2 特殊符号的转义\n\n\n场景\n示例\n说明\n\n\n\n单引号与反斜杠\n&#39;\\&#39;、&#39;\\\\&#39;\n避免语法歧义\n\n\n非打印字符\n&#39;\\x07&#39;（响铃）\n用于设备控制或调试\n\n\n\n四、调试与实践技巧4.1 使用转义字符处理字符串char str[] = &quot;Hello \\\\n World&quot;;  // 分开转义，需转义为 &quot;\\\\ \\\\n&quot;  \nprintf(&quot;%s&quot;, str);  // 输出：Hello \\n World（实际显示为两行）  \n\n4.2 真题解析：字符串长度计算题目：  \nchar s[10] = {&#39;A&#39;, &#39;\\0&#39;, &#39;B&#39;, &#39;C&#39;};  \nprintf(&quot;%d %d&quot;, sizeof(s), strlen(s));  \n\n输出：10 1解析：  \n\nsizeof(s) 返回数组总大小（10 字节）。  \nstrlen(s) 遇到 \\0 终止，仅计算前 1 个字符\n\n\n五、总结\n转义字符：用于表示特殊字符（如换行、空格）或非打印字符。  \n字符常量：严格遵循单引号包裹和单字符规则。  \n字符串常量：需用双引号包裹，自动添加 \\0 结束符\n\n🎯 记忆口诀：“反斜杠后跟特殊码，八进十六要分清；单引号里一个符，字符串尾藏 \\0！”  \n","categories":["C_Language","第六章——字符型数据"],"tags":["C Language"]},{"title":"第六章——字符型数据 拓展节04——strlen和sizeof的区别","url":"/Blog/posts/91c504ba/","content":"strlen和sizeof的区别\nstrlen(s)是计算以s为起始地址的字符串的长度，并作为函数值返回。这一长度不包括字符串结尾的标志’\\0’。\nsizeof(s)是求数组a的长度，包括’\\0’，如果数组已经分配了大小N，则sizeof的值就为N.\n\n","categories":["C_Language","第六章——字符型数据"],"tags":["C Language"]},{"title":"第六章——字符型数据 第二节——字符型常量的运算","url":"/Blog/posts/3a5224ff/","content":"一、基本概念：字符型常量的数值本质1.1 字符常量的整型属性字符型常量在C语言中本质上是一个整数，其值为对应字符的 ASCII 码值。例如：  \n&#39;A&#39; == 65    // 真（ASCII 码值比较）  \n&#39;0&#39; == 48    // 真  \n\n核心规则：  \n\n字符常量可直接参与整数运算（如 &#39;A&#39; + 1）。  \n可进行关系运算（如 &#39;a&#39; &gt; &#39;Z&#39;）。\n\n1.2 真题实战：ASCII 码运算例题：  \nchar ch = &#39;B&#39;;  \nprintf(&quot;%c %d&quot;, ch, ch);  \n\n输出：B 66（字符 B 的 ASCII 码为 66）  \n\n二、运算规则与陷阱2.1 常见运算场景\n\n\n运算类型\n示例\n结果解释\n\n\n\n整数运算\n&#39;A&#39; + 32\n对应小写字母 a（ASCII 97）\n\n\n关系运算\n&#39;a&#39; &gt; &#39;A&#39;\n真（ASCII 码 97 &gt; 65）\n\n\n赋值运算\nint i = &#39;Z&#39;;\ni 的值为 90（ASCII 码）\n\n\n2.2 真题解析：大小写转换陷阱题目：以下哪项 不能 将大写字母转换为小写字母？  \nA. c = (c - &#39;A&#39;) % 26 + &#39;a&#39;;  \nB. c = c + 32;  \nC. c = c - &#39;A&#39; + &#39;a&#39;;  \nD. c = (&#39;A&#39; + c) % 26 - &#39;a&#39;;  \n\n答案：D（逻辑错误，(&#39;A&#39; + c) 无法正确计算偏移量）解析：选项 D 的错误在于 错误地使用 ‘A’ + c 作为模运算的基数 ，而非基于 c - ‘A’ 的偏移量。这种设计导致无法正确计算小写字母，甚至可能生成非法字符值。\n\n三、进阶应用：字符运算的实际用途3.1 加密与解密通过字符运算实现简单的凯撒加密：  \nchar ch = &#39;A&#39;;  \nch = (ch - &#39;A&#39; + 3) % 26 + &#39;A&#39;;  // 向后偏移3位，结果为 &#39;D&#39;  \n\n原理：利用 ASCII 码的连续性进行模运算。  \n3.2 输入验证判断字符是否为小写字母：  \nif (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) {  \n    printf(&quot;是小写字母&quot;);  \n}  \n\n优势：直接利用 ASCII 码的顺序性。  \n\n四、调试与实践技巧4.1 使用 putchar 和 getcharchar ch = getchar();  \nputchar(ch + 1);  // 输出下一个字符  \n\n案例：输入 &#39;X&#39;，输出 &#39;Y&#39;。  \n4.2 字符数组与字符串函数char str[] = &quot;Hello&quot;;  \nfor (int i = 0; str[i] != &#39;\\0&#39;; i++) {  \n    str[i] += 1;  // 每个字符后移一位（如 &#39;H&#39; -&gt; &#39;I&#39;）  \n}  \n\n结果：字符串变为 &quot;Ifmmp&quot;。  \n\n五、总结：选择的艺术\n字符运算：适用于直接操作 ASCII 码的场景（如加密、验证）。  \n字符串函数：需处理复杂文本时使用（如 strcpy、strcat）。\n\n🎯 记忆口诀：“字符运算看ASCII，整型操作随心转；大小写换加32，字符串拼接用库函！”  \n","tags":["C Language"]},{"title":"第六章——字符型数据 第七节——使用 getchar 和 putchar 函数进行字符的输入与输出","url":"/Blog/posts/22d79d1d/","content":"一、核心概念：单字符输入输出的“轻量级选手”1.1 getchar 与 putchar 的定义\ngetchar：从标准输入（键盘）读取一个字符（含空格、换行符），无需格式说明符。  char ch = getchar();  // 直接赋值  \n\n\nputchar：向标准输出（屏幕）输出一个字符，参数可以是字符常量、变量或 ASCII 码值。  putchar(&#39;A&#39;);         // 输出字符 A  \nputchar(97);          // 输出字符 a（ASCII 码值）  \n\n\n\n1.2 与 scanf/printf 的对比\n\n\n特性\ngetchar/putchar\nscanf/printf\n\n\n\n适用场景\n单字符输入输出\n格式化混合数据输入输出\n\n\n空白处理\n直接读取所有字符（含空格、换行）\n%c 需手动跳过空白符\n\n\n效率\n轻量级，适合简单操作\n灵活但稍复杂\n\n\n\n二、实战应用：典型用法与陷阱2.1 基础示例：字符回显与过滤char ch;  \nwhile ((ch = getchar()) != &#39;\\n&#39;) {  // 读取直到换行  \n    putchar(ch);                     // 输出字符  \n}  \n\n功能：逐字符回显输入内容，自动过滤换行符。  \n2.2 真题解析：输入缓冲区的陷阱题目：以下代码的输出是什么？  \n#include &lt;stdio.h&gt;  \nint main() {  \n    char c1 = getchar(), c2 = getchar();  \n    printf(&quot;c1=%c, c2=%d&quot;, c1, c2);  \n}  \n\n输入：A（回车）输出：c1=A, c2=10（c2 读取了换行符 \\n 的 ASCII 码 10）。  \n2.3 常见错误与修复\n\n\n错误类型\n错误示例\n修复方法\n\n\n\n忽略换行符\ngetchar() 读取后未处理 \\n\n使用 while(getchar() != &#39;\\n&#39;) 清空缓冲区\n\n\n混淆函数返回值类型\nchar ch = getchar() 可能截断\n改用 int 类型存储返回值（getchar 返回 int 以兼容 EOF）\n\n\n\n三、进阶技巧：控制字符与调试3.1 输出控制字符putchar 可直接输出转义字符：  \nputchar(&#39;\\n&#39;);  // 换行  \nputchar(&#39;\\x07&#39;); // 响铃（ASCII 码 7）  \n\n3.2 输入验证与过滤案例：仅允许输入数字字符：  \nchar ch;  \nwhile ((ch = getchar()) != &#39;\\n&#39;) {  \n    if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {  \n        putchar(ch);  \n    }  \n}  \n\n效果：输入 a1b2c3，输出 123。  \n\n四、调试与优化：避免死循环与缓冲区污染4.1 清空输入缓冲区int c;  \nwhile ((c = getchar()) != &#39;\\n&#39; &amp;&amp; c != EOF);  // 丢弃剩余字符  \n\n用途：防止前一次输入残留影响后续 getchar() 读取。  \n4.2 处理 EOF（文件结束符）getchar 在遇到文件结束符（Windows 下为 Ctrl+Z，Linux 下为 Ctrl+D）时返回 EOF（值为 -1）：  \nint ch;  \nwhile ((ch = getchar()) != EOF) {  \n    putchar(ch);  \n}  \n\n\n五、总结：选择的艺术\ngetchar/putchar：适用于单字符输入输出，简洁高效，无需格式字符串。  \nscanf/printf：需处理混合数据或格式化时使用，但需注意空白符陷阱。\n\n🎯 记忆口诀：“单字符选 get/put，空白陷阱不用愁；混合输入 scanf 强，但要记得跳空格！”  \n","tags":["C Language"]},{"title":"第六章——字符型数据 第五节——字符串常量的定义及其与字符型常量的区别","url":"/Blog/posts/df98f5f9/","content":"一、字符串常量的定义1.1 基本概念字符串常量是用双引号括起来的一串字符，系统会自动在字符串末尾添加结束符 &#39;\\0&#39;，作为字符串的终止标志。例如：  \n&quot;Hello World&quot;  &quot;123&quot;  &quot;C&quot;  &quot;&quot;  // 合法字符串常量  \n核心规则：  \n\n结束符：字符串常量的存储包含 &#39;\\0&#39;（占1字节），实际占用内存大小为字符数加1 。  \n空字符串：&quot;&quot; 是合法的字符串常量，仅包含 &#39;\\0&#39;，占用1字节内存 。\n\n1.2 真题实战：内存占用计算题目：  \nchar a[7] = &quot;a0\\0a0\\0&quot;;  int i = sizeof(a);  int j = strlen(a);  printf(&quot;%d %d&quot;, i, j);  \n答案：7 2解析：  \n\nsizeof(a) 返回数组总大小（7字节），包含所有字符和 &#39;\\0&#39;。  \nstrlen(a) 遇到第一个 &#39;\\0&#39; 终止，仅计算前2个字符 。\n\n\n二、字符串常量 vs 字符型常量2.1 核心区别对比\n\n\n特性\n字符型常量\n字符串常量\n\n\n\n引号类型\n单引号 &#39; &#39;\n双引号 &quot; &quot;\n\n\n内容容量\n仅限单字符\n可含多字符及 &#39;\\0&#39; 结束符\n\n\n内存占用\n1 字节\n字符数 + 1 字节（&#39;\\0&#39;）\n\n\n存储方式\n直接存储 ASCII 码值\n存储字符序列及结束符 &#39;\\0&#39;\n\n\n2.2 常见错误与修复\n\n\n错误类型\n错误示例\n修复方法\n\n\n\n混淆单双引号\nchar ch = &quot;A&quot;;\n改为单引号：char ch = &#39;A&#39;;\n\n\n多字符赋值给 char\nchar ch = &#39;ab&#39;;\n改用字符数组：char str[] = &quot;ab&quot;;\n\n\n忽略 &#39;\\0&#39; 的影响\nchar str[3] = &quot;abc&quot;;\n扩大数组长度：char str[4] = &quot;abc&quot;;\n\n\n\n三、字符串处理函数的应用3.1 常用函数及功能\nstrlen：计算字符串实际长度（不包含 &#39;\\0&#39;）。  \nchar str[] = &quot;Hello&quot;;  printf(&quot;%d&quot;, strlen(str));  // 输出 5   \nstrcpy：拷贝字符串（自动包含 &#39;\\0&#39;）。  \nchar dest[10], src[] = &quot;C++&quot;;  strcpy(dest, src);  // dest 内容为 &quot;C++\\0&quot;   \nstrcat：拼接字符串（覆盖目标字符串的 &#39;\\0&#39;）。  \nchar dest[20] = &quot;Turbo&quot;;  strcat(dest, &quot; C++&quot;);  // dest 内容为 &quot;Turbo C++\\0&quot;   \n\n3.2 真题解析：字符串比较与赋值题目：  \nchar *s1 = &quot;OK&quot;, *s2 = &quot;ok&quot;;  if (strcmp(s1, s2) != 0)      puts(s1);  \n输出：OK解析：strcmp 按 ASCII 码逐个比较字符，区分大小写，&quot;OK&quot; 与 &quot;ok&quot; 不同 。  \n\n四、调试与实践技巧4.1 使用 sizeof 和 strlen 的陷阱\nsizeof：返回数组总大小（包含 &#39;\\0&#39;）。  \nstrlen：遇到 &#39;\\0&#39; 终止，仅计算有效字符数。\n\nchar str[] = &quot;\\t\\v\\\\\\0will\\n&quot;;  printf(&quot;Sizeof: %d, Strlen: %d&quot;, sizeof(str), strlen(str));  // 输出：Sizeof: 9, Strlen: 3   \n\n4.2 输入输出函数的选择\nscanf + %s：读取不含空格的字符串。  \ngets：可读取含空格的整行输入（需注意缓冲区溢出风险）。  \nputs：输出字符串并自动换行。\n\nchar str[80];  printf(&quot;Input a string: &quot;);  gets(str);  // 输入 &quot;How are you?&quot;  puts(str);  // 输出 &quot;How are you?&quot; 并换行   \n\n\n五、总结：字符串常量的核心法则\n双引号包裹：字符串常量必须用双引号，末尾自动添加 &#39;\\0&#39;。  \n内存分配：字符数组大小需至少为字符串长度加1（含 &#39;\\0&#39;）。  \n函数依赖：字符串操作依赖库函数（如 strlen, strcpy），不能直接赋值或比较 。\n\n🎯 记忆口诀：“双引号串单引号符，字符串尾藏 \\0；字符数组存文本，库函操作避错误！”  \n\n后记&emsp;&emsp;C语言中没有专门存放字符串的字符串变量，字符串如果要放在变量中，必须用字符数组（char[]）来存储。为了方便区分字符串常量和字符数组，有如下示例：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123;    // ===== 字符串常量示例 =====    // 字符串常量：存储在只读内存中的固定字符串    // 以下两种写法等效    char *strConst1 = &quot;Hello&quot;;         // 不可修改内容，指向只读内存的指针    const char strConst2[] = &quot;World&quot;;  // 数组形式的常量字符串（内容不可修改）        // 尝试修改字符串常量会导致未定义行为    // strConst1[0] = &#x27;h&#x27;;  // 不建议取消注释此行        // ===== 字符数组示例 =====    // 可变的字符串存储方式    char strArray1[20] = &quot;Hello&quot;;  // 明确指定大小    char strArray2[] = &quot;World&quot;;    // 自动计算大小        // 修改字符数组内容是合法的    strArray1[0] = &#x27;h&#x27;;  // 合法操作    strArray2[0] = &#x27;w&#x27;;          // 输出结果    printf(&quot;字符串常量示例:\\n&quot;);    printf(&quot;strConst1: %s\\n&quot;, strConst1);    printf(&quot;strConst2: %s\\n\\n&quot;, strConst2);        printf(&quot;字符数组示例:\\n&quot;);    printf(&quot;修改后 strArray1: %s\\n&quot;, strArray1);    printf(&quot;修改后 strArray2: %s\\n&quot;, strArray2);        // ===== 常见操作对比 =====    // 字符串拼接：目标必须是可修改的字符数组    char dest[50] = &quot;Hello&quot;;    strcat(dest, &quot; World&quot;);  // 合法    // strcat(strConst1, &quot;!&quot;);  // 非法 - 不要取消注释        // 字符串复制    char dest2[50];    strcpy(dest2, strConst1);  // 合法        return 0;&#125;","tags":["C Language"]},{"title":"第六章——字符型数据 第四节——字符型变量的定义","url":"/Blog/posts/2b7d2eb0/","content":"一、定义与内存布局：用 char 存储世界的符号1.1 基本语法字符型变量通过 char 关键字定义，用于存储单个字符（如字母、数字、符号），其本质是 ASCII 码值的整型表示。  \nchar ch1 = &#39;A&#39;;    // 合法：单引号包裹单字符  \nchar ch2 = 97;     // 合法：直接赋 ASCII 码值（对应 &#39;a&#39;）  \nchar ch3 = &#39;ab&#39;;   // 非法：单引号内仅允许一个字符  \n\n1.2 内存占用与编码规则\n内存占用：每个 char 变量固定占用 1 字节（8 位），可表示 0-255 的数值范围，在此范围内，字符型变量与整型变量可以通用。  \nASCII 码映射：字符变量的值为其 ASCII 码（如 &#39;A&#39; 对应 65，&#39;0&#39; 对应 48）。\n\n\n二、赋值与初始化：从键盘到内存的旅程2.1 直接赋值与转义字符\n单字符赋值：  char ch = &#39;Z&#39;;  // ASCII 码 90  \n\n\n转义字符赋值：  char newline = &#39;\\n&#39;;  // 换行符  \nchar bell = &#39;\\x07&#39;;   // 十六进制转义（ASCII 7，响铃）  \n\n\n\n2.2 输入输出操作\nscanf 与 printf：  char ch;  \nscanf(&quot;%c&quot;, &amp;ch);       // 输入时需注意空格、换行符会被读取  \nprintf(&quot;字符：%c，ASCII 码：%d\\n&quot;, ch, ch);  \n\n\ngetchar 与 putchar：  ch = getchar();         // 读取单个字符（含空格）  \nputchar(ch);            // 输出字符  \n\n\n\n\n三、运算与转换：字符与整数的“双面人生”3.1 字符变量的整型特性字符变量可直接参与整数运算（如加减、比较），因其本质是 ASCII 码值。  \nchar ch = &#39;A&#39; + 3;        // 结果为 &#39;D&#39;（ASCII 68）  \nif (ch &gt; &#39;a&#39;) {           // 判断字符是否为大写  \n    ch += 32;             // 转换为小写（ASCII 码加 32）  \n}  \n\n3.2 大小写转换的魔法公式\n大写转小写：  ch = ch + 32;           // 或 ch += &#39;a&#39; - &#39;A&#39;;  \n\n\n小写转大写：  ch = ch - 32;           // 或 ch -= &#39;a&#39; - &#39;A&#39;;  \n\n\n\n\n四、常见错误与避坑指南4.1 典型陷阱与修复方法\n\n\n错误类型\n错误示例\n修复方法\n\n\n\n多字符赋值\nchar ch = &#39;ab&#39;;\n改用字符数组：char str[] = &quot;ab&quot;;\n\n\n混淆单双引号\nchar ch = &quot;A&quot;;\n改为单引号：char ch = &#39;A&#39;;\n\n\n忽略空格输入\nscanf(&quot;%c&quot;, &amp;ch) 输入 &#39; &#39;\n使用 getchar() 或 scanf(&quot; %c&quot;, &amp;ch)（注意空格）\n\n\n4.2 真题实战：字符运算的边界问题题目：以下代码的输出是？  \nchar ch = &#39;Z&#39;;  \nch += 32;  \nprintf(&quot;%c&quot;, ch);  \n\n答案：z（&#39;Z&#39; 的 ASCII 码 90，加 32 得 122，对应 &#39;z&#39;）  \n\n五、字符变量与字符串：单兵与军团的区别5.1 核心差异对比\n\n\n特性\n字符变量 (char)\n字符串 (char[])\n\n\n\n存储内容\n单个字符\n多个字符（含 \\0 结束符）\n\n\n内存占用\n1 字节\n字符数 + 1 字节（\\0）\n\n\n初始化方式\nchar ch = &#39;A&#39;;\nchar str[] = &quot;Hello&quot;;\n\n\n5.2 字符串的底层实现字符串本质是字符数组，需以 \\0 结尾。例如：  \nchar str[] = &quot;C&quot;;     // 合法：隐含 `\\0`  \nchar str[] = {&#39;C&#39;};   // 非法：缺少 `\\0`，无法作为字符串处理  \n\n\n六、总结：字符变量的三大法则\n单引号规则：字符变量必须用单引号包裹，且仅能包含一个字符。  \n整型本质：字符变量的本质是 ASCII 码值，可参与整数运算。  \n字符串基石：字符数组是构建字符串的基础，需以 \\0 结尾。\n\n🎯 记忆口诀：“单引号赋值，1字节存；运算自如，别忘转义！字符串靠数组，\\0 结尾不能漏。”  \n","tags":["C Language"]},{"title":"第六章——字符型数据 第六节——调用printf和scanf进行输入输出","url":"/Blog/posts/30d7d9e/","content":"一、基本概念：字符的输入输出规则1.1 printf 和 scanf 的语法\n使用前提： 必须调用  #include &lt;stdio.h&gt; \n\n输出字符：使用 printf 函数，格式说明符为 %c。  \nchar ch = &#x27;A&#x27;;  printf(&quot;字符：%c\\n&quot;, ch);  // 输出：字符：A  \n输入字符：使用 scanf 函数，格式说明符为 %c。  \nchar ch;  scanf(&quot;%c&quot;, &amp;ch);  // 注意取地址符 &amp;  \n\n1.2 宽度控制与格式化\nprintf 可通过整数指定输出宽度：  \nprintf(&quot;字符：%5c\\n&quot;, &#x27;B&#x27;);  // 输出右对齐，占5列：字符：    B  \n\n\n二、输入陷阱与避坑指南2.1 空白字符的处理问题\n连续 %c 输入：scanf(&quot;%c%c%c&quot;, &amp;a, &amp;b, &amp;c) 会将空格、换行符视为有效字符。  \n正确输入：ABC（无空格）  \n错误输入：A B C（空格会被读入 b 和 c）。\n\n\n交叉输入数值与字符：  int a1; char c1;  scanf(&quot;%d%c&quot;, &amp;a1, &amp;c1);  // 输入 &quot;10A&quot; 合法，但 &quot;10 A&quot; 会导致 c1 读取空格  \n\n2.2 真题实战：输入格式陷阱题目：以下哪种输入形式能正确为变量 a1=10, a2=20, c1=&#39;X&#39;, c2=&#39;Y&#39; 赋值？  \nscanf(&quot;%d%c%d%c&quot;, &amp;a1, &amp;c1, &amp;a2, &amp;c2);  \n选项：A. 10□X □20 □YB. 10 □X20 □YC. 10 □X＜回车＞ 20 □YD. 10X＜回车＞ 20Y  \n答案：D解析：选项 D 中输入 10X 和 20Y 无多余空格，避免了 scanf 误读空白字符 。  \n\n三、进阶应用：字符与数值的混合输入3.1 数值与字符的顺序冲突\n问题：当 scanf 中交替出现数值和字符变量时，数值输入后的换行符可能被字符变量误读。  int a; char c;  printf(&quot;输入数值：&quot;); scanf(&quot;%d&quot;, &amp;a);  printf(&quot;输入字符：&quot;); scanf(&quot;%c&quot;, &amp;c);  // 此处会直接读取上一行的换行符！  \n修复方法：在 scanf 前添加空格跳过空白：  scanf(&quot; %c&quot;, &amp;c);  // 注意格式字符串前的空格  \n\n3.2 调试技巧：打印变量验证char ch;  scanf(&quot;%c&quot;, &amp;ch);  printf(&quot;读取的字符：%c，ASCII 码：%d\\n&quot;, ch, ch);  \n输出示例：输入 &#39; &#39;（空格），输出：字符： ，ASCII 码：32  \n\n四、对比分析：scanf/printf vs getchar/putchar\n\n\n特性\nscanf/printf\ngetchar/putchar\n\n\n\n适用场景\n格式化输入输出（含混合数据）\n单字符输入输出\n\n\n空白处理\n需手动跳过（如 &quot; %c&quot;）\n直接读取所有字符（含空格）\n\n\n效率\n适合复杂格式，稍慢\n单字符操作，效率更高\n\n\n示例对比：  \n// 使用 scanf/printf  char ch;  scanf(&quot;%c&quot;, &amp;ch);  printf(&quot;字符：%c\\n&quot;, ch);  // 使用 getchar/putchar  ch = getchar();  putchar(ch);  putchar(&#x27;\\n&#x27;);  \n\n\n五、总结：字符输入输出的核心法则\n格式严格：scanf 的 %c 会读取所有字符，包括空格和换行符。  \n缓冲区陷阱：数值输入后需清除残留换行符，避免干扰后续字符输入。  \n宽度控制：printf 可通过 %5c 等格式调整输出对齐方式。\n\n🎯 记忆口诀：“字符输入 %c 精，空白陷阱需小心；数值字符混输入，空格跳过保太平！”  \n","tags":["C Language"]},{"title":"第四章——选择结构 第三节——条件表达式及其构成的选择结构","url":"/Blog/posts/f5ae6e3a/","content":"条件运算符&emsp;&emsp;C语言中的条件运算符（也称为三目运算符）是C语言中唯一的三目运算符，用于简化简单的条件判断逻辑。它通过一个表达式来替代简单的 if-else 语句，使代码更简洁。以下是对其详细介绍：\n\n1. 语法格式条件运算符的语法形式为：\n条件表达式 ? 表达式1 : 表达式2\n\n条件表达式：一个布尔表达式（返回值为真或假）。\n如果为真（非0），则计算并返回 表达式1 的值。\n如果为假（0），则计算并返回 表达式2 的值。\n\n\n\n\n2. 使用示例基本用法比较两个数的大小：\n#include &lt;stdio.h&gt;int main() &#123;    int a = 10, b = 20;    int max = (a &gt; b) ? a : b; // 如果a &gt; b为真，max=a；否则max=b    printf(&quot;最大值是: %d\\n&quot;, max); // 输出：最大值是: 20    return 0;&#125;\n\n嵌套条件运算符处理多个条件判断（例如找三个数的最大值）：\n#include &lt;stdio.h&gt;int main() &#123;    int a = 10, b = 20, c = 30;    int max = (a &gt; b) ? ((a &gt; c) ? a : c) : ((b &gt; c) ? b : c);    printf(&quot;最大值是: %d\\n&quot;, max); // 输出：最大值是: 30    return 0;&#125;\n\n判断奇偶性#include &lt;stdio.h&gt;int main() &#123;    int num = 10;    printf(&quot;%d 是 %s\\n&quot;, num, (num % 2 == 0) ? &quot;even&quot; : &quot;odd&quot;); // 输出：10 是 even    return 0;&#125;\n\n\n3. 注意事项(1) 优先级与结合性\n优先级：条件运算符的优先级低于关系运算符（如 &gt;, &lt;）和算术运算符，但高于赋值运算符（=）。因此，通常需要显式使用括号以避免逻辑错误。\n示例：int x = 3 + a &gt; 5 ? 100 : 200; // 等价于 x = ((3 + a) &gt; 5) ? 100 : 200;\n\n\n结合性：条件运算符具有右结合性，即多个条件运算符连续出现时，从右向左结合。\n示例：a &gt; b ? a : c &gt; d ? c : d; // 等价于 a &gt; b ? a : (c &gt; d ? c : d);\n\n\n\n(2) 类型兼容性\n表达式1和表达式2的类型应兼容。如果类型不同，结果会以更高的类型为准（隐式类型转换）。\n示例：int x = 5;int y = 10;double result = (x &gt; y) ? 1 : 1.5; // 返回1.5（double类型）\n\n\n\n(3) 可读性问题\n过度嵌套：虽然条件运算符可以嵌套使用，但过多嵌套会降低代码可读性。建议嵌套不超过两层。\n示例（不推荐）：condition1 ? (condition2 ? expr1 : expr2) : (condition3 ? expr3 : expr4);\n替代方案（推荐）：if (condition1) &#123;    if (condition2) &#123;        expr1;    &#125; else &#123;        expr2;    &#125;&#125; else &#123;    if (condition3) &#123;        expr3;    &#125; else &#123;        expr4;    &#125;&#125;\n\n\n\n\n4. 与 if-else 的比较\n\n\n条件运算符\nif-else 语句\n\n\n\n适用于简单条件判断和赋值\n适用于复杂逻辑和多分支\n\n\n代码更简洁\n逻辑更清晰，可读性更高\n\n\n不适合执行多个语句\n可执行多个语句块\n\n\n示例对比\n条件运算符：max = (a &gt; b) ? a : b;\nif-else：if (a &gt; b) &#123;    max = a;&#125; else &#123;    max = b;&#125;\n\n\n5. 适用场景\n简单赋值：当需要根据条件给变量赋值时（如取最大值、最小值）。\n表达式嵌套：在复杂表达式中嵌入条件判断（如 printf 中的动态输出）。\n代码简洁性：在逻辑简单且需要减少代码行数时使用。\n\n\n总结条件运算符是C语言中一个高效且实用的工具，尤其适合处理简单的条件判断和赋值操作。然而，对于复杂逻辑或需要执行多个语句的场景，建议优先使用 if-else 结构以确保代码的可读性和可维护性。合理使用条件运算符，可以使代码更加简洁高效！\n","tags":["C Language"]},{"title":"第六章——字符型数据 第零节——前言","url":"/Blog/posts/e89b5a91/","content":"第六章 字符之道——掌控文字的炼金术核心能力修炼：参悟字符三重境界通过本章修炼，你将获得：\n\n破解字符常量的”暗码玄机”\n掌握字符变量的”阴阳转化”之术\n驯服字符串函数的”十八般武艺”\n领悟输入输出的”文字搬运心法”\n参透常见陷阱的”破局之眼”\n\n知识脉络一、字符玄机\n字符常量：ASCII江湖中的神秘暗号（’A’的16进制密码）\n转义字符：反斜杠统领的特殊军团（\\n换行令旗、\\t空格飞梭）\n字符运算：字符与整数的隐秘交易（’9’ - ‘0’的数字解码术）\n\n二、字符串秘境\n字符串定义：字符数组的列阵之法（末尾\\0的隐形守卫）\n处理函数：\nstrlen：丈量字符串的游标卡尺\nstrcpy：字符串搬运的乾坤大挪移\nstrcat：字符串融合的太极推手\nstrcmp：字符较量的华山论剑\n\n\n常见误区：\n字符与字符串的”一字之差”\nsizeof与strlen的”时空迷局”\n数组越界的”无间地狱”\n\n\n\n三、输入输出要诀\n单字符操作：getchar&#x2F;putchar的闪电战法\n字符串操作：gets&#x2F;puts的阵地攻坚战\n格式化输入：scanf的字符过滤罗网\n\n修炼心法&emsp;&emsp;建议用”内存视角”观察字符存储，重点参悟字符串结束符\\0的隐形法则。特别注意字符数组越界的”雪崩效应”，善用调试器观察内存布局。警惕scanf读取字符串时的空格陷阱，掌握缓冲区清理的”回车清除术”。\n","categories":["C_Language","第六章——字符型数据"],"tags":["C Language"]},{"title":"第四章——选择结构 第二节——逻辑运算","url":"/Blog/posts/ae06b0ca/","content":"逻辑运算&emsp;&emsp;在之前的关系表达式中，只能描述单一条件，那如何描述a条件同时b条件之类的呢？此处就要用到逻辑表达式。\n逻辑运算符种类\n\n\n符号\n名称\n功能描述\n示例\n\n\n\n&amp;&amp;\n逻辑与\n当两个操作数都为真时，结果才为真；否则为假\nint a = 5, b = 10; if(a &gt; 0 &amp;&amp; b &gt; 0)\n\n\n||\n逻辑或\n当两个操作数中至少一个为真时，结果为真；都为假时才为假\nint x = 3, y = -1; if(x != 0 || y != 0)\n\n\n!\n逻辑非（取反）\n单目运算符，将其操作数的真假值取反：真变假，假变真\nint flag = 0; if(!flag)\n\n\n\n💡 在C语言中，任何非0值都被视为“真”（true），而只有 0 被视为“假”（false）。\nint a = 5;if(a) &#123;    // 会执行，因为5是非0值&#125;\n关于if(a)，此处的判断条件是a是否是非0值。\n\n逻辑运算真值表\n\n\na\nb\n!a\n!b\na &amp;&amp; b\na || b\n\n\n\n假\n假\n真\n真\n假\n假\n\n\n假\n真\n真\n假\n假\n真\n\n\n真\n假\n假\n真\n假\n真\n\n\n真\n真\n假\n假\n真\n真\n\n\n逻辑运算符的优先级&emsp;&emsp;在C语言中，！、&amp;&amp;，||的优先级依次降低。\n示例：优先级的影响// 优先级最高：逻辑非!int a = 1, b = 0;if (!a &amp;&amp; b) &#123;    // 等价于 (!a) &amp;&amp; b    // 先计算 !a=0，再 0 &amp;&amp; 0 → 0，不执行&#125;// 优先级其次：逻辑与&amp;&amp;int x = 1, y = 0;if (x &amp;&amp; y || 1) &#123;    // 先计算 x &amp;&amp; y → 0，再 0 || 1 → 1，执行&#125;// 优先级最低：逻辑或||int m = 0, n = 1;if (m || n &amp;&amp; !m) &#123;    // 先计算 n &amp;&amp; !m → 1 &amp;&amp; 1 → 1，再 m || 1 → 1，执行&#125;\n\n\n\n\n逻辑运算符\n优先级\n示例说明\n\n\n\n!\n最高\n!a &amp;&amp; b 先计算 \\!a 再计算 &amp;&amp;\n\n\n&amp;&amp;\n其次\na &amp;&amp; b || c 先计算 &amp;&amp; 再计算 ||\n\n\n||\n最低\na || b &amp;&amp; c 先计算 b &amp;&amp; c 再计算 ||\n\n\n逻辑运算符的结合方向示例：结合方向的影响// 从右向左结合：逻辑非!int flag = 0;if (!flag &amp;&amp; 5) &#123;    // 等价于 (!flag) &amp;&amp; 5 → 1 &amp;&amp; 1 → 执行&#125;// 从左向右结合：逻辑与&amp;&amp;int a = 1, b = 1, c = 0;if (a &amp;&amp; b &amp;&amp; c) &#123;    // 等价于 ((a &amp;&amp; b) &amp;&amp; c) → (1 &amp;&amp; 1) &amp;&amp; 0 → 0，不执行&#125;// 从左向右结合：逻辑或||int x = 0, y = 1, z = 0;if (x || y || z) &#123;    // 等价于 ((x || y) || z) → (0 || 1) || 0 → 1，执行&#125;\n\n\n\n\n逻辑运算符\n结合方向\n示例说明\n\n\n\n!\n从右向左\n!flag &amp;&amp; x 等价于 (!flag) &amp;&amp; x\n\n\n&amp;&amp;\n从左向右\na &amp;&amp; b &amp;&amp; c 等价于 (a &amp;&amp; b) &amp;&amp; c\n\n\n||\n从左向右\nx || y || z 等价于 (x || y) || z\n\n\n\n短路特性：&emsp;&emsp;短路特性（Short-circuit Evaluation）是逻辑运算符（&amp;&amp; 和 ||）在C语言中的行为规则：&emsp;&emsp;当逻辑运算的结果已经可以确定时，跳过后续操作数的计算。这种机制提高了程序效率，并能避免潜在错误。\n\n1. 短路特性的工作原理(1) 逻辑与（&amp;&amp;）\n规则：  \n如果第一个操作数为假（0），整个表达式的结果必为假，跳过第二个操作数的计算。\n\n\n真值表：\n\n\na\nb\na &amp;&amp; b\n\n\n\n0\n任意\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n(2) 逻辑或（||）\n规则：  \n如果第一个操作数为真（非0），整个表达式的结果必为真，跳过第二个操作数的计算。\n\n\n真值表：| a    | b    | a || b ||——|——|——–|| 1    | 任意 | 1      || 0    | 0    | 0      || 0    | 1    | 1      |\n\n\n2. 短路特性的应用场景(1) 避免运行时错误空指针检查#include &lt;stdio.h&gt;void process(int *ptr) &#123;    if (ptr &amp;&amp; *ptr &gt; 0) &#123;  // 先检查 ptr 是否为 NULL        printf(&quot;值为 %d\\n&quot;, *ptr);    &#125; else &#123;        printf(&quot;指针为空或值无效\\n&quot;);    &#125;&#125;int main() &#123;    int *p = NULL;    process(p);  // 输出：指针为空或值无效    return 0;&#125;\n\n原理：ptr &amp;&amp; *ptr &gt; 0 中，如果 ptr 为 NULL，&amp;&amp; 会短路，跳过 *ptr 的解引用，避免崩溃。\n\n避免除零#include &lt;stdio.h&gt;int main() &#123;    int a = 5;    int b = 0;        if (b != 0 &amp;&amp; a / b &gt; 1) &#123;  // 如果 b 为 0，直接跳过除法        printf(&quot;结果有效\\n&quot;);    &#125; else &#123;        printf(&quot;除数不能为 0\\n&quot;);  // 输出：除数不能为 0    &#125;        return 0;&#125;\n\n(2) 优化性能#include &lt;stdio.h&gt;#include &lt;time.h&gt;int expensive_check() &#123;    // 模拟耗时计算    for (int i = 0; i &lt; 100000000; ++i);    return 0;  // 返回 false&#125;int main() &#123;    clock_t start = clock();        if (0 &amp;&amp; expensive_check()) &#123;  // 短路跳过 expensive_check()        // ...    &#125;        double duration = (double)(clock() - start) / CLOCKS_PER_SEC;    printf(&quot;耗时: %.6f 秒\\n&quot;, duration);  // 耗时极低    return 0;&#125;\n\n(3) 默认值赋值#include &lt;stdio.h&gt;int main() &#123;    int *ptr = NULL;    int value = (ptr != NULL) ? *ptr : 0;  // 安全获取值    printf(&quot;value = %d\\n&quot;, value);  // 输出：0    return 0;&#125;\n\n\n4. 短路特性的注意事项(1) 条件顺序的重要性\n逻辑与（&amp;&amp;）：将更可能为 假 的条件放在左侧。\nif (is_valid &amp;&amp; is_ready) &#123; ... &#125;  // 如果 is_valid 为假，直接跳过 is_ready\n\n逻辑或（||）：将更可能为 真 的条件放在左侧。\nif (is_cached || fetch_from_database()) &#123; ... &#125;  // 如果缓存存在，直接跳过数据库查询\n\n(2) 副作用的影响int i = 0;int result = (i++ &gt; 0) &amp;&amp; (i++ &gt; 1);  // i 最终为 1printf(&quot;%d&quot;, i);  // 输出 1\n\n解释：i++ &gt; 0 为假，i++ &gt; 1 不会被执行，因此 i 只自增一次。\n\n(3) 优先级问题if (a || b &amp;&amp; c) &#123; ... &#125;  // 等价于 if (a || (b &amp;&amp; c))\n\n建议：使用括号明确优先级：if ((a || b) &amp;&amp; c) &#123; ... &#125;\n\n\n5. C语言与其他语言的差异\n\n\n语言\n逻辑与\n逻辑或\n特性说明\n\n\n\nC\n&amp;&amp;\n&#96;\n\n\n\nPython\nand\nor\n返回实际值（非布尔值）\n\n\nJavaScript\n&amp;&amp;\n&#96;\n\n\n\nC++\n&amp;&amp;\n&#96;\n\n\n\n\n6. 总结优点\n提高性能：跳过不必要的计算。\n防止错误：避免空指针、除零等运行时异常。\n简化代码：如默认值赋值（value = a || b）。\n\n潜在问题\n副作用：依赖短路跳过的表达式可能导致逻辑错误。\n可读性：复杂条件可能导致代码难以理解。\n\n最佳实践\n显式括号：明确逻辑运算的优先级。\n避免副作用：不依赖短路跳过的表达式中的副作用。\n条件顺序优化：将更可能触发短路的条件放在左侧。\n\n\n位运算符按位异或运算符运算符种类\n\n\n符号\n名称\n功能描述\n示例\n\n\n\n&amp;\n按位与\n对两个操作数的每一位执行逻辑000与操作\nint a = 5 &amp; 3; // 1\n\n\n|\n按位或\n对两个操作数的每一位执行逻辑或操作\nint b = 5 | 3; // 7\n\n\n^\n按位异或\n当两个操作数的对应位不同时为1，相同时为0\nint c = 5 ^ 3; // 6\n\n\n~\n按位取反\n单目运算符，将操作数的每一位取反\nint d = ~5; // 依赖于系统位数\n\n\n&lt;&lt;\n左移\n将操作数的二进制位向左移动指定的位数\nint e = 5 &lt;&lt; 1; // 10\n\n\n&gt;&gt;\n右移\n将操作数的二进制位向右移动指定的位数\nint f = 5 &gt;&gt; 1; // 2\n\n\n按位异或特性// 交换两个变量的值（不使用临时变量）int a = 10, b = 20;a = a ^ b;  // a becomes 26 (11010)b = a ^ b;  // b becomes 10 (1010)a = a ^ b;  // a becomes 20 (10100)\n\n典型应用场景\n数据加密：使用异或进行简单加密\n\nchar data = &#x27;A&#x27;;char key = &#x27;K&#x27;;data = data ^ key;  // 加密// 重复异或操作可解密data = data ^ key;  // 恢复为&#x27;A&#x27;\n\n\n位掩码操作\n\n// 提取第3位和第1位（从0开始计数）int flags = 0b101010;int mask = 0b1010;  // 二进制掩码int result = flags &amp; mask;  // 保留指定位置\n\n注意事项\n逻辑运算 vs 位运算：\n&amp;&amp; 和 || 返回布尔值（0或1）\n&amp; 和 | 返回整数值\n\n\n移位陷阱：int x = -1;int y = x &gt;&gt; 1;  // 取决于系统实现（算术右移或逻辑右移）\n结合性问题：int a = 5 ^ 3 &amp; 0x0F;  // 等价于 5 ^ (3 &amp; 0x0F) 因为&amp;优先级高于^\n\n","tags":["C Language"]},{"title":"第四章——选择结构 第一节——关系运算","url":"/Blog/posts/ee89cbc6/","content":"逻辑值&emsp;&emsp;在C语言中，逻辑值是表示条件判断结果的基本数据类型，其本质是整型数值：\n核心概念\n传统表示：\n\n逻辑真：任意非0整数（如1, -1, 2等）\n逻辑假：0\n\n\nC99标准扩展：\n\n使用bool类型（需包含&lt;stdbool.h&gt;）\n特殊常量：true（等价1）和false（等价0）\n\n\n\n简单示例#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int main() &#123;    bool flag = true; // 布尔值赋值    if (flag) &#123;       // 非0值触发条件        printf(&quot;条件成立\\n&quot;);    &#125;    return 0;&#125;\n\n\n关系运算&emsp;&emsp;在C语言中，关系运算（也称为比较运算）用于比较两个数据的大小或相等性，其结果为逻辑值（0或非0）。\n1. 关系运算符&emsp;&emsp;C语言提供了6种关系运算符：\n\n\n\n运算符\n含义\n示例\n说明\n\n\n\n&lt;\n小于\na &lt; b\n如果 a 小于 b，结果为1（真），否则为0（假）\n\n\n&lt;=\n小于等于\na &lt;= b\n如果 a 小于等于 b，结果为1，否则为0\n\n\n&gt;\n大于\na &gt; b\n如果 a 大于 b，结果为1，否则为0\n\n\n&gt;=\n大于等于\na &gt;= b\n如果 a 大于等于 b，结果为1，否则为0\n\n\n==\n等于\na == b\n如果 a 等于 b，结果为1，否则为0\n\n\n!=\n不等于\na != b\n如果 a 不等于 b，结果为1，否则为0\n\n\n\n⚠️ 注意：\n\n== 用于判断相等性，而 = 是赋值运算符，两者容易混淆（如 if (a = 5) 会将 a 赋值为5，而非比较）\n浮点数（如 float、double）的比较需谨慎，直接使用 == 可能因精度问题导致错误，建议使用范围比较（如 fabs(a - b) &lt; 1e-6）\n\n\n\n2. 优先级\n关系运算符之间的优先级：\n\n前4个运算符（&lt;、&lt;=、&gt;、&gt;=）的优先级相同。\n后2个运算符（==、!=）的优先级相同。\n前4个运算符的优先级高于后2个运算符。\n\n\n与其他运算符的优先级：\n\n低于算术运算符（如 +、*）。\n高于赋值运算符（如 =）。\n低于逻辑运算符（如 &amp;&amp;、||）。\n\n\n\n示例：\nint a = 3, b = 4;int result1 = a + b &gt; 5;     // 等价于 (a + b) &gt; 5 → (7 &gt; 5) → 1int result2 = a == b + 1;    // 等价于 a == (b + 1) → 3 == 5 → 0\n\n\n3. 关系表达式&emsp;&emsp;关系表达式是通过关系运算符将两个表达式连接起来的表达式，其值为逻辑值（0或1）。\n示例：\n#include &lt;stdio.h&gt;int main() &#123;    int a = 5, b = 3;    int result = (a &gt; b);  // 比较 a 和 b 的大小    printf(&quot;%d\\n&quot;, result); // 输出 1（真）    return 0;&#125;\n\n复杂表达式：\nint num1 = 3, num2 = 4, num3 = 5;// 表达式 (num1 &gt; num2) 的值为 0（假）// 表达式 (num1 &lt; num2 &lt; num3) 的值为 1（真）// 表达式 (num1 &lt; num2) + num3 的值为 6（1 + 5）\n\n\n4. 注意事项\n避免浮点数的直接比较：\nfloat a = 1.0 / 3.0 * 3.0;if (a == 1.0) &#123; ... &#125; // 可能因精度问题导致错误// 推荐使用范围比较：if (fabs(a - 1.0) &lt; 1e-6) &#123; ... &#125;\n\n逻辑值的隐式转换：\n\nC语言中没有布尔类型（C99之前），所有非0值均视为真，0视为假。\n关系表达式的结果为0或1（逻辑假或逻辑真）。\n\n\n避免链式比较：\nint a = 0, b = 0.5, x = 0.3;int result = a &lt;= x &lt;= b; // 结果为 0（错误！）// 正确写法应为：(a &lt;= x) &amp;&amp; (x &lt;= b)\n\n常见错误：\n\n错误使用 = 而非 ==：if (a = 5) &#123; ... &#125; // 实际是赋值，而非比较\n\n\n\n\n总结\n关系运算符用于比较两个值的大小或相等性，结果为逻辑值（0或1）。\n优先级规则需特别注意，避免因优先级错误导致逻辑错误。\n关系表达式可描述单一条件，但无法直接组合多个条件（需结合逻辑运算符）。\n避免常见错误：浮点数比较、链式比较、混淆 = 和 ==。\n\n","tags":["C Language"]},{"title":"第四章——选择结构 第五节——if语句及其拓展","url":"/Blog/posts/3281fff4/","content":"1. 什么是if语句？&emsp;&emsp;简单来说，if语句就是程序里的“判断开关”。你可以把它想象成生活中的选择题：  \n\n如果某个条件成立（比如“你成绩优秀”），就执行某个操作（比如“发奖学金”）。  \n如果条件不成立（比如“成绩不及格”），就执行另一个操作（比如“补考”）。\n\n&emsp;&emsp;在C语言里，if语句就是用来让程序根据条件决定“下一步该干嘛”的。\n\n2. 最基础的if语句语法：  \nif (条件) &#123;    // 条件成立时执行的代码&#125;\n举个栗子🌰：  \nint age = 18;if (age &gt;= 18) &#123;    printf(&quot;你可以投票了！\\n&quot;);&#125;\n\n如果age大于等于18，就输出“你可以投票了！”；否则，啥也不干。\n\n注意⚠️：  \n\n条件写在()里，结果为“真”（非0）或“假”（0）。  \n如果只有一行代码，可以省略大括号{}，但建议还是加上，避免出错。\n\n\n3. 加上else的“二选一”&emsp;&emsp;有时候需要“如果A成立，做X；否则，做Y”。这时候就要用if-else：  \nif (条件) &#123;    // 条件成立时执行&#125; else &#123;    // 条件不成立时执行&#125;\n例子：  \nint score = 85;if (score &gt;= 60) &#123;    printf(&quot;恭喜及格！\\n&quot;);&#125; else &#123;    printf(&quot;需要补考哦。\\n&quot;);&#125;\n\n如果score大于等于60，输出“恭喜及格！”；否则输出“需要补考哦。”\n\n注意⚠️：  \n\nelse必须和最近的if配对。如果嵌套太深，容易出错，建议用大括号明确结构。\n\n\n4. 多条件分支：else if的“多选一”&emsp;&emsp;当有多个条件需要判断时，可以用else if：  \nif (条件1) &#123;    // 条件1成立时执行&#125; else if (条件2) &#123;    // 条件2成立时执行&#125; else &#123;    // 所有条件都不成立时执行&#125;\n例子：  \nint grade = 85;if (grade &gt;= 90) &#123;    printf(&quot;A\\n&quot;);&#125; else if (grade &gt;= 80) &#123;    printf(&quot;B\\n&quot;);&#125; else if (grade &gt;= 70) &#123;    printf(&quot;C\\n&quot;);&#125; else &#123;    printf(&quot;D\\n&quot;);&#125;\n\n程序会从上到下判断，一旦某个条件成立，后面的条件就不再检查。\n\n\n5. 嵌套if：条件里的条件&emsp;&emsp;有时候需要“条件里的条件”，比如：  \nif (天气晴朗) &#123;    if (有空) &#123;        去爬山；    &#125; else &#123;        看电影；    &#125;&#125; else &#123;    看书；&#125;\n&emsp;&emsp;在C语言中，嵌套if的写法是：  \nif (外层条件) &#123;    if (内层条件) &#123;        // 内层条件成立时执行    &#125; else &#123;        // 内层条件不成立时执行    &#125;&#125; else &#123;    // 外层条件不成立时执行&#125;\n例子：  \nint age = 20, hasLicense = 1;if (age &gt;= 18) &#123;    if (hasLicense == 1) &#123;        printf(&quot;你可以开车。\\n&quot;);    &#125; else &#123;        printf(&quot;你需要考驾照。\\n&quot;);    &#125;&#125; else &#123;    printf(&quot;你还未成年。\\n&quot;);&#125;\n\n\n6. 常见坑与避坑指南\n条件判断的“真假”规则  \n\nC语言中，0是假，非0是真。  \n例如：if (x)等价于if (x != 0)。\n\n\n别把=和==搞混  \n\n=是赋值，==才是判断相等。  \n错误示例：  if (x = 5) &#123; ... &#125;  // 实际是给x赋值5，条件永远为真！\n\n\nelse匹配最近的if  \n\n如果没有大括号，else会和最近的if配对，可能导致逻辑错误。  \n建议： 用大括号明确代码块。  if (a)    if (b)        doSomething();else    doOther();  // 这个else其实是和上面的if(b)配对！\n\n\n逻辑运算符的优先级  \n\n&amp;&amp;（与）优先级高于||（或），但低于比较运算符（如&gt;、&lt;）。  \n建议用括号明确优先级：  if ((a &gt; 5) &amp;&amp; (b &lt; 10)) &#123; ... &#125;\n\n\n短路现象  \n\n&amp;&amp;和||有“短路”特性：  \na &amp;&amp; b：如果a为假，b不会被计算。  \na || b：如果a为真，b不会被计算。\n\n\n例子：  if (ptr != NULL &amp;&amp; ptr-&gt;value &gt; 0) &#123; ... &#125;  // 避免空指针访问\n\n\n\n\n7. 总结：if语句的核心思想\n选择结构：程序根据条件动态决定执行路径。  \n灵活组合：通过if、else if、else、嵌套if，可以处理复杂的逻辑。  \n注意事项：  \n条件判断的真假规则（0是假，非0是真）。  \n使用大括号明确代码块，避免歧义。  \n注意运算符优先级，避免逻辑错误。\n\n\n\n\n8.补充：关于条件&emsp;&emsp;1. if后面圆括号中的表达式，可以是任意合法的C语言表达式，了可以是任意类型的数据。&emsp;&emsp;2. 无论是否有else子句，if子句中如果只有一条语句，则此语句后的分号不能省略。\n\n9.补充：关于执行条件&emsp;&emsp;首先计算紧跟在if后面一对圆括号内表达式的值。如果表达式值非零，则执行if子句，然后跳过else子句，去执行if语句后的下一条语句；如果表达式的值为零，则跳过if子句，去执行else子句，接着去执行if语句后的下一条语句。\n","tags":["C Language"]},{"title":"第四章——选择结构 拓展节——goto","url":"/Blog/posts/c6ad4934/","content":"1. 什么是goto？&emsp;&emsp;goto是C语言中一个“跳转指令”，它就像你在代码里插了一个书签，然后直接跳到那个书签的位置继续执行。举个栗子🌰：  \nstart:  // 这是书签    printf(&quot;Hello&quot;);    goto start;  // 跳回书签位置\n&emsp;&emsp;这段代码会无限打印“Hello”，因为goto让它一直回到start的位置。  \n\n⚠️ 注意：别真这么写，会死循环的！电脑坏了别来找我！虽然也没那么容易坏就是（目移）\n\n\n2. 语法怎么写？label:    // 标签（书签名）    // 代码块// 跳转到标签goto label;\n\n标签：用标识符+冒号定义，比如error:。\n跳转指令：用goto加标签名，比如goto error;。\n\n\n3. 什么时候能用goto？虽然大家都不太推荐用，但有些时候它真能救命：\n(1) 错误处理：一键清理想象你在写一个复杂函数，比如打开文件、分配内存、再干点别的。如果中间哪一步出错了，你想统一做清理工作，goto就能帮你一键跳到最后的“收尾代码”：\nif (打开文件失败) &#123;    goto 清理;&#125;if (内存分配失败) &#123;    goto 清理;&#125;// ...其他操作清理:    关闭文件();    释放内存();\n这样不用写一堆嵌套的if，代码看着更清爽。\n(2) 从多层循环里逃出来比如你在俄罗斯套娃里，想直接跳出最外层的循环，goto能帮你一步到位：\nfor (...) &#123;    for (...) &#123;        if (发现bug) &#123;            goto 结束循环;        &#125;    &#125;&#125;结束循环:    printf(&quot;终于跑出来了！&quot;);\n要不你得一层层break，还得传状态变量，麻烦得很。\n(3) 简单逻辑的直接跳转在极简代码中，goto可实现类似循环的功能（不推荐滥用）：\nstart:    printf(&quot;Iteration\\n&quot;);    if (condition) goto start;\n\n\n4. 为什么大家都说goto不好？\n代码像面条：goto跳来跳去，逻辑线乱得像意大利面，别人看你的代码得拿根筷子才能理清楚。（ky意大利面抱歉！！！！）\n容易出错：跳转太多，可能会漏掉某些清理步骤，或者不小心跳到不该去的地方。\n过时了：现在编程讲究“结构化”，用if、for、while这些更清晰，goto是以前计算机性能差时的妥协方案。\n\n\n5. 怎么规范用goto？\n只在必要时用：比如错误处理、多层循环退出，别用来写循环体。\n标签命名有意义：别用here:这种模糊的名字，用error:、cleanup:这样一看就知道是干啥的。\n别跳来跳去：确保跳转路径最终能退出循环或函数，防止无限跳转。\n\n\n6. 替代方案有哪些？\n\n\n场景\n推荐替代方案\n解释\n\n\n\n错误处理\n使用return提前退出函数\n比如发现错误直接return，不用goto\n\n\n多层循环跳出\n使用状态变量或函数封装\n用一个break标志控制外层循环\n\n\n资源清理\n使用RAII（C++）或try-catch（其他语言）\nC语言没这些，但可以用goto简化\n\n\n\n7. 示例代码（规范使用）#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void process_data() &#123;    int *buffer = malloc(1024);    FILE *file = fopen(&quot;input.txt&quot;, &quot;r&quot;);    if (!buffer) &#123;        goto error_cleanup;    &#125;    if (!file) &#123;        goto buffer_cleanup;    &#125;    // 正常逻辑...    fclose(file);    free(buffer);    return;buffer_cleanup:    free(buffer);error_cleanup:    printf(&quot;Error: Failed to process data.\\n&quot;);&#125;\n代码解释：&emsp;&emsp;这段代码像打扫房间一样，哪里出问题就跳到对应的“清理步骤”，比如文件没打开就跳到buffer_cleanup释放内存，最后统一输出错误信息。这样代码既简洁又不容易漏掉清理步骤。\n\n8. 总结&emsp;&emsp;goto就像一把瑞士军刀，功能强大但容易伤人。它不是不能用，但得看场合——比如收拾错误残局时，它能帮你省点事。但平时写代码，还是老老实实用结构化的方式更安全。记住一句话：能不用goto的时候尽量不用，非要用的时候也得让逻辑一目了然。\n","tags":["C Language"]},{"title":"第四章——选择结构 第四节——几类运算符的优先级","url":"/Blog/posts/c757fdc0/","content":"\n\n\n优先级\n运算符\n名称&#x2F;功能\n结合性\n说明\n\n\n\n1\n()\n函数调用\n左到右\nfunc()\n\n\n2\n[]\n数组下标\n左到右\narr[3]\n\n\n3\n-&gt;\n指针访问结构体成员\n左到右\nptr-&gt;member\n\n\n4\n.\n结构体成员访问\n左到右\nstruct.member\n\n\n5\n++（后缀）\n后缀自增\n左到右\na++\n\n\n6\n--（后缀）\n后缀自减\n左到右\na--\n\n\n7\n++（前缀）\n前缀自增\n右到左\n++a\n\n\n8\n--（前缀）\n前缀自减\n右到左\n--a\n\n\n9\n+\n正号\n右到左\n5\n\n\n10\n-\n负号\n右到左\n-x\n\n\n11\n!\n逻辑非\n右到左\n!flag\n\n\n12\n~\n按位取反\n右到左\n~0x0F\n\n\n13\n&amp;\n取地址\n右到左\n&amp;var\n\n\n14\n*\n解引用（指针）\n右到左\n*ptr\n\n\n15\n(type)\n类型强制转换\n右到左\n(int)3.14\n\n\n16\nsizeof\n计算对象或类型大小\n右到左\nsizeof(int)\n\n\n17\n*\n乘法\n左到右\na * b\n\n\n18\n&#x2F;\n除法\n左到右\na &#x2F; b\n\n\n19\n%\n取模\n左到右\na % b（仅整数）\n\n\n20\n+\n加法\n左到右\na + b\n\n\n21\n-\n减法\n左到右\na - b\n\n\n22\n&lt;&lt;\n左移\n左到右\na &lt;&lt; 2\n\n\n23\n&gt;&gt;\n右移\n左到右\na &gt;&gt; 2\n\n\n24\n&lt;\n小于\n左到右\na &lt; b\n\n\n25\n&lt;&#x3D;\n小于等于\n左到右\na &lt;&#x3D; b\n\n\n26\n&gt;\n大于\n左到右\na &gt; b\n\n\n27\n&gt;&#x3D;\n大于等于\n左到右\na &gt;&#x3D; b\n\n\n28\n&#x3D;&#x3D;\n等于\n左到右\na &#x3D;&#x3D; b\n\n\n29\n!&#x3D;\n不等于\n左到右\na !&#x3D; b\n\n\n30\n&amp;\n按位与\n左到右\na &amp; b\n\n\n31\n^\n按位异或\n左到右\na ^ b\n\n\n32\n|\n按位或\n左到右\na | b\n\n\n33\n&amp;&amp;\n逻辑与\n左到右\na &amp;&amp; b（短路特性）\n\n\n34\n||\n逻辑或\n左到右\na || b（短路特性）\n\n\n35\n?:\n三目条件运算符\n右到左\na ? b : c\n\n\n36\n&#x3D;\n赋值\n右到左\na &#x3D; b\n\n\n37\n+&#x3D;\n加后赋值\n右到左\na +&#x3D; b\n\n\n38\n-&#x3D;\n减后赋值\n右到左\na -&#x3D; b\n\n\n39\n*&#x3D;\n乘后赋值\n右到左\na *&#x3D; b\n\n\n40\n&#x2F;&#x3D;\n除后赋值\n右到左\na &#x2F;&#x3D; b\n\n\n41\n%&#x3D;\n取模后赋值\n右到左\na %&#x3D; b\n\n\n42\n&lt;&lt;&#x3D;\n左移后赋值\n右到左\na &lt;&lt;&#x3D; b\n\n\n43\n&gt;&gt;&#x3D;\n右移后赋值\n右到左\na &gt;&gt;&#x3D; b\n\n\n44\n&amp;&#x3D;\n按位与后赋值\n右到左\na &amp;&#x3D; b\n\n\n45\n^&#x3D;\n按位异或后赋值\n右到左\na ^&#x3D; b\n\n\n46\n|&#x3D;\n按位或后赋值\n右到左\na |&#x3D; b\n\n\n47\n,\n逗号运算符\n左到右\na &#x3D; (b++, c &#x3D; 5, d)\n\n\n记忆技巧 ：\n\n单目 &gt; 算术 &gt; 移位 &gt; 关系 &gt; 逻辑 &gt; 赋值 。\n\n","categories":["C_Language","第四章——选择结构"],"tags":["C Language"]},{"title":"第四章——选择结构 第六节——switch-break语句及其构成的选择结构","url":"/Blog/posts/253c2b9f/","content":"1. 什么是switch-break语句？&emsp;&emsp;switch-break是C语言中用于多分支选择的控制结构，它通过匹配一个表达式的值，决定执行哪一段代码。  \n\n核心思想：像“服务员根据顾客点的菜名做对应的菜”。  \nswitch：服务员，根据输入的值（菜名）决定做什么。  \ncase：菜单上的每一道菜（具体选项）。  \nbreak：做完这道菜就停下（否则会继续做后面的菜！）。  \ndefault：如果没点任何列出的菜，就默认做奶茶（兜底选项）。\n\n\n2. 语法结构switch (表达式) &#123;    case 值1:         执行代码1;         break;    case 值2:         执行代码2;         break;    ...    default:         默认执行代码;         break;&#125;\n\n表达式：必须是整型或字符型（如int、char）。  \ncase：每个值必须是固定常量（不能是变量）。  \nbreak：跳出switch，否则会继续执行后续case（穿透效应）。  \ndefault：可选的默认分支，处理所有未匹配的情况。\n\n\n3. default的作用\n兜底选项：当所有case都不匹配时执行default。  \n场景举例：  \n用户点了菜单上没有的菜 → 推荐默认菜品（奶茶）。  \n程序接收到未知状态码 → 提示“请检查输入”。\n\n\n\n\n4. 生活中的例子例1：点餐系统int choice = 2; // 用户点了“2”switch (choice) &#123;    case 1: printf(&quot;牛肉面已下单！\\n&quot;); break;    case 2: printf(&quot;炒饭已下单！\\n&quot;); break;    case 3: printf(&quot;奶茶已下单！\\n&quot;); break;    default: printf(&quot;抱歉，暂时没有这道菜。\\n&quot;);&#125;\n\n输出：炒饭已下单！  \n如果用户输入4：抱歉，暂时没有这道菜。（default生效）\n\n例2：交通信号灯int light = 2; // 1=红灯，2=黄灯，3=绿灯switch (light) &#123;    case 1: printf(&quot;红灯：请停车！\\n&quot;); break;    case 2: printf(&quot;黄灯：准备通行！\\n&quot;); break;    case 3: printf(&quot;绿灯：可以通行！\\n&quot;); break;    default: printf(&quot;信号灯故障，请小心！\\n&quot;);&#125;\n\n如果light=4：输出信号灯故障，请小心！（default兜底）\n\n\n5. switch和if-else的区别\n\n\n场景\nswitch\nif-else\n\n\n\n适用类型\n整型、字符型\n所有类型（包括浮点、字符串）\n\n\n多分支效率\n更高效（直接跳转）\n逐个判断条件\n\n\n穿透效应\n存在（需注意break）\n无\n\n\n默认处理\ndefault兜底未匹配情况\nelse处理未匹配情况\n\n\n\n6. 常见错误与避坑指南坑1：忘记加break导致“穿透效应”switch (choice) &#123;    case 1: printf(&quot;牛肉面\\n&quot;);    case 2: printf(&quot;炒饭\\n&quot;);    default: printf(&quot;奶茶\\n&quot;);&#125;\n\n如果choice=1，输出：  牛肉面炒饭奶茶\n原因：没有break，程序会继续执行后续case，直到遇到break或结束。  \n避坑方法：每个case后都加break，除非有意设计穿透（如合并选项）。\n\n坑2：default的位置影响执行流程switch (x) &#123;    case 1: printf(&quot;1\\n&quot;); break;    default: printf(&quot;default\\n&quot;);     case 2: printf(&quot;2\\n&quot;); break;&#125;\n\n如果x=2，程序会先执行default，再执行case 2，因为default不在最后。  \n避坑方法：把default放在最后，避免逻辑混乱。\n\n坑3：switch表达式类型错误float x = 3.14;switch (x) &#123; ... &#125;  // ❌ 错误！只能用整型或字符\n\n原因：switch的表达式必须是整数或字符，不能是浮点数或字符串。\n\n坑4：case后使用非常量int a = 5;switch (x) &#123;    case a: ...  // ❌ 错误！a是变量，不是常量&#125;\n\n原因：case后面必须是固定值（如1、2、’A’），不能是变量。\n\n\n7. default的典型应用场景\n无效输入处理  \n用户输入不在菜单选项中 → 提示“请重新输入”。\n\n\n错误处理  \n程序接收到未知状态码 → 提示“请检查输入”。\n\n\n默认操作  \n颜色未指定时，默认使用白色。\n\n\n\n\n8. 总结\nswitch-break的核心：根据表达式的值快速匹配多个分支，default作为兜底。  \n关键规则：  \n表达式必须是整型或字符。  \n每个case必须是固定值。  \n每个case后尽量加break，除非有意设计穿透。  \ndefault放最后，处理未匹配的情况。\n\n\n记住一句话：  \nswitch是“菜单选择器”，default是“最后的救命稻草”！\n\n\n\n\n9.几点稍微正式一点的说明\nswitch、case 和 default 是 C 语言关键字，default 子句可缺省；&emsp;&emsp;2. switch 后的表达式必须为整型或字符型（如 int、char）；&emsp;&emsp;3. case 后的常量表达式称为标号，标号必须互不相同，且 case 与标号间需留空格（如 case 1:）；&emsp;&emsp;4. case 标号后的语句序列可以为空（仅保留冒号），但冒号不可省略；&emsp;&emsp;5. case 后的语句序列可以是单条或多条语句，多条语句无需用 {} 包裹；&emsp;&emsp;6. 多个 case 可共用同一组执行语句（实现多个标号对应相同操作），如下实例，无论输入大写还是小写，都是一样的；\n\n#include &lt;stdio.h&gt;int main() &#123;    int grade;    printf(&quot;请输入成绩等级 (A/B/C/D): &quot;);    scanf(&quot;%c&quot;, &amp;grade);    switch (grade) &#123;        case &#x27;A&#x27;:        case &#x27;a&#x27;:            printf(&quot;优秀\\n&quot;);            break;        case &#x27;B&#x27;:        case &#x27;b&#x27;:            printf(&quot;良好\\n&quot;);            break;        case &#x27;C&#x27;:        case &#x27;c&#x27;:            printf(&quot;中等\\n&quot;);            break;        case &#x27;D&#x27;:        case &#x27;d&#x27;:            printf(&quot;及格\\n&quot;);            break;        default:            printf(&quot;无效输入\\n&quot;);    &#125;    return 0;&#125;\n&emsp;&emsp;7. 若未使用 break，程序会顺序执行后续所有 case 语句（包括 default），因此必须用 break 跳出当前 case；&emsp;&emsp;8. switch 语句支持嵌套，内部 switch 的规则与外部一致；&emsp;&emsp;9. case 标号必须为常量表达式（如字面量、宏定义等），不能是变量或计算结果；&emsp;&emsp;10. default 子句通常放在最后，用于处理未匹配的情况；&emsp;&emsp;11. 避免因忘记 break 导致的穿透执行（fall-through）问题。\n","tags":["C Language"]},{"title":"第八章——地址和指针 第二节——给指针变量赋值","url":"/Blog/posts/f4230736/","content":"给指针变量赋地址值&emsp;&emsp;指针变量可以通过不同的方式获得地址值，从而指向一个具体的对象。&emsp;&emsp;指针变量获得地址值通常有以下几种办法：\n\n通过取地址运算符&amp;&emsp;&emsp;&amp;：表示求出变量的地址，如下：\nint k = 1 , *q , *p;q = &amp;k;\n\n说明\n求地址运算符&amp;只能用于变量和数组元素。不能用于常量、表达式和register变量。\n\n\nq&#x3D;&amp;(k+1); &#x2F;&#x2F; 这种是错误的\n\n\n&amp;必须放在运算对象的左边，而且运算对象的基类型要与指针变量的基类型相同。\n在scanf()函数中，输入的每个变量之前都必须加&amp;，就是把终端读入的数据依次放到这些地址所代表的才能出单元之中。故有以下语句等价： //=======语句1=======//scanf(&quot;%d&quot;,&amp;a);//=======语句2=======//q = &amp;k;scanf(&quot;%d&quot;,q);\n\n\n通过指针变量获得地址值&emsp;&emsp;通过赋值运算把一个指针变量中的地址赋给另外一个指针变量，从而使两个指针指向同一个地址。\nint k = 1 , *p , *q;q = &amp;k;p = q;\n\n\n通过标准函数获得地址&emsp;&emsp;通过调用库函数malloc和calloc在内存中开辟动态存储单元，并把所开辟的动态存储单元的地址赋给指针变量。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    // 1. malloc分配内存（手动初始化）    int *p1 = (int *)malloc(sizeof(int));  // 分配单个int空间    if(p1 != NULL) &#123;                        // 检查分配是否成功        *p1 = 100;                          // 给分配的内存赋值        printf(&quot;malloc值：%d\\\\n&quot;, *p1);     // 输出：100        free(p1);                           // 用完必须释放    &#125;    // 2. calloc分配内存（自动初始化为0）    int *p2 = (int *)calloc(3, sizeof(int)); // 分配3个int的数组    if(p2 != NULL) &#123;        printf(&quot;calloc数组初始值：&quot;);        for(int i=0; i&lt;3; i++) &#123;            printf(&quot;%d &quot;, p2[i]);  // 输出：0 0 0        &#125;        free(p2);    &#125;    // 3. realloc扩展内存    int *p3 = (int *)malloc(2 * sizeof(int)); // 初始分配2个int    p3[0] = 1;     p3[1] = 2;        // 扩展为4个int空间    p3 = (int *)realloc(p3, 4 * sizeof(int));    if(p3 != NULL) &#123;        p3[2] = 3;  // 新增空间赋值        p3[3] = 4;                printf(&quot;\\\\n扩展后的数组：&quot;);        for(int i=0; i&lt;4; i++) &#123;            printf(&quot;%d &quot;, p3[i]);  // 输出：1 2 3 4        &#125;        free(p3);    &#125;    return 0;&#125;\n\nmalloc值：100calloc数组初始值：0 0 0扩展后的数组：1 2 3 4\n\n\n给指针变量赋空值&emsp;&emsp;NULL是在stdio.h中定义的预定义符，代码值为0。\np=NULL;\n&emsp;&emsp;执行该语句后，p就称为空指针。上述代码等价于如下：\np=‘\\0’;p＝0；\n说明\n这时p是具有一个确定的值－－“空”，而不是指向地址为0的存储单元。\n不能通过一个空指针去访问一个存储单元时，否则会得到一个出错信息。\n\n\n考点&emsp;&emsp;一个指针可以通过以下三种方式获得一个确定的地址，从而指向一个具体的对象：\n\n通过求地址运算（&amp;）&emsp;&emsp;求地址运算符&amp;只能用于变量和数组元素，不能用于表达式、常量或者被说明为register的变量。且&amp;必须放在运算对象的左边，而且运算对象的类型必须与指针变量的基类型相同。\n\n通过指针变量获得地址值\n\n通过标准函数获得地址值\n\n\n","tags":["C Language"]},{"title":"第四章——选择结构 第零节——前言","url":"/Blog/posts/b9d74d24/","content":"第四章 选择结构程序设计——让程序学会思考学习目标：打造会”决策”的程序通过本章修炼，你将获得：\n\n掌握关系运算与逻辑运算的”判断之眼”\n理解条件表达式的”选择之心”\n熟练运用if语句家族（单分支&#x2F;双分支&#x2F;嵌套）\n玩转switch-case的”多选魔法阵”\n认识语句标号与goto语句的”古老秘术”\n\n知识脉络一、基础判断力培养\n关系运算：如同裁判员比较选手得分（&gt;, &lt;, &#x3D;&#x3D; 等）\n逻辑运算：像侦探推理的真伪判断（&amp;&amp;, ||, !）\n优先级法则：掌握运算顺序的”武林秘籍”\n\n二、选择结构三重奏\n条件表达式：构建决策树的种子\nif家族传奇：\n单分支：如果下雨就带伞的经典逻辑\n双分支：像自动售货机的”投币-出货”机制\n嵌套结构：多层关卡挑战的通关密码\n\n\n\n三、多路分支魔法阵\nswitch-case：\ncase：像不同钥匙打开对应锁孔\nbreak：防止”穿透效应”的防护罩\ndefault：兜底方案的保险箱\n\n\n\n四、古老控制术\n语句标号：给代码行装上定位器\ngoto语句：时空跳跃的传送门（慎用！）\n\n生活场景映射\n天气感知系统：像老中医看天穿衣\n智能导航：化身GPS里的决策精灵\n权限验证：做数字世界的守门人\n游戏AI：创造会思考的虚拟对手\n\n修炼指南&emsp;&emsp;建议用”流程图思维”观察程序走向，重点参悟if语句的嵌套心法和switch-case的匹配玄机。对于goto语句，了解其运行机制即可，现代编程应以结构化控制语句为正道，goto他是邪修!\n","categories":["C_Language","第四章——选择结构"],"tags":["C Language"]},{"title":"第八章——地址和指针 第一节——指针变量的定义和初始化","url":"/Blog/posts/4944f5d8/","content":"变量（从内存层次的重理解）&emsp;&emsp; 变量实质上代表了“内存中的某个存储单元”。若在内存中定义一个变量，那么这个变量的内存也就是确定的了。&emsp;&emsp; 即，定义一个变量，相当于插了个路标，指向一定的存储空间。&emsp;&emsp; 举个通俗一点的例子：假设你要去一栋教学楼中的一间教室，去取某个物品，此时你要去的教室名“4 教 101”便是 变量名，而教室钥匙便是 指针，教室便是 内存空间，你要取的物品便是 存储值。\n&emsp;&emsp; 我们在程序中只需要指出变量名（教室名），无需知道每个变量在内存中的具体位置（房间具体在教学楼的哪个位置），每个变量与具体地址的联系是由 C 语言编译系统来完成的。对于变量的存取操作就是对某个存储单元进行操作。这种  直接按变量的地址存取变量值  的方式就称作  直接存取 。\n\n指针&emsp;&emsp; 指针也可以视作一种变量，而这种变量用来存放的是内存地址。\nint *p;int a = 9063;p = &amp;a;\n\n\n间接存取&emsp;&emsp; 这种通过变量 p 到变量 a 的地址，然后再存取变量 a 的值的方式称为“间接存取”&emsp;&emsp; 指针变量 p 指向了变量 a 的含义是：指针 p 中存放了变量 a 的地址。\n定义&emsp;&emsp; 一个变量的地址\n指针变量&emsp;&emsp; 专门用来存放变量地址的变量。\n\n定义指针的形式类型名 *指针变量名1，*指针变量2，……int *pi,*pj;\n\n\n*是一个说明符，说明该变量指针变量。\n*不可省略，否则就变成了 int pi , pj（定义两个整型变量）。\n\ndouble *pd;// 只能是指向double型的变量，即存放double型变量的地址。char *s1,*s2;// 只能是指向char型的变量，即存放char型变量的地址。\n\n说明int **p , *s , k = 20;s = &amp;k;p = &amp;s;\n\n\n指针 p 的基类型是 int 类型的指针。\n&amp;是求地址运算符。\n因为基本数据类型 int、float、char 等所需存储的空间不同，所以需要定义指针变量的基类型。\n*是指针运算符，返回其所指对象的值。\n\n\n\n考点\n指针变量定义的形式：\n\n\n存储类型 类型名 指针变量名 1, 指针变量名 2,…\n\n\n也可以定义的同时赋初值:\n\n\n存储类型 类型名 *指针变量名 1 &#x3D; [初值],…\n\n\n“存储类型”可以缺省, 缺省时的存储类型为自动型 auto\n定义指针变量时，指针变量名前必须有一个*，在此它是定义指针变量的标志，不同于后面所说的“指针运算符”\n初值的形式通常有三种：“&amp;普通变量名”、“&amp;数组元素”和“数组名”\n\nC 语言规定：&emsp;&emsp; 数组名代表的是数组的首地址，即第一个元素的地址。\n","categories":["C_Language","第八章——地址和指针"],"tags":["C Language"]},{"title":"第八章——地址和指针 第五节——指针的比较","url":"/Blog/posts/4fb3113c/","content":"指针的比较核心概念想象你手上有两个快递单号（指针），比较这两个地址的位置关系：\n\n同一条街的对比：就像比较同一排房子的门牌号（同一数组）\n不同城市的对比：比较不同街道的门牌号毫无意义（不同数组指针）\n\n代码示例#include &lt;stdio.h&gt;int main() &#123;    int arr[5] = &#123;10, 20, 30, 40, 50&#125;;    int *p = &amp;arr[0];  // 指向第一个房子    int *q = &amp;arr[3];  // 指向第四个房子        // 生活场景：快递员送餐路线比较    if(p &lt; q) &#123;        printf(&quot;p指向的地址比q更靠近街道入口\\n&quot;);  // 实际是内存地址的高低    &#125;        // 空指针检查：确认地址是否有效    int *temp = NULL;    if(temp == NULL) &#123;        printf(&quot;这个地址是空的，不能送快递！\\n&quot;);    &#125;        return 0;&#125;\n\n\n生活举例场景一：图书馆找书&emsp;&emsp;假设你在图书馆找书：\n\n正确对比：比较同一排书架的编号（同一数组）\n“A区3号架”和”A区5号架”谁离入口近？\n\n\n错误对比：比较不同楼栋的书架编号（不同数组）\n比较”主楼A3”和”分楼B2”谁离入口近是没意义的\n\n\n\n场景二：快递投递&emsp;&emsp;想象你是外卖小哥：\n\n有效比较：查看两个订单是否在同一栋楼\n\nif(order1.building == order2.building)// 同一栋楼才能比较楼层\n\n空指针检查：确认订单地址是否有效\n\nif(order != NULL) // 确认不是虚构的订单地址\n\n注意事项\n无效对比就像：\n\n\n比较北京朝阳区和上海浦东新区的门牌号大小\n试图用GPS定位比较纸质书的页码\n\n\n空指针陷阱：\n\n\n就像拿着写有”火星1号”的地址去送餐（NULL指针）\n或者地址栏写着”宇宙中心”的虚假信息（野指针）\n\n\n比较结果：\n\n\n内存地址数值大小与变量值无关\n类似于门牌号666和888不代表住户财富多少\n\n","tags":["C Language"]},{"title":"第八章——地址和指针 第四节——指针的移动","url":"/Blog/posts/b79fcdac/","content":"理解&emsp;&emsp;所谓移动指针就是对指针变量加上或减去一个整数，或通过赋值运算，使指针指向相邻的存储单元。只有当指针指向一串连续的存储单元时，还可以和指向同一串连续存储单元的指针进行相减的运算，除此之外，不可以对指针进行任何其它的算术运算。\n\n指针变量只能进行逻辑运算和相减的算术运算。\n不是指向同一数组的指针变量运算是无意义的。\n指针变量的值加1或减1，并不能地址加1中减1，而是加上或减去该变量在内存中所占的字节数，该字节数由指针的基类型决定。\n\n\n#include &lt;stdio.h&gt;int main() &#123;    int arr[] = &#123;1, 2, 3, 4, 5&#125;;    int *p = arr;  // 指针初始化指向数组首元素        // 示例1：通过指针移动遍历数组    printf(&quot;遍历数组元素：\\n&quot;);    for(int i=0; i&lt;5; i++) &#123;        printf(&quot;元素地址：%p，值：%d\\n&quot;, p, *p);        p++;  // 指针向后移动一个int类型的位置    &#125;        // 示例2：指针相减运算    int *p1 = &amp;arr[2];    int *p2 = &amp;arr[4];    printf(&quot;\\n两个指针相减的结果：%ld\\n&quot;, p2 - p1);  // 输出2（两个int指针间隔2个元素）        // 示例3：错误的指针运算    int a = 10, b = 20;    int *p3 = &amp;a;    // 错误！不能对非数组指针执行算术运算    // p3 += 1;  // 取消注释将导致未定义行为        return 0;&#125;","tags":["C Language"]},{"title":"第八章——地址和指针 第零节——前言","url":"/Blog/posts/ad030492/","content":"第八章 地址与指针——内存操控的九阳真经核心能力修炼：参悟三大指针秘术通过本章修炼，你将获得：\n\n掌握指针变量的”灵魂绑定”之术\n驯服内存地址的”瞬移大法”\n参透指针比较的”天机算盘”\n解锁函数参数的”隔空传物”神功\n破解指针移动的”循经走脉”奥秘\n\n知识脉络一、指针根基\n定义仪式：指针变量的声明如同签订生死契约（int *p;的玄机）\n初始化要诀：野指针是修真者的大忌（NULL指针的自我保护机制）\n取址秘法：&amp;运算符是打开内存之门的钥匙\n\n二、内存操控\n间接访问：*运算符的穿墙术（通过指针修改变量值）\n指针移动：步进法则如同打通任督二脉（+1不是加1！）\n地址比较：内存布局的华山论剑（&gt;、&lt;、&#x3D;&#x3D;的江湖规矩）\n\n三、实战应用场\n函数参数：地址传递的隔空传物（突破值传递的桎梏）\n数组操作：指针与数组的双生之谜（a[i]与*(a+i)的等价证明）\n字符串处理：char指针的游龙戏凤（字符串常量的正确打开方式）\n动态内存：malloc&#x2F;calloc的内功心法（未完待续…）\n\n修炼心法&emsp;&emsp;建议用”内存视角”观察程序运行，重点参悟指针移动的步进法则。警惕野指针的”走火入魔”，善用调试器观察内存地址变化。特别注意数组越界访问的”经脉错乱”，掌握空指针检查的”护体神功”。指针运算需遵循类型法则，切勿强行类型转换破坏内存安全。\n","categories":["C_Language","第八章——地址和指针"],"tags":["C Language"]},{"title":"第八章——地址和指针 第六节——指针作为函数的参数","url":"/Blog/posts/af992b60/","content":"指针作为函数参数详解核心原理&emsp;&emsp;指针作为函数参数就像给函数发”定位器”，让函数能直接操作你家里的真实物品。普通参数传递相当于给函数一个物品的复印件，函数怎么改都不会影响原件；而指针参数相当于告诉函数”这个东西在你家客厅第三个柜子第四个抽屉”，函数可以直接修改原件。\n经典代码示例// 交换两个数的函数void swap(int *a, int *b) &#123;    int temp = *a;  // 取出a指向的值    *a = *b;        // 把b的值放回a的位置    *b = temp;      // 把临时值放回b的位置&#125;\n\n生活类比\n医院体检场景：医生直接修改你的原始报告单 vs 看复印件\n快递取件场景：直接给原始取件码 vs 复印取件码\n\n进阶应用场景// 计算矩形面积和周长的函数void calculateRectangle(int length, int width, int *area, int *perimeter) &#123;    *area = length * width;    *perimeter = 2 * (length + width);&#125;\n\n&emsp;&emsp;指针可以作为参数在主调函数和被调用函数之间传递数据，通过指针可以在被调用函数对调用函数中的变量进行引用，这也就使得通过形参改变对应实参的值有了可能，利用此形式就可以把两个或两个以上的数据从被调用的函数返回到调用函数。\n&emsp;&emsp;通过传送地址值，可以在被调用函数中对调用函数中的变量进行引用。\n","categories":["C_Language","第八章——地址和指针"],"tags":["C Language"]},{"title":"第八章——地址和指针 第三节——通过指针来引用一个存储单元","url":"/Blog/posts/5d0f6387/","content":"*：间接访问运算符（间址运算符）&emsp;&emsp;首先看如下示例代码：\nint *p , i = 10 , j;p = &amp;i;j = *p;// 等价于看j = *(&amp;i)// 语句整体等价于 j = i;\n\n说明\n*的运算对象必须是地址或者是存放地址的指针变量。\n*的含义是取地址中的内容\n\n示例二int *p,k=0;p=&amp;k;*p=100;    *p=*p+1;// 最后一行代码等价于// *p+=1// ++*p　// (*p)++\n\n说明\n出现在赋值号左边时，代表的是指针所指的存储单元；当出现在赋值号右边时，代表的是所指存储单元的内容。 \n*p&#x3D;*p+1的含义是指将p所指向单元的内容加1，然后再放入p所指向的单元中。即将k的值加1，此时，k&#x3D;101。\n\n\n&amp;与*运算符含义&amp;\n含义：取变量的地址\n单目运算符\n优先级：与*相同\n结合性：自右向左\n\n*\n含义：取指针所指向变量的内容\n单目运算符\n优先级：与&amp;相同\n结合性：自右向左\n\n两者关系：&emsp;&emsp;互为逆运算\n\n个人理解&emsp;&emsp;在C语言里，*和&amp;这两个符号看起来像乘法和按位与，但它们其实是“指针操作的双胞胎兄弟”，一个负责“找地址”，一个负责“用地址找东西”。我们用“人话”来解释它们到底在干嘛。\n\n1. 首先，变量和内存地址是什么关系？&emsp;&emsp;想象你有一个装苹果的盒子，盒子的名字叫a，里面放了5个苹果。  \nint a = 5;\n\na 是盒子的名字。\n5 是盒子里的苹果数量。\n这个盒子放在某个地方（比如厨房的桌子上），这个“位置”就是它的内存地址。\n\n\n2. &amp;：取地址运算符（“我要盒子的位置！”）&emsp;&emsp;&amp; 就是说：“嘿，告诉我这个盒子放在哪？”  \nint *p = &amp;a;\n\n&amp;a：就是问“盒子 a 放在哪？”——得到的是它的地址（比如厨房桌子的第3排第5列）。\nint *p：是一个“存折”，存折上写着“我指向一个 int 类型的盒子”。\np = &amp;a：把地址（厨房的位置）写在存折上。\n\n\n3. *：解引用运算符（“我要用地址找盒子！”）&emsp;&emsp;* 有两种用法，分别对应两种场景：\n(1) 声明指针（开个存折）int *p;\n\n这里的 * 是告诉编译器：“我要开个存折，以后用来存 int 类型盒子的地址。”\n\n(2) 解引用指针（根据地址取东西）*p = 10;\n\n这里的 *p 是说：“根据存折上的地址（厨房的位置），找到那个盒子，然后往里面放10个苹果。”\n\n\n4. 对比总结：&amp; 和 * 是“互为反义词”\n\n\n操作\n人话解释\n示例\n\n\n\n&amp;a\n找到变量 a 的地址\n把 a 的地址（厨房位置）写在存折上\n\n\n*p\n根据指针 p 的地址，找到它指向的值\n根据存折上的地址，去拿盒子的苹果\n\n\n\n5. 生活化例子：快递送苹果\n变量 a：你家的快递柜，编号是 123，里面有 5 个苹果。\n&amp;a：快递员问你“你的快递柜编号是多少？”，你回答“123”。\n指针 p：快递员的小本本，他记下“123”这个编号。\n*p：快递员根据小本本上的编号 123，去快递柜取出苹果。\n\n\n6. 常见错误：别让存折“没写地址”或“写错地址”\n错误1：未初始化指针就用 *p  \nint *p;*p = 10; // 错误！存折上没写地址，凭空改值会出事！\n👉 比喻：存折上没写快递柜编号，快递员随便找个地方放苹果，可能砸了别人的快递！\n\n错误2：对非指针变量用 *  \nint a = 5;int b = *a; // 错误！a 不是指针，不能解引用\n👉 比喻：a 是个快递柜编号，不是存折，你不能用它去找“编号的编号”。\n\n\n\n7. 代码示例：一步一步看懂#include &lt;stdio.h&gt;int main() &#123;    int a = 5;        // 有个快递柜 a，编号 123，里面有 5 个苹果    int *p = &amp;a;      // 存折 p 记下地址 123    printf(&quot;a 的值是 %d\\n&quot;, a);     // 输出 5    printf(&quot;a 的地址是 %p\\n&quot;, &amp;a);  // 输出 123（实际是十六进制地址）    printf(&quot;p 里的地址是 %p\\n&quot;, p); // 输出 123    printf(&quot;p 指向的值是 %d\\n&quot;, *p); // 输出 5（根据地址 123 取苹果）    *p = 10;          // 根据存折里的地址 123，把苹果改成 10 个    printf(&quot;现在 a 的值是 %d\\n&quot;, a); // 输出 10    return 0;&#125;\n\n\n8. 最后总结：一句话记住它们\n&amp;：从变量找地址（快递柜 → 快递柜编号）。  \n*：从地址找变量（快递柜编号 → 快递柜里的苹果）。\n\n它们就像“钥匙和锁”、“地图和宝藏”的关系：  \n\n&amp; 是钥匙（找到地址），  \n* 是地图（根据地址找到值）。\n\n\n考点\n指针运算符“*”：其作用是返回以操作对象的值作为地址的变量的内容。\n指针运算符“*”是单目运算符，优先级高于所有的双目运算符，结合性是自右向左。\n\n","tags":["C Language"]},{"title":"第零章——万物起源 第零章——万物起源","url":"/Blog/posts/3700410d/","content":"一、前言&emsp;&emsp;C语言属于是编程界的开山鼻祖了，所以有些东西超级原始，但也不是不好理解，在学习C语言之前有些工具我们要设置一下。当然，学校还在用Visual Studio 2010的版本，出去别人一问。哇！是清朝老古董欸！那就尴尬了，所以我用的是比较大众化，适合多平台开发的Visual Studio Code，不光可以用来写C，还可以写Python，JAVA，PHP，算是全能型选手了。\n\n二、[[安装Visual Studio Code]]&emsp;&emsp;首先打开他的官网，点击Download For Windows&emsp;&emsp;会下载一个安装包，打开之后一直点下一步就好，第一次打开之后可能是全英文界面，比如下面这样&emsp;&emsp;所以，我在这边提供了我的配置文件，下载下来后你只需要按照图示操作即可（不过就算是中文也建议用一下我的配置文件，因为我将别的设置部分也配置好了）\n点击下载配置文件&emsp;&emsp;配置文件下载之后，按下图导入&emsp;&emsp;然后选择我们下载的配置文件打开即可（之后我都会以VSC来简称这个软件）\n\n三、[[安装MSYS2]]&emsp;&emsp;之前我们安装的VSC只是个编辑软件，将相当于编辑任务清单，具体执行还是需要MSYS来进行配合。&emsp;&emsp;首先去MSYS2的官网去下载安装包，网站打开之后点击这个&emsp;&emsp;下载之后的安装包也是一直点下一步即可（如果要修改安装路径，不建议有中文，空格等等），在安装完成之后会打开一个命令行窗口，分别输入以下命令以更新基础数据库。（即一行一行执行）\npacman -Syupacman -Supacman -S --needed base-devel mingw-w64-x86_64-toolchain\n&emsp;&emsp;命令执行期间只要不报错即可，出现[Y&#x2F;n]的选项都填入Y然后点击回车即可，另说就是，这些命令行无法使用CTRL+C或者+V之类的快捷键，因为在这些系统之中ctrl+c属于停止运行的快捷键，所以一般还是不要用比较好，在界面右键选择copy和paste也可以复制粘贴。&emsp;&emsp;接下来打开我们刚才的安装路径，比如我是默认安装，就在C:&#x2F;msys64这个路径之下，找到mingw64文件夹，然后打开它里面的bin文件夹，复制整个文件路径C:\\msys64\\mingw64\\bin，在此电脑图标上右键，点击属性，打开设置之后点击高级系统属性&emsp;&emsp;在蓝色框里把路径填写进去之后点确定就可以，，然后按住win+r，打开运行窗口，输入CMD，输入如下命令测试安装是否成功。\ngcc -v\n&emsp;&emsp;出现如下内容便是安装成功&emsp;&emsp;至此，我们的基础设置已经全部完成！接下来就是正式学习C语言了。\n","categories":["C_Language","第零章——万物起源"],"tags":["C Language"]}]