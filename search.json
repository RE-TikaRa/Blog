[{"title":"LaTeX学习日志01-前期准备","url":"/Blog/posts/828fd9e/","content":"前言LaTeX 是基于 TeX 的排版系统，用纯文本加命令写作，排版统一且可复用。它会编译为高质量 PDF，尤其适合公式、参考文献和长文档，也便于后期统一调整格式。写作时可更专注内容，把样式交给工具处理。本文记录在 Windows 11 上使用 Tectonic + VS Code + LaTeX Workshop 的前期准备流程。\n◆❖◆\n\n准备清单\nTectonic（LaTeX 引擎）\nVS Code\nLaTeX Workshop 插件\n环境变量 Path（用于命令行调用）\n\n◆❖◆\n\n安装 Tectonic\n打开 Tectonic 官网，点击 Install Tectonic 0.15.0 进入安装页面。\n\n\n\n我更推荐在 GitHub Release 下载。点击 find the latest released binaries on GitHub 进入发行页。\n\n\n\n在发布页找到 Assets。\n\n\n\nWindows 11 x64 建议下载 tectonic-0.15.0-x86_64-pc-windows-msvc.zip（官方 MSVC 原生构建，兼容性最好）。\n\n\n\n解压后将 tectonic.exe 放到固定路径，例如 C:\\Tectonic。\n把该路径加入系统环境变量 Path。\n\n\n\n（可选）命令行验证：tectonic --version。\n\n◆❖◆\n\n安装 VS Code 与 LaTeX Workshop在 VS Code 扩展中搜索并安装 LaTeX Workshop 插件。\n\n安装完成后，使用快捷键 Ctrl+Shift+P 打开用户设置（JSON）。\n\n◆❖◆\n\n配置 LaTeX Workshop找到下面类似的配置，没有的话可以直接复制并按需调整。注意 JSON 语法，不确定就发给 AI 帮你检查。\n&#123;  &quot;workbench.editorAssociations&quot;: &#123;    &quot;*.pdf&quot;: &quot;latex-workshop-pdf-hook&quot;  &#125;,  &quot;latex-workshop.intellisense.biblatexJSON.replace&quot;: &#123;&#125;,  &quot;latex-workshop.latex.tools&quot;: [    &#123;      &quot;name&quot;: &quot;tectonic&quot;,      &quot;command&quot;: &quot;tectonic&quot;,      &quot;args&quot;: [        &quot;--synctex&quot;,        &quot;--keep-logs&quot;,        &quot;--print&quot;,        &quot;%DOC%.tex&quot;      ],      &quot;env&quot;: &#123;&#125;    &#125;  ],  &quot;latex-workshop.latex.recipes&quot;: [    &#123;      &quot;name&quot;: &quot;tectonic&quot;,      &quot;tools&quot;: [&quot;tectonic&quot;]    &#125;  ],  &quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;: &quot;double-click&quot;,  &quot;[latex]&quot;: &#123;    &quot;editor.formatOnSave&quot;: false  &#125;,  &quot;latex-workshop.latex.autoBuild.run&quot;: &quot;onSave&quot;,  &quot;latex-workshop.latex.autoBuild.interval&quot;: 500&#125;\n\n完成后保存即可。之后保存 .tex 文件会自动调用 Tectonic 编译，并在 VS Code 内部预览 PDF。\n","categories":["Latex"],"tags":["LaTeX"]},{"title":"FileLocksmith-单文件版本","url":"/Blog/posts/5d98e7ac/","content":"File Locksmith 是用于定位并解除文件&#x2F;文件夹占用的工具。\n项目信息\n原始项目仓库：https://github.com/microsoft/PowerToys\n拆分自 PowerToys 0.97.1 的 File Locksmith\n目标环境：Windows 11 24H2 26100.7623\n\n下载方式一：下载发布包（推荐）Releases：https://github.com/RE-TikaRa/FileLocksmith/releases\n\nFileLocksmith Portable version：自带依赖，开箱即用，体积更大  \nFileLocksmith System dependency versions：不带运行库，体积更小，需要系统已安装依赖  \n依赖：Windows App SDK Runtime、VC++ 运行库、WebView2 Runtime\n\n\n\n方式二：获取源码用于自行构建或二次开发：\ngit clone https://github.com/RE-TikaRa/FileLocksmith.git\n\n界面预览首页\n设置页\n关于页\n功能概览\n右键菜单：快速定位占用文件&#x2F;文件夹的进程并处理\n扫描界面：展示占用进程、文件列表，可结束进程\n管理主界面：统一管理注册状态与显示方式\n支持“仅扩展菜单显示”（Win11“显示更多选项”）\n支持提升权限完成注册&#x2F;卸载与系统进程查看\n\n运行方式\n直接运行：启动管理主界面\n从右键菜单启动：进入扫描&#x2F;解锁界面\nCLI：FileLocksmithCLI.exe\n\n依赖说明\n本项目已尽量对关键依赖进行本地化与版本固定，以降低外部环境变化带来的不确定性。但由于 Windows SDK、运行库与系统环境差异较大，仍可能出现未覆盖的构建或运行问题。本地化范围主要包含仓库内置的 C++ 依赖（如 deps/spdlog、deps/expected-lite）以及明确的 NuGet 版本锁定。仍需在线还原的依赖以 Directory.Packages.props&#x2F;packages.config 为准。如遇异常，请提交 issue 并附上系统版本、构建日志或崩溃日志，便于定位与完善。\n\n构建环境\n\nWindows 11 + Visual Studio 2022（Build Tools 或 Professional，含 C++ 工具集与 MSBuild）\n.NET SDK 9（TargetFramework: net9.0-windows10.0.26100.0）\nWindows 11 SDK（WindowsSdkPackageVersion: 10.0.26100.68-preview）\nPowerShell 5+（便携包脚本）\n\n核心依赖（NuGet&#x2F;源码）\n\nWindows App SDK 1.8.251106002\nC#&#x2F;WinRT Microsoft.Windows.CsWinRT 2.2.0\nC++&#x2F;WinRT Microsoft.Windows.CppWinRT 2.0.240111.5\nWIL Microsoft.Windows.ImplementationLibrary 1.0.231216.1\nUI 组件：CommunityToolkit.WinUI.*、WinUIEx\nC++ 依赖（仓库内置）：deps/spdlog、deps/expected-lite\n\n运行时依赖\n\nWindows App SDK Runtime（便携包内会自带）\nVC++ 运行库（便携包脚本会尝试复制）\nWebView2 Runtime（WinUI WebView2）\n\n配置与数据位置（独立路径）根目录%LocalAppData%\\\\ALp_Studio\\\\FileLocksmith\n设置文件file-locksmith-settings.json\n\nEnabled：是否启用\nshowInExtendedContextMenu：仅扩展菜单显示\n\n运行数据last-run.log：上次选择路径列表（UTF-16 + 换行，空行终止）\n日志\n\nLogs\\\\log.log（原生日志）\nLogs\\\\Log_YYYY-MM-DD.log（托管日志）\n不再使用版本子目录，历史的 Logs\\\\&lt;版本&gt; 可删除。\n\n\n\n组策略（GPO）管理员可通过策略强制启用&#x2F;禁用：\nHKLM\\\\Software\\\\Policies\\\\FileLocksmith\n\nEnabled（DWORD）：1 启用，0 禁用若存在该键值，将覆盖本地设置。\n\n注册表标记（状态）用于记录右键菜单注册状态（脚本写入）：\nHKCU\\\\Software\\\\FileLocksmith\n\nContextMenuRegistered（DWORD）\n\nCLI 使用FileLocksmithCLI.exe [选项] &lt;路径1&gt; [路径2] ...选项:  --kill      结束占用文件的进程  --json      以 JSON 格式输出结果  --wait      等待文件解锁  --timeout   --wait 的超时（毫秒）  --help      显示帮助\n\n结构速览\nsrc/modules/FileLocksmith/FileLocksmithUI\n管理主界面与 WinUI 视图\n\n\nsrc/modules/FileLocksmith/FileLocksmithContextMenu\n右键菜单（Win11）\n\n\nsrc/modules/FileLocksmith/FileLocksmithExt\n右键菜单（经典）\n\n\nsrc/modules/FileLocksmith/FileLocksmithLib\n原生核心逻辑（句柄枚举&#x2F;扫描）\n\n\nsrc/modules/FileLocksmith/FileLocksmithLibInterop\n原生互操作层（WinRT）\n\n\nsrc/modules/FileLocksmith/FileLocksmithCLI\n命令行与单元测试\n\n\ntools/FileLocksmithPortable\n便携版打包脚本\n\n\n\n构建与打包项目使用 WinUI 3 + Windows App SDK（.NET 9 目标）。\n输出目录\n\nUI：x64/Release/WinUI3Apps\nCLI：x64/Release/FileLocksmithCLI.exe\n便携包（自带依赖）：artifacts/FileLocksmith Portable version/x64/Release\n便携包（系统依赖）：artifacts/FileLocksmith System dependency versions/x64/Release\n\n快捷脚本\n\n仅构建 UI：build_project.bat\n构建 + 便携版打包：build_and_pack.bat（输出 Portable&#x2F;System 两个版本）\n\n清理缓存（推荐在重新构建前执行）\n\n删除 x64/\n删除 artifacts/FileLocksmith Portable version/\n删除 artifacts/FileLocksmith System dependency versions/\n删除 src/**/bin 与 src/**/obj\n删除旧版日志子目录 Logs\\\\&lt;版本&gt;（如果仍存在）\n\n构建 UI（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithUI/FileLocksmithUI.csproj /restore /p:Configuration=Release /p:Platform=x64 /p:RunAnalyzers=false /p:RunCodeAnalysis=false /p:EnableNETAnalyzers=false /p:EnforceCodeStyleInBuild=false /p:TreatWarningsAsErrors=false\n\n构建 CLI（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithCLI/FileLocksmithCLI.vcxproj /p:Configuration=Release /p:Platform=x64\n\n构建原生组件（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithLib/FileLocksmithLib.vcxproj /p:Configuration=Release /p:Platform=x64&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithLibInterop/FileLocksmithLibInterop.vcxproj /p:Configuration=Release /p:Platform=x64\n\n构建右键菜单组件（Release x64）\n&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithContextMenu/FileLocksmithContextMenu.vcxproj /p:Configuration=Release /p:Platform=x64&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\MSBuild\\\\Current\\\\Bin\\\\MSBuild.exe&quot; src/modules/FileLocksmith/FileLocksmithExt/FileLocksmithExt.vcxproj /p:Configuration=Release /p:Platform=x64\n\nCLI 与原生项目（可选）\n\n使用 Visual Studio 2022 打开对应 .vcxproj，选择 x64 构建。\n\n便携包powershell -ExecutionPolicy Bypass -File tools\\\\FileLocksmithPortable\\\\pack.ps1 -Platform x64 -Configuration Release -Mode Portablepowershell -ExecutionPolicy Bypass -File tools\\\\FileLocksmithPortable\\\\pack.ps1 -Platform x64 -Configuration Release -Mode System\n\n便携版构建&#x2F;打包常见问题\n\n输出目录为空：pack.ps1 依赖 x64/Release/WinUI3Apps。请先构建 UI，再打包。\nSystem 模式找不到 WinUI3Apps.System：请先执行 build_and_pack.bat 或用相同参数构建 System 版本 UI。\n便携版点击关于&#x2F;设置闪退（MUI 资源缺失）：若输出目录缺少 FileLocksmithXAML、Assets 或语言目录（如 zh-CN），WinUI 资源加载会崩溃。pack.ps1 已改为复制 WinUI3Apps 下所有子目录，若仍异常请重新构建并打包。\nSystem dependency versions 启动失败：请确认系统已安装 Windows App SDK Runtime、VC++ 运行库与 WebView2 Runtime。\n\n其他文档\ntools/FileLocksmithPortable/README.md：便携版打包与使用说明\nsrc/common/Telemetry/README.md：Telemetry 采集说明（排查&#x2F;性能）\nsrc/common/CalculatorEngineCommon/README.md：exprtk 封装说明（共享库）\ndeps/spdlog/README.md：第三方日志依赖说明\n同目录下 *.Original.md 为上游&#x2F;历史说明备份（PowerToys 官方说明）\n\n作者与信息\n创建日期：2026-01-29\n制作者：亓翎_Re-TikaRa\n网站：https://re-tikara.fun\n\n许可本项目遵循 PowerToys 仓库的原始许可，即 MIT 许可，详见仓库根目录 LICENSE。\n免责声明本项目为开源研究与学习用途的软件分支，按“现状”提供，不对适用性、稳定性或特定用途做任何保证。使用本项目进行文件占用解除、进程终止、右键菜单注册&#x2F;卸载等操作可能影响系统或数据，请自行确认风险并对操作结果负责。\n","categories":["Project"],"tags":["project"]},{"url":"/Blog/posts/0/","content":"DesktopTimer | 桌面计时器\n   \n      \n   \n   \n      \n   \n   \n      \n   \n   \n      \n   \n   \n      \n   \n\n\n\n\n   \n\n\nDesktopTimer | 桌面计时器\n\n\n基于 PyQt6 的轻量级桌面计时器，支持正计时/倒计时/时钟模式，系统托盘、快捷键、音效与闪烁提醒、多语言（中/英）以及丰富的外观自定义；\n\n\n\n\n  下载最新版本 •\n  查看源码 •\n  报告 Bug •\n  提出新特性\n\n\n\n本 README 同时面向“用户”和“开发者”，上来就想用的看“快速开始”，想参与开发的看“开发者指南”。\n\n\n🚀 快速开始（用户）\n支持系统：Windows 10&#x2F;11（x64）\n推荐环境：Python 3.13（仅源码运行需用到），普通用户可直接使用安装包或便携版\n\n\n安装程序（建议）\n\n\n前往 Releases 下载 DesktopTimer-Setup.exe\n双击安装，按向导完成；从开始菜单或桌面快捷方式启动\n\n\n便携版\n\n\n下载 DesktopTimer.zip → 解压 → 直接运行 DesktopTimer.exe\n\n\n从源码运行（开发者）\n\n\n克隆仓库并安装依赖后运行 main.py（见下文“开发者指南”）\n\n\n✨ 功能一览\n⏰ 三种计时：正计时、倒计时、时钟（12&#x2F;24 小时制、可选“秒&#x2F;日期”）\n🔔 提醒方式：自定义音效（可调音量）、系统 Beep、窗口闪烁、托盘气泡、Windows 通知（可开关）\n🌐 双语言：中文 &#x2F; English 一键切换\n🎯 预设管理：设置页支持自定义&#x2F;排序&#x2F;搜索&#x2F;多选删除倒计时预设，排序方式可记忆，可为中&#x2F;英文界面分别命名并同步托盘快捷菜单\n🎨 外观：字体&#x2F;字号、颜色、圆角、透明度、夜读模式、窗口尺寸、主题（浅&#x2F;深&#x2F;跟随系统）\n🧰 系统托盘：暂停&#x2F;继续、重置、模式切换、倒计时预设（含自定义单次输入）、显示&#x2F;隐藏、锁定&#x2F;解锁、打开设置、退出\n🔒 窗口锁定：固定位置并可启用“点击穿透”\n⌨️ 快捷键：常用操作一键直达\n🖥️ 全屏模式：F11 一键切换，简拍&#x2F;展示更方便\n\n\n🧭 使用说明（核心操作）\n设置倒计时：在设置页输入小时&#x2F;分钟&#x2F;秒，或托盘菜单选择预设&#x2F;自定义单次倒计时\n开始&#x2F;暂停&#x2F;继续：托盘菜单或快捷键 Ctrl+Space；也可在设置中启用“启动自动开始”\n重置计时：托盘菜单或快捷键 Ctrl+R\n窗口锁定：托盘菜单或 Ctrl+L（锁定后支持点击穿透）\n切换模式：设置页或托盘“模式切换”菜单\n显示&#x2F;隐藏：托盘菜单或 Ctrl+H\n配置保存：所有设置自动保存至 settings/timer_settings.json\n\n⌨️ 快捷键\n\n\n快捷键\n功能\n\n\n\nCtrl+Space\n暂停&#x2F;继续\n\n\nCtrl+R\n重置\n\n\nCtrl+H\n显示&#x2F;隐藏窗口\n\n\nCtrl+L\n锁定&#x2F;解锁窗口\n\n\nCtrl+,\n打开设置\n\n\nF11\n全屏&#x2F;退出全屏\n\n\n\n🛠️ 开发者指南开发环境要求\nPython 3.13\nWindows 10&#x2F;11\n依赖管理：UV\n注：如需 Qt Designer 等工具，可另行安装 pyqt6-tools（与项目运行依赖无关）。\n\n\n\n源码运行# 克隆与进入目录git clone https://github.com/RE-TikaRa/DesktopTimer.gitcd DesktopTimer# 安装依赖uv sync# 运行uv run python main.py# 如需调试日志，可在运行前设置环境变量# PowerShell$env:DESKTOPTIMER_DEBUG=1# CMDset DESKTOPTIMER_DEBUG=1\n\n打包为可执行文件# 打包需要安装开发依赖uv sync --devuv run python -m PyInstaller DesktopTimer.spec --noconfirm\n打包完成后生成 dist/DesktopTimer.exe。请将 img/、lang/、sounds/ 一并放入 dist/ 目录。\n也可直接使用内置脚本一键完成清理、打包、复制资源与压缩：\ntools\\pyinstaller.bat\n\n文件结构DesktopTimer/├── main.py           # 程序入口├── /module/          # 拆分逻辑（app/窗口/配置等）│   ├── __init__.py│   ├── app.py│   ├── constants.py│   ├── localization.py│   ├── paths.py│   ├── settings_dialog.py│   └── timer_window.py├── DesktopTimer.spec          # PyInstaller 配置├── pyproject.toml             # UV 项目配置├── uv.lock                    # UV 锁文件├── requirements.txt           # Python 依赖（历史/兼容）├── README.md                  # 项目说明├── tools/                     # 构建/打包脚本├── /img/                      # 图标资源│   ├── timer_icon.ico│   └── ALP_STUDIO-logo-full.svg├── /lang/                     # 语言包│   ├── zh_CN.json│   └── en_US.json├── /sounds/                   # 提醒音├── /settings/                 # 用户运行时配置│   └── timer_settings.json├── /build/                    # 临时构建文件└── /dist/                     # 打包输出\n\n架构与实现要点\ni18n：多语言加载（lang&#x2F;*.json）\nSettingsDialog：设置对话框（外观&#x2F;模式&#x2F;预设&#x2F;通用&#x2F;关于）\nTimerWindow：主窗口&#x2F;计时&#x2F;托盘&#x2F;提醒&#x2F;快捷键（含模式切换菜单、倒计时预设与自定义单次输入）\n路径管理：自动识别开发&#x2F;打包环境，动态定位资源\n配置管理：JSON 持久化，包含版本兼容处理\n\n要点：使用 sys.frozen 识别打包环境；相对路径存储确保可移植；QTimer&#x2F;QMediaPlayer&#x2F;QSystemTrayIcon 组合\n\n📦 打包与发布\n使用 DesktopTimer.spec 进行 onefile 打包，输出 dist/DesktopTimer.exe\n将 img/、lang/、sounds/ 复制到 dist/ 下，确保资源可用\n可使用 Inno Setup 生成安装程序（参考 setup/SetUp.iss）\n\n\n❓ 常见问题（FAQ）\n打包后没有声音&#x2F;语言不生效？\n\n请确认已将 img/、lang/、sounds/ 整个目录复制到 dist/。\n\n\n托盘图标不显示&#x2F;找不到？\n\n检查系统托盘的“隐藏的图标”区域；确保 Explorer 正常；程序最小化到托盘时可通过 Ctrl+H 显示&#x2F;隐藏。\n\n\n锁定后无法操作窗口怎么办？\n\n使用快捷键 Ctrl+L 解锁，或通过系统托盘菜单解锁。\n\n\n源码运行报依赖错误？\n\n重新执行 uv sync，确保网络正常。\n若提示 Python 版本不匹配，请确认项目使用 Python 3.13。\n\n\n打包后资源路径异常？\n\n本项目已兼容 sys.frozen 场景；若自定义了运行目录，请保持资源与可执行文件同级。\n\n\nDesktopTimer.egg-info/ 是什么？\n\n这是 setuptools 构建产生的元数据目录，可在发布包或清理时忽略&#x2F;删除。\n\n\n切换语言后界面没变化？\n\n语言下拉框一旦切换就会立即应用到主窗口与托盘；若仍看到旧语言，可确认设置文件是否可写或查看日志输出。\n\n\n\n\n🧭 开发路线图✅ 已完成功能\n正计时&#x2F;倒计时&#x2F;时钟三种模式\n系统托盘常驻与快捷操作\n多种提醒方式（音效&#x2F;闪烁&#x2F;通知）\n中英文双语支持\n外观完全自定义\n快捷键支持\n番茄钟快捷预设\n窗口锁定功能（位置固定 + 点击穿透）\n快捷键自定义\n托盘模式切换与即席自定义倒计时\n预设支持中英文双描述，可在创建时同步填写\n\n📌 计划中的功能\n结束提醒增强：音量、循环次数、渐入渐出；播放列表&#x2F;多音频轮播\nWindows 原生通知按钮（如“再来 5 分钟”“停止”）\n托盘与主题：暗&#x2F;亮主题托盘图标，自定义图标包\n设置管理：设置导出&#x2F;导入备份，一键恢复默认\n自动更新：检查 Releases 新版本并提示下载\n开机自启动（用户可选）\n多语言扩展：支持更多语言（日文、韩文等）\n可视化窗口滑块：为字体&#x2F;窗口大小提供滑块+“恢复默认”按钮，并显示实时数值\n全屏专用主题：进入全屏时可使用独立的背景&#x2F;文字&#x2F;透明度样式\n自定义快捷预设：允许用户在设置中增删 Pomodoro 预设并同步到托盘&#x2F;右键菜单\n配置导入&#x2F;导出：一键备份或应用 settings/*.json，方便在不同设备间迁移\n预设导入&#x2F;导出能力（JSON 备份&#x2F;恢复）\n预设列表排序、搜索或分组功能\n语言切换提示（关闭设置前提醒“需点击应用&#x2F;确定”）\n设置中添加调试日志开关（无需依赖环境变量）\n更易用的预设多语言编辑视图（统一列表，可批量维护）\n替换 win10toast 或移除其中的 pkg_resources 依赖以适配未来环境\n\n\n🧩 使用到的技术栈\nPyQt6 - GUI 框架\nPyQt6-Fluent-Widgets - Fluent 风格组件库（设置页 UI）\nPyInstaller - 打包工具\nwin10toast - Windows 通知（可选）\nInno Setup - 安装程序制作\n\n\n🤝 贡献指南欢迎通过 Issues 或 Pull Requests 参与贡献！\n如何参与开源项目\nFork 本仓库\n新建分支：git checkout -b feature/your-feature\n提交改动：git commit -m &quot;feat: your message&quot;\n推送分支：git push origin feature/your-feature\n发起 Pull Request\n\n\n🔖 版本控制项目使用 Git 管理版本；发布版本在 Releases&#x2F;Tags 标注。\n\n👤 作者TikaRa📧 邮箱：163mail@re-TikaRa.fun🌐 个人网站：https://re-tikara.fun🐙 GitHub：https://github.com/RE-TikaRa/DesktopTimer📺 B 站主页：https://space.bilibili.com/374412219\n\n📄 版权说明本项目采用 GNU GPL v3 或更高版本。\n允许：自由使用、修改与再发布（包含商用），需保留版权与许可声明，并在发布衍生作品时继续采用 GPL v3 或更高版本。\n要求：发布二进制时需同时提供对应源码；不得移除许可证文本。\n完整条款参见仓库中的 LICENSE 文件。\n\n🙏 鸣谢\nPyQt6 - 提供强大的 GUI 框架\nPyInstaller - Python 打包为可执行文件\nQt - 跨平台 GUI 框架\nInno Setup - Windows 安装程序制作工具\nShields.io - 项目徽章\nGitHub Pages - 文档托管\n\n","categories":["Project"]},{"url":"/Blog/posts/0/","content":"第一章 前言第一章的内容，我们先来了解一下C语言基础。想象一下，计算机就像个超级听话的机器人，它能按照我们写的指令一步步完成任务。这就是程序设计最核心的道理。\n程序是怎么来的？第一节会带咱们穿越时空，看看程序设计是怎么从0和1的二进制代码，慢慢变成现在咱们熟悉的C语言这种高级语言的。就像看老照片一样有趣！\n举个栗子🌰：\n#include &lt;stdio.h&gt;int main() &#123;    printf(&quot;程序就是这么简单！\\n&quot;);    return 0;&#125;\n\n算法的秘密第二节要讲的算法，其实就是解决问题的套路。比如做菜要按步骤来，先切菜再下锅。算法也有几个特点：\n\n必须能在有限步骤内完成（别无限循环啊）\n每个步骤要明确不含糊\n能通过简单操作实现\n可能需要输入数据\n最重要的是要有输出结果\n\n举个简单算法🌰：\n计算1+2的步骤：1. 准备纸笔（初始化）2. 写下13. 加上24. 得到结果3\n\n编程三大招式第三节教咱们三个基本功：\n\n顺序招：像排队买奶茶，一个接一个按顺序执行\n选择变招：遇到岔路口，根据条件选不同路线（后续章节重点）\n循环连招：重复执行直到满足条件（后续章节重点）\n\n学完这章，你会对编程有个全景图式的认识。别担心，跟着我们一起探索，你会慢慢发现编程的乐趣！\n"},{"title":"置顶公告","url":"/Blog/posts/25ad5f96/","content":"关于新版本网站的公告（其实是笨蛋亓翎的谢罪函）大家好，这里跟大家说明一下网站的新版本情况。\n因为之前亓翎在整理&#x2F;维护网站时不小心把网站的原始结构数据整个误删了，导致旧版本的数据出现了比较大的缺口。现在手头能留下来的内容，主要是一些零散的存档（并不是完整站点），还有就是Hexo的生成文件，很多页面之间的关联、分类、时间线、链接结构之类的信息都丢失了。也正因为这样，旧版想要“一键恢复”基本不现实，要恢复的话只能靠后续一点点整理、核对、重建，工作量和难度都会比较高。\n考虑到网站不能一直停着不更新，也不想让大家一直看到缺内容、打不开的页面，所以我决定把网站直接重构，先把新版本的框架搭起来。新版本会以更清晰、也更好维护的方式重新整理结构，这样后面更新内容、修复问题、补充功能都会更顺手，也能减少类似情况再次发生的概率。\n关于大家比较关心的“以前的文章还会不会回来”：会的，但可能需要时间。我会根据现有存档的情况，优先把能确定内容完整、整理成本相对低的文章先恢复出来；剩下比较零碎、需要补齐信息或重新排版的内容，会在后续慢慢补。恢复进度可能不会特别快，但会持续推进。也就是说，旧内容不是“没了”，而是需要一个逐步找回、逐步整理的过程。\n这次的情况给大家带来不便真的很抱歉，也谢谢大家一直以来的理解和支持。如果你发现新版本里有链接失效、排版问题，或者你记得某篇旧文但现在找不到，也欢迎提醒我（有线索会更好，比如标题、关键词、发布时间大概范围等），我会尽量安排处理。\n总之：新版本先保证稳定可用，旧内容会陆续回归。谢谢大家，敬请期待后续更新。（我这次也是对内容做了原始数据的备份，长教训了）\n","categories":["Announcement"],"tags":["Announcement"]},{"url":"/Blog/posts/0/","content":"一、程序&emsp;&emsp; 什么是程序？人们常说，我们仿佛是上帝创造的 NPC，只会机械的重复着毫无意义的动作, 毫无思想的执行着一条条预设的指令，完成衬托着那些主角的成功。同样的，人们把需要用计算机完成的工作写成一条条指令，并把这些指令存储在预定的内存中，当人们给出执行命令后，计算机就按指令顺序自动进行操作。这些可以连续执行的一条条指令的集合称为“程序”。\n\n二、程序设计语言的发展2.1 机器语言&emsp;&emsp; 一切的开始，都是 0 与 1 的交汇。因为组成电子逻辑的电门仅有通过和不通过两种判断。于是人们将计算机的运算用 01 来编写，自此，将 100110011101 这种专门让机器执行的指令码叫做机器语言。\n2.2 汇编语言&emsp;&emsp; 在编写程序时，人脑作为仅有 10 bit &#x2F;s 交换流的低数据流单线程的处理器，当然没办法记下数量庞大的 01 字符串来执行类似于相加相减等操作，别说更复杂的的运算。所以汇编语言便应运而生。用助记符来代表系统指令与计算机硬件直接交互，比如，相加我们用 ADD 来表示相加等等。\n2.3 高级语言&emsp;&emsp; 高级语言分为两大部分，第一部分时面向对象，第二部分是面向过程。高级语言是比汇编语言更抽象的存在，其在思维逻辑上，与机器语言和汇编语言更符合人类的思维方式。同时它可以将开发者的思维聚焦到具体问题的软件逻辑而非协调底层硬件。高级语言更接近人类语言，通常使用词法和语法结构，使程序更易读、更易写。高级语言通过编译器或解释器转换为机器码，让计算机能够理解并执行这些指令。\n2.3.1 面向对象语言&emsp;&emsp; 面向对象语言这一块更偏向于让谁来完成工作，类比于团队合作，面向对象语言关注于把一件事情下分给各个部门，然后各个部门协同完成一件工作。其中代表语言如 Python，Java 等。\n2.3.2 面向过程语言&emsp;&emsp; 面向过程语言更偏向于步骤，像是写教程，第一步要干什么，第二步要干什么，将一份工作拆分为一块一块，分步完成。\n2.3.3 两种面向的区别&emsp;&emsp; 总而言之，面向过程是 「怎么做」，面向对象是 「谁来做」 。就像单独旅行 vs 跟团游，一个要自己安排所有步骤，一个把任务分配给导游&#x2F;司机&#x2F;酒店各司其职。\n2.4 三种语言的区别&emsp;&emsp; 其中机器语言和汇编语言更偏向于让机器读，人的理解比较低，而高级语言则更偏向让人理解，机器的部分由编译器等等来执行\n\n三、程序间的转换&emsp;&emsp; 我们的高级语言通过编译才能转化为机器语言，而汇编语言需用通过汇编才可以转为机器语言。&emsp;&emsp; 通常情况下，我们的源程序，如件.c文件，. cpp 文需要先编译为. obj文件，然后链接各种库，最后封装才能成为一个可执行文件. exe。其中. obj 文件和. exe 文件都是二进制文件。&emsp;&emsp;需要注意的是，.obj和.exe虽然都是二进制文件，但是可以直接运行的仅有.exe，.obj文件是编译后的目标文件，需要通过链接器（linker）与其他目标文件或库文件链接，生成最终的可执行文件（如 .Exe），才能在操作系统上运行。&emsp;&emsp;然后，在编译过程中，像是注释之类的非执行语句，会被编译器直接跳过，不会被转换为二进制语句，而只有二进制语句才会被转换为二进制的机器指令。&emsp;&emsp; C语言程序有两种执行方式，分别是编译执行和解释执行。这个有关于机器的不过多解释。\n\n本小节总结一、程序的定义程序本质\n由一系列可连续执行的指令组成，存储在内存中，计算机按顺序自动执行这些指令完成特定任务。\n\n\n二、程序设计语言的发展2.1 机器语言\n特点：  \n由二进制代码（0 和 1）直接编写，是计算机唯一能直接执行的指令。\n示例：100110011101。\n\n\n局限性：  \n对人类极不友好，难以记忆和编写复杂逻辑。\n\n\n\n2.2 汇编语言\n特点：  \n用助记符（如 ADD 表示相加）代替机器指令，与硬件直接交互。\n示例：MOV AX, BX。\n\n\n优势：  \n比机器语言更易读，但仍依赖硬件知识。\n\n\n\n2.3 高级语言\n核心特点：  \n抽象层次高，接近人类自然语言，聚焦问题逻辑而非硬件细节。\n需通过编译器或解释器转换为机器码。\n\n\n分类：  \n面向对象语言（如 Java、Python）：  \n关注“谁来做”，将任务分配给不同对象协作完成（类似团队分工）。\n\n\n面向过程语言（如 C）：  \n关注“怎么做”，按步骤拆解任务（类似写教程分步操作）。\n\n\n\n\n与底层语言的区别：  \n机器&#x2F;汇编语言：机器易读，人类难理解。\n高级语言：人类易读写，机器需编译后执行。\n\n\n\n\n三、程序间的转换编译流程\n高级语言 → 机器语言：源文件（如 .c）→ 编译器 → 目标文件（.obj）→ 链接库文件 → 可执行文件（.exe）。\n\n文件类型说明\n.obj 和 .exe 均为二进制文件，机器仅可直接执行.exe。\n\n\n四、核心对比总结\n\n\n语言类型\n特点\n示例指令\n适用场景\n\n\n\n机器语言\n二进制代码，机器直接执行\n10101010\n底层硬件操作\n\n\n汇编语言\n助记符替代机器指令\nADD AX, BX\n硬件驱动、性能优化\n\n\n高级语言\n人类易读写，需编译后执行\nprint(&quot;Hello&quot;)\n软件开发、复杂逻辑实现\n\n\n"},{"url":"/Blog/posts/0/","content":"无返回值的调用形式函数名(实际参数列表) ; // 分号是必不可少的\n\n函数调用执行流程&emsp;&emsp;其实与有返回值的调用形式一样，只是最后没有“return(表达式)”\n"},{"url":"/Blog/posts/0/","content":"一、什么是算法？&emsp;&emsp; 说到算法，比较陌生。那要是说起解题思路，会不会比较好理解一点？假设。我们此时有一个，十分明确的题目，我们脑海中自然会产生第一步，第二步，第三步……以此类推的一个整体有限的解题步骤。此时这些解题步骤就可以被称作算法。这时你应该就可以想到，算法实质上就是为了解决某个特定问题而采取的确定且有限的步骤。\n二、算法的特性\n有穷性：一个算法包含的步骤是有限的。即在若干个步骤后结束，并且每一步都在合理时间内完成\n确定性：算法中每一条指令必须有确切的含义，不能有二义性，对于相同的输入必能得出相同的执行结果。\n可行性：算法中指定的操作，都可以通过已经验证可以实现的基本运算执行有限次后实现。\n必须有零个或多个输入：算法都是用来处理数据对象的，通常情况下这些数据对象需要通过输入来得到。\n必须有一个或多个输出：算法的目的是为了求解。这些“解”只有通过输出得到。\n\n三、如何评价算法&emsp;&emsp; 对于算法一般有如下几个要求：\n\n必须正确\n必须高效（即占用内存空间少，所需运行时间短）\n\n&emsp;&emsp; 于是便有了如下两个维度：\n\n时间复杂度\n空间复杂度\n\n"},{"url":"/Blog/posts/0/","content":"一、三大模块化结构&emsp;&emsp; 在 C 语言中，我们主要学习使用如下几种结构：\n1. 顺序结构&emsp;&emsp;像是正常步骤说明一样，一条一条，一步一步执行，没有分支，没有转移的结构。结构如下：\n2. 选择结构选择其实就是根据不同的条件执行不同分支下的语句，执行后将结果继续向下或者跳出。\n3. 循环结构&emsp;&emsp; 循环结构和选择结构不一样的是，循环结构当条件为真时进入循环，一直到条件不成立。用选择结构写循环结构相当于好多层嵌套。\n二、模块化结构&emsp;&emsp;模块化结构就象是我们第一节讲过的面向对象语言，将任务按照各个部门所擅长的职能拆分下去，然后各部门按照团队擅长的部分继续拆分，团队按照成员继续拆分，直到拆分成每个任务都可以由每个人超级简单的完成。此时这些完成任务的单位个体的人就是一个个模块，用很多小小的简单的模块整体协调完成整个任务这种做法就是模块化方法，由一个个功能模块构成的程序结构为模块化结构。\n"},{"url":"/Blog/posts/0/","content":"有返回值函数的调用形式函数名 （实际参数列表）\n&emsp;&emsp;    调用的结果是获得一个返回值，该返回值可以参加相应类型的计算。\n函数调用的过程\n首先为被调用函数的所有形参分配内存，再计算实际参数的值，再一一对应地赋给相应的形参（对于无参函数，不做这项工作）。\n然后进行函数体，为函数说明部分定义的变量分配存储空间，再依次执行函数体中的可执行语句。\n当执行到return语句时，计算返回值，收回本函数中定义的变量所占用的存储空间，对于static类型的变量，其空间不收回），返回主调函数继续执行。\n\n函数调用的语法要求\n调用函数时，函数名必须与所调用的函数名字完全一致。\n实参的个数必须与形参一致。\nC语言规定，函数必须先定义后调用。\n\n"},{"url":"/Blog/posts/0/","content":"数据传递的三种方式\n实参和形参之间的数据传递\n值传递方式\n方式：函数调用时,为形参分配单元,并将实参的值复制到形参中；调用结束，形参单元被释放，实参单元仍保留并维持原值\n特点：\n形参与实参占用不同的内存单元\n单向传递，即用户不可能在函数中改变对应实参的值\n\n\n\n\n\n\n通过return语句把函数值返回调用函数\n通过全局变量。（不提倡）\n\n\n形参和实参\n形式参数：定义函数时函数名后面括号中的变量名\n实际参数：调用函数时函数名后面括号中的表达式\n\n说明：\n实参必须有确定的值\n\n形参必须指定类型\n\n形参与实参类型一致，个数相同\n\n若形参与实参类型不一致，自动按形参类型转换———函数调用转换\n\n形参在函数被调用前不占内存;函数调用时为形参分配内存；调用结束，内存释放\n\n\n\n地址传递方式&emsp;&emsp;函数调用时，将数据的存储地址作为参数传递给形参。\n特点\n形参与实参占用同样的存储单元\n“双向”传递\n实参和形参必须是地址常量或变量\n\n"},{"url":"/Blog/posts/0/","content":"赋值语句&emsp;&emsp;在赋值表达式的尾部加上一个“；”，又称为表达式语句。如下：\n\na&#x3D;b+c；–i；i++；a&#x3D;b&#x3D;c；a&#x3D;b,b&#x3D;c；\n\n\n考点\n赋值语句必须在最后出现分号，分号是语句中必不可少的部分。（就像是你有手机却没有电）\n任何赋值表达式都可以加上分号而成为赋值语句，C语言规定赋值号左边不能为常量或者表达式。\n\n"},{"url":"/Blog/posts/0/","content":"递归调用的定义&emsp;&emsp;函数直接或间接的调用自身叫函数的递归调用。\n示例#include &lt;stdio.h&gt;// 递归函数：计算n的阶乘int factorial(int n) &#123;    // 终止条件：当n为0或1时直接返回1    if (n == 0 || n == 1) &#123;        return 1;  // 基本情况：0! = 1! = 1    &#125; else &#123;        // 递归调用：n! = n * (n-1)!        // 程序执行路径分解（以n=3为例）：        // 1. factorial(3) -&gt; 3 * factorial(2)        // 2. factorial(2) -&gt; 2 * factorial(1)        // 3. factorial(1) -&gt; 返回1（触发终止条件）        // 4. 回溯计算：2*1=2 -&gt; 3*2=6        return n * factorial(n - 1);    &#125;&#125;int main() &#123;    int num = 5;  // 设置输入数值        // 调用递归函数并输出结果    // 执行过程分解：    // factorial(5) -&gt; 5 * factorial(4)    //              -&gt; 5 * 4 * factorial(3)    //              -&gt; 5 * 4 * 3 * factorial(2)    //              -&gt; 5 * 4 * 3 * 2 * factorial(1)    //              -&gt; 5 * 4 * 3 * 2 * 1 = 120    printf(&quot;Factorial of %d is %d\\n&quot;, num, factorial(num));        return 0;&#125;\n流程展示流程展示\n几点说明\nC编译系统对递归函数的自调用次数没有限制\n每调用函数一次，在内存堆栈区分配空间，用于存放函数变量、返回值等信息，所以递归次数过多，可能引起堆栈溢出\n\n"},{"url":"/Blog/posts/0/","content":"第七章 函数之法——编程的模块化之道核心能力修炼：掌握三大函数秘术通过本章修炼，你将获得：\n\n破解函数定义的”魔法盒咒语”\n掌握参数传递的”数据桥梁”\n领悟返回值的”结果通道”\n参悟函数声明的”契约精神”\n驯服递归调用的”分形秘法”\n\n知识脉络一、函数三要素\n定义仪式：函数名+参数列表+函数体的三位一体\n参数传递：形参如门户，实参似信使的数据流通法则\n返回机制：结果输出的单行道（return语句的玄机）\n\n二、控制玄机\n作用域法则：局部变量的城堡与全局变量的王国\n递归分形：俄罗斯套娃般的自我调用艺术\n声明契约：头文件中的函数宣言\n\n三、实战应用场\n代码复用：一次编写，四处调用的魔法\n模块拆分：将大问题分解为小函数的庖丁解牛术\n库函数调用：善用标准库的瑞士军刀\n调试隔离：通过函数模块定位问题的探针法\n\n修炼心法&emsp;&emsp;建议用”黑箱思维”观察函数功能，重点参悟参数传递的值拷贝特性。特别注意函数设计的单一职责原则，警惕函数膨胀症。善用注释标注函数功能，调试时可采用printf探针法逐层验证。递归调用需把握基准情形和递归步进两个关键要素。\n"},{"title":"Certificate-Management","url":"/Blog/posts/6c20921f/","content":"\n  \n  荣誉证书管理系统\n  \n    一款功能完整、界面精美的荣誉证书管理桌面应用。\n    支持荣誉证书的全生命周期管理：从录入、统计分析、成员管理到附件管理，一应俱全。\n    当前版本： v1.4.0（2025-12-18）\n  \n\n\n\n\n\n  📖 目录导航 (点击展开)\n\n\n✨ 核心特性\n🎯 功能详情\n\n\n🛠️ 技术栈\n📸 界面预览\n🚀 快速开始\n📥 安装步骤\n🛠️ 常用命令\n🧾 AI 证书识别\n⚙️ 配置与模型\n🧾 使用流程\n\n\n📥 导入 &#x2F; 导出（CSV&#x2F;XLSX）\n🤖 MCP 接入（本地）\n🔌 连接方式\n🛡️ 权限与安全\n🛠️ 能力概览\n⚙️ 常用环境变量\n\n\n\n\n📂 文件目录说明\n🏗️ 项目架构\n💾 数据模型\n🏆 荣誉记录 (Awards)\n🧩 荣誉成员快照 (AwardMembers)\n👤 参与成员 (TeamMembers)\n🤖 AI 提供商 (AIProviders)\n🏷️ 自定义开关 (CustomFlags&#x2F;AwardFlagValues)\n🎓 专业与学校 (Majors&#x2F;Schools)\n\n\n🔐 数据安全与备份\n🎨 主题系统\n🛠️ 开发指南\n🧰 故障排查\n📝 更新日志\nv1.4.0 (2025-12-18)\nv1.3.1 (2025-12-17)\nv1.3.0 (2025-12-16)\nv1.2.0 (2025-12-14)\nv1.1.0 (2025-12-09 ~ 2025-12-10)\nv1.0.1 (2025-12-04 ~ 2025-12-07)\nv1.0.0 (2025-12-02 ~ 2025-12-03)\n\n\n📈 Star History\n🤝 如何贡献\n📄 许可证\n\n\n\n\n✨ 核心特性\n  \n    \n      \n        ⚡ 极速检索\n        500ms 防抖全文检索FTS5 引擎加持\n      \n      \n        📊 数据可视化\n        8 张动态指标卡图表实时联动\n      \n      \n        🧭 丝滑体验\n        页面异步懒加载启动速度飞快\n      \n      \n        🛡️ 数据安全\n        本地 SQLite 存储自动定时备份\n      \n    \n    \n      \n        🧠 智能补全\n        专业/学院自动匹配支持拼音/代码搜索\n      \n      \n        🗑️ 后悔药\n        回收站机制双重删除确认\n      \n      \n        🎨 炫彩主题\n        深色/浅色模式一键实时切换\n      \n      \n        🛠️ 运维工具\n        一键清理日志/备份数据库维护工具\n      \n    \n  \n\n\n🎯 功能详情\n首页: 快速导航与最近动态，一键直达常用功能。\n仪表盘: 8 个梯度指标卡 + 饼&#x2F;柱图可视化 + 最近荣誉速览。\n总览: FTS5 全文搜索（比赛名&#x2F;证书号&#x2F;成员）+ 筛选排序分页，支持编辑与批量操作。\n录入: 卡片式表单，多成员动态管理；集成专业&#x2F;学校智能搜索（中文&#x2F;拼音&#x2F;代码）；支持一键 AI 识别证书（图片&#x2F;PDF）。\n成员管理: 成员库维护与详情，10 字段监控与快速修改。\n回收站: 已删除记录可恢复&#x2F;彻底删除，双重确认。\n系统设置: 主题&#x2F;备份&#x2F;日志&#x2F;索引维护与清理工具，自定义开关管理，导入模板下载；AI 与 MCP 配置入口。\nMCP 接入: 内置本地 MCP（stdio&#x2F;SSE）与可选 Web 控制台，默认只读，支持 PII 脱敏与写入开关。\n\n\n🛠️ 技术栈\n\n\n\n\n核心框架\n数据存储\n工具链\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAI 证书识别：OpenAI 兼容 API（Chat Completions&#x2F;Responses）+ PyMuPDF（PDF 渲染）+ Pydantic（结构化解析）\nMCP：mcp（FastMCP），支持 stdio&#x2F;SSE；可选 gradio Web 控制台\n日志：loguru（应用日志与 MCP 进程日志输出到 logs/）\n类型检查：pyright（标准模式）+ ruff（风格&#x2F;未使用项）\n\n\n📸 界面预览\n💡 提示: 点击图片可查看大图\n\n\n  \n    \n      \n        \n        🏠 首页快速导航与最近动态\n      \n      \n        \n        📊 仪表盘指标卡 + 统计图表\n      \n    \n    \n      \n        \n        👀 总览页FTS5 搜索 + 筛选排序\n      \n      \n        \n        📝 录入页成员卡片式表单 + AI 识别\n      \n    \n    \n      \n        \n        👥 成员管理10 字段监控与详情\n      \n      \n        \n        ⚙️ 设置页主题/备份/清理/日志\n      \n    \n  \n\n\n\n🚀 快速开始📥 安装步骤\n克隆仓库\ngit clone https://github.com/RE-TikaRa/Certificate-Management.gitcd Certificate-Management\n\n安装依赖 (推荐使用 uv)\n# 安装 uv (如果尚未安装)# pip install uv# 同步环境uv sync\n\n启动应用\n# Windows 快捷启动./main.bat# 或使用 uv 启动uv run python -m src.main\n\n🛠️ 常用命令\n\n\n操作\n命令\n说明\n\n\n\n运行\nuv run python -m src.main\n启动主程序\n\n\n调试\nuv run python -m src.main --debug\n开启调试日志\n\n\n检查\nuv run ruff check .\n代码 Lint 检查\n\n\n格式化\nuv run ruff format .\n代码自动格式化\n\n\n类型检查\nuv run python -m pyright\nPyright 标准模式\n\n\n语法检查\nuv run python -m py_compile src/\n基础语法编译检查\n\n\nMCP 服务\nuv run certificate-mcp\n启动 MCP（默认 stdio，只读）\n\n\nMCP SSE\nCERT_MCP_TRANSPORT=sse uv run certificate-mcp\n启动 SSE（默认 http://127.0.0.1:8000/sse；推荐用设置页随软件启动）\n\n\nMCP Web\nuv run certificate-mcp-web\n启动本地 Web 控制台（需安装可选依赖；默认 http://127.0.0.1:7860）\n\n\n\n🧾 AI 证书识别AI 证书识别用于“荣誉录入”页面的一键识别：从证书图片&#x2F;PDF 自动抽取 比赛名称、获奖日期、赛事级别、奖项等级、证书编号、成员姓名，并在预览对话框中确认后再写入表单。\n⚙️ 配置与模型\n打开 系统设置 → AI 证书识别，勾选“启用 AI 证书识别”\n配置一个提供商（Provider）\nAPI 地址：OpenAI 兼容地址（如 https://api.openai.com 或你的兼容中转）\nAPI Key：支持多 Key，程序会按请求轮换（见下文）\n模型：可手动填写模型 ID；若你的服务支持 /v1/models，可在设置页刷新&#x2F;选择\nPDF 页数：1~10（PDF 会渲染前 N 页作为图片参与识别）\n\n\n点击“测试联通”验证配置（会发起最小请求）\n\n说明（按当前实现）：\n\n支持文件：.pdf .png .jpg .jpeg .webp\nKey 轮换：每次调用（识别证书、刷新模型、测试联通）都会轮到下一个 Key；当前不会在失败时自动切 Key 重试\nOpenAI 官方 api.openai.com：会走 responses 接口；PDF 会以文件方式上传，图片会以单张图片方式上传\n兼容服务：走 /v1/chat/completions；PDF 会按“PDF 页数”渲染多页图片后发送\n\n🧾 使用流程\n在 荣誉录入 页点击顶部“AI 识别证书”\n选择证书文件后，程序会自动将其加入附件并开始识别\n在“AI 识别预览”中确认&#x2F;修改结果后应用到表单\n\n\n📥 导入 &#x2F; 导出（CSV&#x2F;XLSX）\n入口：系统设置 → 导入&#x2F;导出\n导入：支持 CSV&#x2F;XLSX；表头需与模板一致；可选字段 附件路径（用 ; 分隔多个文件的绝对路径）\n导出：导出文件包含 附件数量 与 附件路径；若要回导请确保附件文件在原路径可访问（跨机器需自行拷贝并修正路径）\n\n\n🤖 MCP 接入（本地）本项目内置了 MCP (Model Context Protocol) 服务，允许 AI Agent（如 Claude Desktop、Cursor 等）安全地读取本地荣誉数据与附件。\n🔌 连接方式\nstdio 模式（推荐）\n\n适用场景：本地客户端直接拉起进程（无需占用端口）。\n启动命令：uv run certificate-mcp\n配置示例：见下文“客户端配置示例”。\n\n\nSSE 模式（HTTP 服务）\n\n适用场景：本机调试（HTTP）。\n地址：http://127.0.0.1:8000/sse\n启动方式：\n自动（推荐）：在“设置页 → MCP 服务”中开启“随软件启动 MCP”。\n手动：CERT_MCP_TRANSPORT=sse uv run certificate-mcp\n\n\n日志：logs/mcp_sse.log\n注意：服务端强制本地绑定，CERT_MCP_HOST 只能是 127.0.0.1 &#x2F; localhost &#x2F; ::1，请勿暴露到公网。\n\n\nWindows PowerShell 手动启动命令\n\n$env:CERT_MCP_TRANSPORT = &quot;sse&quot;$env:CERT_MCP_HOST = &quot;127.0.0.1&quot;$env:CERT_MCP_PORT = &quot;8000&quot;uv run certificate-mcp\n\n\nWeb 控制台（调试用）\n\n功能：提供一个 Web 界面来测试 MCP 工具调用。\n安装：uv sync --group mcp-web（或在设置页点击安装）。\n启动：uv run certificate-mcp-web（默认访问 http://127.0.0.1:7860）。\n说明：无登录，仅用于本机调试；如关闭后端口仍占用见“故障排查”。\n\n\n\n🛡️ 权限与安全\n默认只读：默认不允许写入数据库或修改文件。如需开启写入（仅限本地），请在设置页勾选或设置环境变量 CERT_MCP_ALLOW_WRITE=1。\n隐私保护：默认开启 PII 脱敏（CERT_MCP_REDACT_PII=1），自动隐藏身份证号与手机号中间位。\n附件限额：单次读取附件最大 1MB（可配置 CERT_MCP_MAX_BYTES）。\n网络安全：服务默认绑定 127.0.0.1，请勿暴露到公网。\n\n🛠️ 能力概览\nTools (工具)：\nlist_awards &#x2F; get_award &#x2F; search_awards：查询荣誉记录。\nlist_members &#x2F; get_member：查询成员信息。\nread_attachment：读取附件内容（支持文本提取）。\nhealth：健康检查。\n\n\nResources (资源)：\ndocs://readme &#x2F; docs://agents：读取项目 README&#x2F;AGENTS 指南。\nschema://models：查看数据库模型定义。\ntemplates://awards_csv：获取导入模板。\n\n\n\n⚙️ 常用环境变量\n\n\n变量名\n说明\n默认值\n\n\n\nCERT_MCP_TRANSPORT\n传输模式 (stdio&#x2F;sse)\nstdio\n\n\nCERT_MCP_HOST\nSSE Host（仅允许本地）\n127.0.0.1\n\n\nCERT_MCP_PORT\nSSE 端口\n8000\n\n\nCERT_MCP_ALLOW_WRITE\n允许写入 (0&#x2F;1)\n0\n\n\nCERT_MCP_REDACT_PII\n敏感信息脱敏 (0&#x2F;1)\n1\n\n\nCERT_MCP_MAX_BYTES\n单次附件读取上限（字节）\n1048576\n\n\nCERT_MCP_DEBUG\n输出调试错误细节 (0&#x2F;1)\n0\n\n\nCERT_MCP_WEB_HOST\nWeb 控制台 Host\n127.0.0.1\n\n\nCERT_MCP_WEB_PORT\nWeb 控制台端口\n7860\n\n\nCERT_MCP_WEB_INBROWSER\n是否自动打开浏览器 (0&#x2F;1)\n1\n\n\n\n📎 客户端配置示例 (Claude Desktop / Cursor)\n\nstdio 模式 (推荐)：\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;certificate&quot;: &#123;      &quot;command&quot;: &quot;uv&quot;,      &quot;args&quot;: [&quot;run&quot;, &quot;certificate-mcp&quot;],      &quot;env&quot;: &#123;        &quot;CERT_MCP_ALLOW_WRITE&quot;: &quot;0&quot;,        &quot;CERT_MCP_REDACT_PII&quot;: &quot;1&quot;      &#125;    &#125;  &#125;&#125;\n\nSSE 模式：\n&#123;  &quot;mcpServers&quot;: &#123;    &quot;certificate&quot;: &#123;      &quot;type&quot;: &quot;sse&quot;,      &quot;url&quot;: &quot;http://127.0.0.1:8000/sse&quot;    &#125;  &#125;&#125;\n\n\n\n📂 文件目录说明\n点击展开完整目录树\n\nCertificate-Management/├── 📄 README.md                    # 项目文档├── ⚙️ pyproject.toml               # 依赖配置├── 🔒 uv.lock                      # 依赖锁定├── 🚀 main.bat                     # Windows 启动脚本├── 🚫 .gitignore                   # Git 忽略规则├── 🧰 tools/                       # 开发辅助脚本（可选）│├── 📦 src/                         # 源代码│   ├── 🏁 main.py                  # 入口文件│   ├── 🌍 app_context.py           # DI 容器│   ├── ⚙️ config.py                # 配置加载│   ├── 📝 logger.py                # 日志配置│   ├── 🤖 mcp/                     # MCP 模块（本地）│   │   ├── server.py               # MCP 服务端（默认只读）│   │   ├── web.py                  # MCP 本地 Web 控制台（可选）│   │   ├── helpers.py              # MCP 配置/解析辅助│   │   └── runtime.py              # MCP 进程/自启动管理（本地）│   ││   ├── 💾 data/                    # 数据层│   │   ├── models.py               # SQLAlchemy 模型│   │   └── database.py             # 数据库会话│   ││   ├── 🔧 services/                # 业务层│   │   ├── award_service.py        # 荣誉逻辑│   │   ├── statistics_service.py   # 统计分析│   │   ├── import_export.py        # 导入导出│   │   ├── ai_certificate_service.py # AI 证书识别（OpenAI 兼容 API）│   │   ├── ai_provider_service.py  # AI Provider / Key 轮换│   │   ├── attachment_manager.py   # 附件存储/去重/回收站│   │   ├── backup_manager.py       # 备份/验证/恢复（含定时任务）│   │   ├── flag_service.py         # 自定义布尔开关（flag）│   │   └── ...│   ││   ├── 🎨 ui/                      # 表现层│   │   ├── main_window.py          # 主窗口│   │   ├── styled_theme.py         # 主题管理│   │   ├── pages/                  # 各功能页面│   │   └── widgets/                # 自定义组件│   ││   └── 📂 resources/               # 静态资源│       ├── styles/                 # QSS 样式│       └── templates/              # 导入模板│├── 📂 data/                        # 数据库存储 (自动生成)├── 📂 attachments/                 # 附件存储├── 📂 backups/                     # 自动备份├── 📂 logs/                        # 运行日志└── 📂 docs/                        # 文档与参考数据\n\n\n\n🏗️ 项目架构flowchart TD    subgraph UI [表现层 Presentation]        direction TB        MainWindow[主窗口 MainWindow]        Pages[页面 Pages]        Widgets[组件 Widgets]        Theme[主题 ThemeManager]    end    subgraph Service [业务层 Business Logic]        direction TB        AwardSvc[荣誉服务 AwardService]        StatSvc[统计服务 StatisticsService]        BackupSvc[备份服务 BackupManager]        ImportSvc[导入服务 ImportExport]        AttachSvc[附件服务 AttachmentManager]        FlagSvc[开关服务 FlagService]        AISvc[AI 证书识别 AICertificateService]    end    subgraph Data [数据层 Data Access]        direction TB        ORM[SQLAlchemy ORM]        SQLite[(SQLite Database)]    end    subgraph Integration [集成 Integration]        direction TB        MCP[MCP Server (FastMCP)]    end    UI --&gt; Service    Service --&gt; Data    MCP --&gt; Service        style UI fill:#e1f5fe,stroke:#01579b    style Service fill:#fff3e0,stroke:#ff6f00    style Data fill:#e8f5e9,stroke:#2e7d32    style Integration fill:#f3e5f5,stroke:#6a1b9a\n\n\n架构说明：本项目采用经典的三层架构（表现层、业务层、数据层），各层职责分明，通过依赖注入（DI）容器 AppContext 进行解耦。\n\n\n💾 数据模型\n查看详细数据库表结构\n\n🏆 荣誉记录 (Awards)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\ncompetition_name\nString\n比赛名称\n\n\naward_date\nDate\n获奖日期\n\n\nlevel\nString\n级别（国家&#x2F;省&#x2F;校等）\n\n\nrank\nString\n等级（一&#x2F;二&#x2F;三&#x2F;优秀）\n\n\ncertificate_code\nString\n证书编号\n\n\nremarks\nText\n备注\n\n\nattachment_folder\nString\n附件目录相对路径\n\n\ndeleted &#x2F; deleted_at\nBool&#x2F;DateTime\n软删除标记\n\n\ncreated_at &#x2F; updated_at\nDateTime\n时间戳\n\n\naward_members\nRelation\n荣誉成员快照（AwardMember，级联删除）\n\n\nattachments\nRelation\n附件（级联删除）\n\n\n🧩 荣誉成员快照 (AwardMembers)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\naward_id\nFK\n关联荣誉\n\n\nmember_id\nFK &#x2F; Nullable\n关联成员库（可空；未入库则为空）\n\n\nmember_name\nString\n当时录入的姓名快照（必填）\n\n\nsort_order\nInteger\n成员顺序\n\n\n👤 参与成员 (TeamMembers)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\nname\nString\n姓名\n\n\ngender\nString\n性别\n\n\nid_card\nString\n身份证号（唯一）\n\n\nphone\nString\n手机号\n\n\nstudent_id\nString\n学号（唯一）\n\n\nemail\nString\n邮箱\n\n\nschool &#x2F; school_code\nString\n学校名称&#x2F;标识码\n\n\nmajor &#x2F; major_code\nString\n专业名称&#x2F;代码\n\n\nclass_name\nString\n班级\n\n\ncollege\nString\n学院\n\n\npinyin\nString\n姓名拼音\n\n\nactive\nBool\n启用状态\n\n\nsort_index\nInteger\n排序权重\n\n\ncreated_at &#x2F; updated_at\nDateTime\n时间戳\n\n\naward_associations\nRelation\n通过 AwardMember 关联荣誉（成员库可变更不影响历史快照）\n\n\n🤖 AI 提供商 (AIProviders)\n\n\n字段\n类型\n说明\n\n\n\nid\nInteger\n主键\n\n\nname\nString\n提供商名称（唯一）\n\n\napi_base\nString\nOpenAI 兼容 API Base\n\n\napi_keys\nText\n多 Key（支持 &#96;name\n\n\nmodel\nString\n默认模型 ID\n\n\npdf_pages\nInteger\nPDF 渲染页数（1~10）\n\n\nlast_key_index\nInteger\nKey 轮换索引（-1 表示未开始）\n\n\n\nsettings.ai_active_provider_id 用于标记当前激活的 provider；旧版单配置（ai_api_base/ai_api_key/ai_model）会在首次启动时迁移到默认 provider。\n\n🏷️ 自定义开关 (CustomFlags&#x2F;AwardFlagValues)\n\n\n模型\n关键字段\n说明\n\n\n\nCustomFlag\nkey(唯一), label, enabled, default_value, sort_order\n自定义布尔开关定义（用于录入&#x2F;导出&#x2F;筛选）\n\n\nAwardFlagValue\naward_id, flag_key, value\n荣誉对应的开关值（与 award_id+flag_key 唯一）\n\n\n🎓 专业与学校 (Majors&#x2F;Schools)\n\n\n模型\n关键字段\n说明\n\n\n\nMajor\nname(唯一), code(唯一), pinyin, category, discipline_code/name, class_code/name, 时间戳\n2025 本科专业目录（约 840 条）\n\n\nSchool\nname(唯一), code(唯一), pinyin, region, 时间戳\n全国高校列表\n\n\nSchoolMajorMapping\nschool_name/code, major_name/code, college_name, category, discipline_*, class_*\n学校-专业-学院映射，支持代码缺失时按名称回退\n\n\nAttachment\naward_id, stored_name, original_name, relative_path(唯一), file_md5, file_size, deleted, 时间戳\n附件记录\n\n\nBackupRecord &#x2F; ImportJob\n路径&#x2F;状态&#x2F;消息&#x2F;时间戳\n备份与导入任务记录\n\n\n(更多模型细节请查阅源码 src/data/models.py)\n\n\n\n🔐 数据安全与备份\n  \n    \n      \n        🛡️ 本地优先\n        数据存于 data/awards.db，附件在 attachments/，默认不上传云端。\n      \n      \n        🔄 自动备份\n        支持手动/启动时/每日/每周备份；基于 SQLite backup() 生成快照，并可在恢复前自动创建还原点。\n      \n    \n    \n      \n        🗑️ 回收站\n        删除荣誉进入回收站可恢复；附件删除会移入 attachments/.trash。\n      \n      \n        🧹 清理策略\n        提供日志/备份清空与数据库重建（reset）工具，均带双重确认；数据库清空会重建空库并重载默认设置。\n      \n    \n  \n\n\n\n⚠️ 隐私提醒：请勿将 data/、backups/、attachments/、logs/、.env 等敏感目录提交到版本控制系统。\n\n\n🎨 主题系统应用内置了一套精美的色彩系统，适配深色&#x2F;浅色模式。\n\n\n\n指标类型\n渐变色 (Light -&gt; Dark)\n语义\n\n\n\n总荣誉\n💜 #a071ff → #7b6cff\n综合实力\n\n\n国家级\n💙 #5a80f3 → #4ac6ff\n最高荣誉\n\n\n省级\n💛 #ffb347 → #ffcc33\n中坚力量\n\n\n校级\n💚 #3ec8a0 → #45dd8e\n基础积累\n\n\n一等奖\n💠 #00b4d8 → #48cae4\n顶尖表现\n\n\n二等奖\n💜 #b54cb8 → #d896ff\n稳定发挥\n\n\n三等奖\n❤️ #ff6b6b → #ff8787\n鼓励奖项\n\n\n优秀奖\n🤍 #999999 → #b3b3b3\n参与&#x2F;优秀\n\n\n\n🛠️ 开发指南\n环境准备: 确保 Python 3.14+，推荐使用 uv 管理虚拟环境。\n新增页面: 继承 BasePage，在 main_window.py 中注册路由。\n数据库变更: 修改 models.py，目前使用自动建表，生产环境建议引入 Alembic。\n代码规范: 提交前请运行 ruff check 和 pyright。\n版本与文档: 版本号统一来自 pyproject.toml（运行时由 src/version.py 读取）；升级版本时请同步更新 README 顶部&#x2F;更新日志与应用“关于”页文案。\n\n\n🧰 故障排查\n点击查看常见问题解决方案\n\n\n\n\n问题现象\n可能原因\n解决方案\n\n\n\n启动缺少 Qt 插件\n环境依赖不完整\n运行 uv sync，若无效则删除 .venv 重试\n\n\n界面文字乱码\n字体缺失或编码问题\n检查系统字体，确认未强制覆盖 QFontDatabase\n\n\n数据库被锁\n异常退出导致锁文件残留\n先关闭应用；仍锁时删除 data/awards.db-shm 和 .db-wal（恢复备份前程序会尝试清理这两类文件）\n\n\n导入无响应\n模板格式错误\n确认 CSV&#x2F;XLSX 表头与模板一致，查看设置页日志\n\n\nMCP 连接失败\n端口未启动&#x2F;URL 错误&#x2F;依赖缺失\nSSE：确认 http://127.0.0.1:8000/sse 且设置页已启动；Web：先 uv sync --group mcp-web，再启动 Web 控制台并访问 http://127.0.0.1:7860\n\n\nMCP Web 关闭后端口仍占用（7860）\n进程未退出&#x2F;残留子进程\n退出应用与相关终端后，用 netstat -ano | findstr :7860 查 PID，再 taskkill /PID &lt;pid&gt; /T /F\n\n\nMCP SSE 启动报 host 限制\nMCP 服务仅允许本地绑定\n将 CERT_MCP_HOST 设置为 127.0.0.1 &#x2F; localhost &#x2F; ::1（或直接用设置页启动）\n\n\nAI 识别提示缺少 PDF 依赖\n未安装 PyMuPDF\n运行 uv sync 安装依赖（需要识别 PDF 时必须）\n\n\nAI 识别失败：Cloudflare 1010\n网络&#x2F;代理&#x2F;风控拦截\n更换网络&#x2F;代理或更换中转；该错误通常与本机环境无关\n\n\nAI 识别失败：模型输出不是有效 JSON\n模型不按要求输出结构化结果\n更换模型&#x2F;提供商；确保模型支持图像输入，并尝试在设置页手动填写模型 ID\n\n\n主题不更新\n信号未连接\n检查 __init__ 是否连接 themeChanged 信号\n\n\n附件校验失败\n文件被占用或修改\n检查文件权限，清空回收站后重试\n\n\n\n\n\n📝 更新日志\n说明：以下版本号按 GitHub main 分支提交记录分段整理（无 Tag 时以日期为准），采用 SemVer（主版本&#x2F;次版本&#x2F;修订号）。\n\nv1.4.0 (2025-12-18)\nAI 证书识别\n荣誉录入页支持一键从证书图片&#x2F;PDF 抽取比赛名称、日期、级别、奖项、证书编号与成员姓名，并提供预览确认后再填充\nAI 设置页新增&#x2F;完善：多 Provider 管理（名称&#x2F;API 地址&#x2F;模型&#x2F;PDF 页数）、模型列表刷新&#x2F;选择、联通测试、API Key 多 Key 轮换\n\n\n运维与数据\n新增数据库 reset 与自定义布尔开关批量保存，便于清理与批处理\n修复奖项成员快照在部分路径下的赋值顺序问题\n\n\n文档\n修正目录锚点与奖项说明细节\n\n\n\n\n提交记录（v1.4.0，共 7 条）\n\n\ncde6154 2025-12-17 docs: 修正目录锚点与补充奖项说明\n47a45f0 2025-12-17 feat: 支持数据库 reset 与 flag 批量保存\n0a7abf4 2025-12-18 fix: 修正奖项成员快照赋值顺序\n9e0fde6 2025-12-18 feat: 增加 AI 证书识别与多 Provider 支持\ne70fa2c 2025-12-18 fix: 优化 AI 证书按钮与模型输入兼容性\nc0d2912 2025-12-18 fix: 优化 AI 密钥表格内容居中显示\n8a7c285 2025-12-18 refactor: 拆分 AI 设置表单结构\n\n\n\nv1.3.1 (2025-12-17)\n荣誉成员快照 &#x2F; 可选入库\n荣誉成员改为快照模型：荣誉始终保存 member_name，可选绑定成员库 member_id，成员库变更&#x2F;停用不影响历史荣誉显示\n录入页每个成员卡片新增“加入成员库”勾选（默认关闭），不入库时仅保存姓名；总览&#x2F;仪表盘&#x2F;导入导出同步适配\n\n\n性能&#x2F;体验\n页面引入懒加载占位页，并在启动后分批后台预热，显著降低首屏初始化压力\n专业&#x2F;学校搜索与仪表盘数据加载迁移到线程池异步执行，减少输入与切页时的 UI 阻塞\n页面切换时仅在可见页面运行刷新&#x2F;轮询定时器，修复“每 5 秒卡一下”的卡顿问题\n控制台日志格式更清晰（时间+等级对齐，可选颜色），过滤第三方提示信息，Windows 启动脚本成功退出不再强制暂停\n\n\n数据安全\n备份改用 SQLite backup() 快照生成，避免 WAL 模式下直接复制 awards.db 可能导致的不一致\n\n\n稳定性\n修复 run_in_thread() 线程池任务回调偶发丢失（worker 生命周期过短导致未回调）\n修复部分类型标注在运行时导入触发 NameError 的问题（提升对不同 Python 版本的兼容性）\n\n\nMCP\n附件读取工具返回信息更准确，并跟随设置页配置的附件目录工作（修改目录后重启 MCP 生效）\n\n\n工程化\n规范化版本号管理，统一从 pyproject.toml 读取，窗口标题显示版本号\n\n\n文档\n修正 README 段落缩进与更新日志结构，补齐各版本提交记录\n完善 MCP&#x2F;AI 接入与本地安全说明（仅本地使用，保持绑定 127.0.0.1）\n\n\n\n\n提交记录（v1.3.1，共 7 条）\n\n\n1bb7c41 2025-12-17 feat: 荣誉成员支持快照与可选入库\n1ae5479 2025-12-17 feat: 优化页面加载与错误处理，提升性能\nac8cc5c 2025-12-17 feat: 优化日志输出与懒加载页面体验\n25041a0 2025-12-17 chore: 规范化版本号管理 (v1.3.1)\nf6b55c3 2025-12-17 feat: 优化荣誉成员快照与页面性能\nef15694 2025-12-17 docs: 修正 README.md 段落缩进与更新日志\n4ed0e17 2025-12-17 docs: 完善 MCP&#x2F;AI 接入与安全说明\n\n\n\nv1.3.0 (2025-12-16)\nMCP 接入\n新增本地 MCP 服务（stdio&#x2F;SSE），默认只读；支持敏感信息脱敏与附件读取限额\n新增可选 Web 控制台（Gradio），用于本机调试 MCP 输出（无登录，仅本地）\n设置页集成 MCP 管理（随软件启动、端口&#x2F;权限&#x2F;脱敏配置、日志入口、Web 依赖一键安装&#x2F;更新）\n\n\n工程化与结构\nMCP 相关代码整理到 src/mcp/，统一模块命名与脚本入口（certificate-mcp &#x2F; certificate-mcp-web）\nMCP 进程与 Web 控制台运行日志落盘（logs/mcp_sse.log、logs/mcp_web.log、logs/mcp_web_install.log）\n\n\n细节修复\n修复导入模板与设置页布局细节，优化 MCP 说明与使用指引\n\n\n\n\n提交记录（v1.3.0，共 5 条）\n\n\nf6086cd 2025-12-16 feat: 集成 MCP 服务及本地 Web 控制台\n2ed061f 2025-12-16 feat: 增强 MCP 进程管理与敏感信息脱敏\n493d310 2025-12-16 feat: 优化 MCP 说明与 Web 控制台操作\n5a2a907 2025-12-16 refactor: MCP 相关模块目录结构调整与功能优化\n35f397c 2025-12-16 chore: 更新版本号至 1.3.0 并补充更新日志\n\n\n\nv1.2.0 (2025-12-14)\n新增：自定义布尔开关（CustomFlag &#x2F; AwardFlagValue）及与荣誉记录关联\n新增：设置页开关管理界面（改名、启用、默认值、排序、删除双重确认）\n增强：录入页&#x2F;导入导出支持开关值读写，统计与相关逻辑同步完善\n\n\n提交记录（v1.2.0，共 1 条）\n\n\n86f6d01 2025-12-14 feat: 增加自定义布尔开关及荣誉关联\n\n\n\nv1.1.0 (2025-12-09 ~ 2025-12-10)\n新增：批量管理（全选&#x2F;反选&#x2F;全不选）与成员排序优化\n新增：荣誉&#x2F;成员全文检索（FTS5）与导入流程优化\n增强：附件去重（含按奖项限定）与备份&#x2F;恢复体验优化\n增强：主窗口导航快捷键、自动备份选项、LOGO 与文档说明完善\n\n\n提交记录（v1.1.0，共 15 条）\n\n\n3c1aa2f 2025-12-09 feat: 批量管理与成员排序功能优化\ndf74008 2025-12-09 feat: 批量管理支持全选&#x2F;反选&#x2F;全不选\n8848538 2025-12-09 refactor: 优化最新荣誉查询逻辑\nc18bc0e 2025-12-09 feat: 学校与专业导入及数据模板完善\ncf09d34 2025-12-10 feat: 附件去重与备份恢复功能优化\n2c7ad87 2025-12-10 feat: 附件查重支持按奖项限定\n193a4cb 2025-12-10 feat: 增加主窗口导航快捷键与备份自动备份选项\n661c30e 2025-12-10 feat: 荣誉与成员全文搜索及导入优化\n85a4fe7 2025-12-10 feat: 更新 LOGO 与设置&#x2F;搜索功能说明\n3de33e0 2025-12-10 docs: 优化 README LOGO 展示布局\n67a5bc6 2025-12-10 docs: 优化 README 顶部布局与徽章展示\n15b3aed 2025-12-10 docs: 完善数据模型与目录说明\n901b405 2025-12-10 docs: 修正 README 顶部打字动画内容编码\nb3616d7 2025-12-10 docs: 完善数据模型说明并删除测试脚本\nb530069 2025-12-10 chore: 更新 .gitignore 及 AGENTS.md 数据目录说明\n\n\n\nv1.0.1 (2025-12-04 ~ 2025-12-07)\n体验优化：表单&#x2F;仪表盘&#x2F;列表 UI 大量调整，表格迁移至 QTableView 并支持居中显示\n主题&#x2F;性能：浅色表格修复、深色背景调整、减少模糊特效避免掉帧、动画更顺滑\n数据能力：专业库 Excel 导入与统计展示、附件表格支持拖拽添加\n工程化：依赖管理切换为 pyproject.toml + uv，集成 Ruff&#x2F;Pyright；构建系统切换为 setuptools\n稳定性：支持信号中断安全退出，修复字体重置、总览页附件显示等问题\n\n\n提交记录（v1.0.1，共 61 条）\n\n\ne0c1b33 2025-12-04 修复操作细节\n6e90000 2025-12-04 逻辑优化\n1b492fd 2025-12-04 无更新\nef0b2d4 2025-12-04 Remove docs folder\n75a6902 2025-12-04 feat: 添加文档导入功能和邮箱自动生成\n55bc0fd 2025-12-04 修复小BUG\n5297fcf 2025-12-04 修复小BUG\na29a915 2025-12-05 修复总览页不显示附件的BUG\n68318b7 2025-12-05 优化体验\n7176bd5 2025-12-05 加入关于页\nf4fa0fd 2025-12-05 提供个人信息模板\ndc4161a 2025-12-05 更新排序功能\n584f049 2025-12-05 更新文本\na8c8af5 2025-12-05 更新细节\n05d60b1 2025-12-05 RM更新\n85f6fe9 2025-12-05 RM更新\n3260af5 2025-12-05 fix: 移除模糊特效防止掉帧\n9b25efa 2025-12-05 fix: 优化备份目录配置容错处理\nc751e23 2025-12-05 feat: 支持logo随主题切换\n69d383d 2025-12-05 fix: 防止动画中卡顿\n4729233 2025-12-05 refactor: 全面替换表格为QTableView并引入模型\nf2363bb 2025-12-05 refactor: 优化表单与仪表盘UI及交互\n93537a2 2025-12-05 refactor: 表单控件统一为qfluentwidgets组件\nbe6c61a 2025-12-05 refactor: 统一成员卡片样式为QSS卡片属性\na80e672 2025-12-05 refactor: 隐藏日期选择器符号按钮\n79b65ae 2025-12-05 refactor: 优化搜索框与荣誉卡片样式\n48a3e17 2025-12-05 refactor: 设置全局字体避免警告\ndbc5819 2025-12-05 fix: 修复字体重置的问题\nf61e75c 2025-12-05 fix: 移除弹窗模糊特效防止掉帧\n958aea2 2025-12-05 chore: 切换依赖管理为 pyproject.toml+uv\n6afce89 2025-12-05 refactor: 移除表情符号并优化注释\n49358ff 2025-12-05 refactor: 精简注释与优化代码结构\n6ee169e 2025-12-05 chore: 调整ruff配置项位置\n2d9fe94 2025-12-05 refactor: 统一导航方法为navigate_to\nc79858a 2025-12-05 style: 统一代码风格与格式优化\n893226f 2025-12-05 refactor: 优化类型导入与异常处理\n6905e1a 2025-12-05 refactor: 统一文件操作与类型注解优化\n4fb64e9 2025-12-05 docs: 重命名 agents.md 至 AGENTS.md\na348921 2025-12-06 docs: 更新 AI 开发指南\nb3ea343 2025-12-06 docs: 更新数据模型与依赖说明\n19096b8 2025-12-06 chore: 移除 ruff 配置中的 PL 规则\n775c69c 2025-12-06 refactor: 精简条件表达式与移除无用Tag相关方法\nc17746a 2025-12-06 feat: 集成 Pyright 类型检查支持\n330c982 2025-12-06 refactor: 适配 PySide6 新版 API 与类型注解优化\n139ab0d 2025-12-06 refactor: 移除 future annotations 导入\n66d29cc 2025-12-06 refactor: 优化页面初始化与导航栏注册\n8e93328 2025-12-06 feat: 优化页面切换动画\n1bba145 2025-12-06 style: 调整深色主题主背景色\n7756c10 2025-12-06 fix: 修复表格亮色模式\n6c048e0 2025-12-06 feat: 支持信号中断安全退出\na91ebd1 2025-12-06 feat: 真正的 Fluent Design 切换动画\n57bef83 2025-12-06 Merge pull request #1 from zetaloop&#x2F;refactorxx\n20e1a66 2025-12-07 chore: 启动脚本增加虚拟环境激活\n7d6b279 2025-12-07 chore: 格式化依赖配置与部分代码结构\na235df8 2025-12-07 chore: 切换构建系统为 setuptools\n2eeb63e 2025-12-07 feat: 附件表格支持拖拽添加文件\ne526e91 2025-12-07 feat: 表格内容居中显示\n27755da 2025-12-07 refactor: 优化类型导入与依赖\n07d3ccc 2025-12-07 feat: 专业库支持 Excel 导入与统计展示\nda71f6d 2025-12-07 refactor: 专业库导入脚本迁移与优化\n61d99e9 2025-12-07 refactor: 优化 test_majors.py 导入与格式\n\n\n\nv1.0.0 (2025-12-02 ~ 2025-12-03)\n初版完成：基础页面、主题样式与主要组件搭建\n文档：引入 AGENTS.md，为 AI&#x2F;自动化开发提供项目导航与规范\n\n\n提交记录（v1.0.0，共 10 条）\n\n\ne30a773 2025-12-02 V1.0 创建\n81e6477 2025-12-02 添加主题样式和页面组件功能\n27071ef 2025-12-02 Clean up: remove unused files and configure .gitignore for sensitive data\n2643a2d 2025-12-02 chore: remove .codemap from version control\n9d38507 2025-12-02 更新细节\n85d8e2f 2025-12-03 feat: implement comprehensive code improvements\ncd2214b 2025-12-03 细节修复\na9a6fc9 2025-12-03 细节修复\nca924ab 2025-12-03 大版本V1.0完成\n5d6f019 2025-12-03 创建agents.md为AI开发提供便利\n\n\n\n\n📈 Star History\n \n   \n   \n   \n \n\n\n\n🤝 如何贡献非常欢迎您的贡献！请遵循以下流程：\n\nFork 本仓库\n创建特性分支 (git checkout -b feature/AmazingFeature)\n提交更改 (git commit -m &#39;Add some AmazingFeature&#39;)\n推送到分支 (git push origin feature/AmazingFeature)\n提交 Pull Request\n\n\n📄 许可证本项目基于 MIT License 开源。\n\n\n  \n    Author: RE-TikaRa |\n    Powered by: PySide6 & QFluentWidgets\n  \n  \n  \n    \n      \n    \n    \n      \n    \n  \n\n","categories":["Project"],"tags":["Project"]},{"url":"/Blog/posts/0/","content":"C语言程序结构\n一个C语言程序可以包含多个源程序文件。\n一个源程序文件中可以包含多个函数。\nC语言程序有且仅有一个主函数main作为程序的入口。\n函数是C语言程序的基本单位。\n程序执行从main()函数开始，在main()函数中结束。\n程序只会执行在main()函数中定义的内容，其他函数需要通过调用的方式执行。\n函数之间不能嵌套定义。\n函数之间可以嵌套调用。\n\nC语言程序基本结构展示\nC语言函数分类1.从用户角度\n标准函数（库函数）：由系统提供\n用户自定义函数\n\n2.从函数形式\n无参函数\n有参函数\n\n库函数（标准函数）&emsp;&emsp;系统提供的已设计好的函数\n使用库函数应注意\n函数功能\n函数参数的数目和顺序，及各个参数的意义和类型\n函数的返回值的意义和类型\n需要使用的包含文件\n调用库函数时，必须要使用#include &lt;头文件名.h&gt;\n标准库函数的调用形式：函数名(参数表)\n\n"},{"url":"/Blog/posts/0/","content":"程序的三种基本结构1. 结构化程序设计\n基本思想：任何程序都可以用三种基本结构表示，限制使用无条件转移语句（即goto）\n结构化程序：由三种基本结构反复嵌套构成的程序叫结构化程序\n优点：结构清晰，易读，提高程序设计质量和效率。\n\n2. 三种基本结构：顺序结构&emsp;&emsp;程序按顺序执行，每条指令都按顺序执行，直到程序结束。\n选择结构&emsp;&emsp;程序根据条件执行不同的指令。又分为二分支选择结构和三分支选择结构。\n二分支选择结构&emsp;&emsp;二分支选择结构：条件为真时执行A，条件为假时执行B。\n三分支选择结构&emsp;&emsp;三分支选择结构：条件为K1时执行A，条件为K2时执行B，条件为K3时执行C，以此类推。\n循环结构&emsp;&emsp;循环结构：又分为当型循环结构和直到型循环结构。\n当型循环结构&emsp;&emsp;当型循环结构：当条件为真时，循环执行A，当条件为假时，跳出循环。\n直到型循环结构&emsp;&emsp;直到型循环结构：当条件为假时，循环执行A，直到条件为真时，跳出循环。\n注：&emsp;&emsp;A,B,A1….An可以是一个简单语句，也可以是一个基本结构\n"},{"url":"/Blog/posts/0/","content":"第三章 前言这一章咱们要掌握程序的“基本功”——就像学功夫要先练马步一样重要。\n程序的三大招式还记得第一章说的三种基本结构吗？\n\n顺序结构：像排队买奶茶，一个接一个\n选择结构：遇到岔路口做选择（后面章节重点）\n循环结构：重复执行直到满足条件（后面章节重点）\n\n本章重点修炼第一种招式——顺序结构。虽然它看起来最简单，但却是所有复杂程序的基础。\n实战训练我们会学到：\n\n怎么让程序输出结果（printf的使用技巧）\n如何接收用户输入（scanf的正确打开方式）\n赋值语句的秘密（别搞混了&#x3D;和&#x3D;&#x3D;）\n复合语句的妙用（用{}把多条语句变成一个整体）\n\n代码示例🌰：\n#include &lt;stdio.h&gt;\n\nint main() {\n    int num1 = 5, num2 = 3;\n    int sum = num1 + num2;\n    \n    printf(&quot;第一个数：%d\\n&quot;, num1);\n    printf(&quot;第二个数：%d\\n&quot;, num2);\n    printf(&quot;两数之和：%d\\n&quot;, sum);\n    \n    // 复合语句示例\n    {\n        int temp = num1;\n        num1 = num2;\n        num2 = temp;\n        printf(&quot;交换后：num1=%d, num2=%d\\n&quot;, num1, num2);\n    }\n    \n    return 0;\n}\n\n"},{"url":"/Blog/posts/0/","content":"第五章 循环之道——驾驭程序的永动机核心能力修炼：参悟三大循环秘术通过本章修炼，你将获得：\n\n破解while循环的”永动机关”咒语\n掌握do…while的”先斩后奏”心法\n领悟for循环的”三位一体”真言\n驯服嵌套循环的”九重天阵法”\n参悟break&#x2F;continue的”瞬移神通”\n\n知识脉络一、循环三重奏\nwhile循环：永不停歇的旋转门（先验型循环）\ndo…while循环：先开闸后验票的霓虹国地铁通道（后验型循环）\nfor循环：三位一体的时间控制器（初始化→条件→迭代）\n\n二、控制玄机\n嵌套艺术：外层如年轮，内层似日晷的套娃法则\nbreak破界：直通紧急出口的瞬间穿越\ncontinue跳转：跳过当前回合的特异功能\n\n三、实战应用场\n计数器：班级人数的点名系统\n数据验证：密码输入的三次机会机制\n定时任务：火箭发射的10秒倒计时\n模式匹配：字符串侦探的字符追踪\n\n修炼心法&emsp;&emsp;建议用”流程图思维”观察循环轨迹，重点参悟三种循环的适用场景差异。特别注意for循环三段式咒语的编写技巧，以及嵌套循环的层次控制要诀。警惕无限循环的”死锁”陷阱，善用调试器的单步追踪功能。\n"},{"url":"/Blog/posts/0/","content":"strlen和sizeof的区别\nstrlen(s)是计算以s为起始地址的字符串的长度，并作为函数值返回。这一长度不包括字符串结尾的标志’\\0’。\nsizeof(s)是求数组a的长度，包括’\\0’，如果数组已经分配了大小N，则sizeof的值就为N.\n\n"},{"url":"/Blog/posts/0/","content":"函数gets和puts输入或输出一行字符串&emsp;&emsp;不是哥们，这多古早的函数了，还在讲？\n\n字符串输入函数gets\n格式：gets(字符数组)\n功能：从键盘输入一以回车结束的字符串放入字符数组中，并自动加‘\\0’\n说明：输入串长度应小于字符数组维数\n\n\n字符串输出函数puts\n格式：puts(字符数组)\n功能：向显示器输出字符串（输出完，换行）\n说明：字符数组必须以‘\\0’结束\n\n#include &lt;stdio.h&gt;int main( )&#123;    char string[80];    printf(“Input a string:”);    gets(string);    puts(string);&#125;\n输入:  How  are  you?输出:  How  are  you?  "},{"url":"/Blog/posts/0/","content":"转义字符详解1.1 转义字符的定义与特性转义字符是以 **反斜杠 \\ 开头** 的特殊字符序列，用于表示无法直接输入的字符（如换行符 \\n）或具有特殊含义的字符（如单引号 \\&#39;）\n核心规则：  \n\n转义字符 只代表一个字符（如 &#39;\\n&#39; 是单个换行符）。  \n八进制转义字符以 \\ 开头，后跟 **1~3位八进制数**（如 &#39;\\101&#39; 对应字符 &#39;A&#39;）\n十六进制转义字符以 \\x （x小写）开头，后跟 1~2位十六进制数（如 &#39;\\x13&#39; 合法，但 \\X13 非法）\n\n\n二、语法与陷阱：转义字符的合法性2.1 合法与非法形式对比\n\n\n类型\n合法示例\n非法示例\n错误原因\n\n\n\n八进制转义\n&#39;\\101&#39;（&#39;A&#39;）\n&#39;\\081&#39;\n八进制数中包含非法数字 8\n\n\n十六进制转义\n&#39;\\x13&#39;\n&#39;\\X13&#39;、&#39;0x13&#39;\n必须以小写 x 开头，不能用大写或 0x\n\n\n单字符限制\n&#39;\\n&#39;\n&#39;\\\\&#39;\n反斜杠需与后续字符组合成合法转义\n\n\n2.2 真题实战：判断合法字符常量题目：以下哪个是合法的字符常量？A. &#39;\\x13&#39;B. &#39;\\081&#39;C. &#39;65&#39;D. &quot;\\\\n&quot;  \n答案：A解析：  \n\nA 合法：\\x 后接两位十六进制数 1 和 3，对应 ASCII 码 19（控制字符）\nB 非法：八进制数 081 包含非法数字 8\nC 非法：单引号内只能包含一个字符，&#39;65&#39; 是两个字符\nD 非法：双引号包裹的是字符串，非字符常量\n\n\n三、进阶应用：转义字符的常见用途3.1 控制字符的表示\n换行符：&#39;\\n&#39;（ASCII 码 10）  \n回车符：&#39;\\r&#39;（ASCII 码 13）  \n制表符：&#39;\\t&#39;（ASCII 码 9）  \n空字符：&#39;\\0&#39;（字符串结束标志）\n\n3.2 特殊符号的转义\n\n\n场景\n示例\n说明\n\n\n\n单引号与反斜杠\n&#39;\\&#39;、&#39;\\\\&#39;\n避免语法歧义\n\n\n非打印字符\n&#39;\\x07&#39;（响铃）\n用于设备控制或调试\n\n\n\n四、调试与实践技巧4.1 使用转义字符处理字符串char str[] = &quot;Hello \\\\n World&quot;;  // 分开转义，需转义为 &quot;\\\\ \\\\n&quot;  \nprintf(&quot;%s&quot;, str);  // 输出：Hello \\n World（实际显示为两行）  \n\n4.2 真题解析：字符串长度计算题目：  \nchar s[10] = {&#39;A&#39;, &#39;\\0&#39;, &#39;B&#39;, &#39;C&#39;};  \nprintf(&quot;%d %d&quot;, sizeof(s), strlen(s));  \n\n输出：10 1解析：  \n\nsizeof(s) 返回数组总大小（10 字节）。  \nstrlen(s) 遇到 \\0 终止，仅计算前 1 个字符\n\n\n五、总结\n转义字符：用于表示特殊字符（如换行、空格）或非打印字符。  \n字符常量：严格遵循单引号包裹和单字符规则。  \n字符串常量：需用双引号包裹，自动添加 \\0 结束符\n\n🎯 记忆口诀：“反斜杠后跟特殊码，八进十六要分清；单引号里一个符，字符串尾藏 \\0！”  \n"},{"url":"/Blog/posts/0/","content":"第六章 字符之道——掌控文字的炼金术核心能力修炼：参悟字符三重境界通过本章修炼，你将获得：\n\n破解字符常量的”暗码玄机”\n掌握字符变量的”阴阳转化”之术\n驯服字符串函数的”十八般武艺”\n领悟输入输出的”文字搬运心法”\n参透常见陷阱的”破局之眼”\n\n知识脉络一、字符玄机\n字符常量：ASCII江湖中的神秘暗号（’A’的16进制密码）\n转义字符：反斜杠统领的特殊军团（\\n换行令旗、\\t空格飞梭）\n字符运算：字符与整数的隐秘交易（’9’ - ‘0’的数字解码术）\n\n二、字符串秘境\n字符串定义：字符数组的列阵之法（末尾\\0的隐形守卫）\n处理函数：\nstrlen：丈量字符串的游标卡尺\nstrcpy：字符串搬运的乾坤大挪移\nstrcat：字符串融合的太极推手\nstrcmp：字符较量的华山论剑\n\n\n常见误区：\n字符与字符串的”一字之差”\nsizeof与strlen的”时空迷局”\n数组越界的”无间地狱”\n\n\n\n三、输入输出要诀\n单字符操作：getchar&#x2F;putchar的闪电战法\n字符串操作：gets&#x2F;puts的阵地攻坚战\n格式化输入：scanf的字符过滤罗网\n\n修炼心法&emsp;&emsp;建议用”内存视角”观察字符存储，重点参悟字符串结束符\\0的隐形法则。特别注意字符数组越界的”雪崩效应”，善用调试器观察内存布局。警惕scanf读取字符串时的空格陷阱，掌握缓冲区清理的”回车清除术”。\n"},{"url":"/Blog/posts/0/","content":"\n\n\n优先级\n运算符\n名称&#x2F;功能\n结合性\n说明\n\n\n\n1\n()\n函数调用\n左到右\nfunc()\n\n\n2\n[]\n数组下标\n左到右\narr[3]\n\n\n3\n-&gt;\n指针访问结构体成员\n左到右\nptr-&gt;member\n\n\n4\n.\n结构体成员访问\n左到右\nstruct.member\n\n\n5\n++（后缀）\n后缀自增\n左到右\na++\n\n\n6\n--（后缀）\n后缀自减\n左到右\na--\n\n\n7\n++（前缀）\n前缀自增\n右到左\n++a\n\n\n8\n--（前缀）\n前缀自减\n右到左\n--a\n\n\n9\n+\n正号\n右到左\n5\n\n\n10\n-\n负号\n右到左\n-x\n\n\n11\n!\n逻辑非\n右到左\n!flag\n\n\n12\n~\n按位取反\n右到左\n~0x0F\n\n\n13\n&amp;\n取地址\n右到左\n&amp;var\n\n\n14\n*\n解引用（指针）\n右到左\n*ptr\n\n\n15\n(type)\n类型强制转换\n右到左\n(int)3.14\n\n\n16\nsizeof\n计算对象或类型大小\n右到左\nsizeof(int)\n\n\n17\n*\n乘法\n左到右\na * b\n\n\n18\n&#x2F;\n除法\n左到右\na &#x2F; b\n\n\n19\n%\n取模\n左到右\na % b（仅整数）\n\n\n20\n+\n加法\n左到右\na + b\n\n\n21\n-\n减法\n左到右\na - b\n\n\n22\n&lt;&lt;\n左移\n左到右\na &lt;&lt; 2\n\n\n23\n&gt;&gt;\n右移\n左到右\na &gt;&gt; 2\n\n\n24\n&lt;\n小于\n左到右\na &lt; b\n\n\n25\n&lt;&#x3D;\n小于等于\n左到右\na &lt;&#x3D; b\n\n\n26\n&gt;\n大于\n左到右\na &gt; b\n\n\n27\n&gt;&#x3D;\n大于等于\n左到右\na &gt;&#x3D; b\n\n\n28\n&#x3D;&#x3D;\n等于\n左到右\na &#x3D;&#x3D; b\n\n\n29\n!&#x3D;\n不等于\n左到右\na !&#x3D; b\n\n\n30\n&amp;\n按位与\n左到右\na &amp; b\n\n\n31\n^\n按位异或\n左到右\na ^ b\n\n\n32\n|\n按位或\n左到右\na | b\n\n\n33\n&amp;&amp;\n逻辑与\n左到右\na &amp;&amp; b（短路特性）\n\n\n34\n||\n逻辑或\n左到右\na || b（短路特性）\n\n\n35\n?:\n三目条件运算符\n右到左\na ? b : c\n\n\n36\n&#x3D;\n赋值\n右到左\na &#x3D; b\n\n\n37\n+&#x3D;\n加后赋值\n右到左\na +&#x3D; b\n\n\n38\n-&#x3D;\n减后赋值\n右到左\na -&#x3D; b\n\n\n39\n*&#x3D;\n乘后赋值\n右到左\na *&#x3D; b\n\n\n40\n&#x2F;&#x3D;\n除后赋值\n右到左\na &#x2F;&#x3D; b\n\n\n41\n%&#x3D;\n取模后赋值\n右到左\na %&#x3D; b\n\n\n42\n&lt;&lt;&#x3D;\n左移后赋值\n右到左\na &lt;&lt;&#x3D; b\n\n\n43\n&gt;&gt;&#x3D;\n右移后赋值\n右到左\na &gt;&gt;&#x3D; b\n\n\n44\n&amp;&#x3D;\n按位与后赋值\n右到左\na &amp;&#x3D; b\n\n\n45\n^&#x3D;\n按位异或后赋值\n右到左\na ^&#x3D; b\n\n\n46\n|&#x3D;\n按位或后赋值\n右到左\na |&#x3D; b\n\n\n47\n,\n逗号运算符\n左到右\na &#x3D; (b++, c &#x3D; 5, d)\n\n\n记忆技巧 ：\n\n单目 &gt; 算术 &gt; 移位 &gt; 关系 &gt; 逻辑 &gt; 赋值 。\n\n"},{"url":"/Blog/posts/0/","content":"二维数组和数组元素的地址\nint  a[3][4],*p;\n\n二维数组a由若干个一维数组组成\na[3][4]可视为由a[0]，a[1], a[2]这三个元素组成。其中a[0] ，a[1], a[2]又是由四个整型数组成的一维数组，可用a[0][0]，a[0][1]等来引用a[0]中的某个元素，其它以此类推。\n一维数组名代表了一个不可变的地址常量，所以a[0] ，a[1], a[2]也代表了一个地址常量，其值依次为二维数组每行第一个元素的地址，基类型就是数组元素的类型。所以a[0]++是非法的，而a[0]+1表示第一行第二个元素，即a[0][1]\n指针p的基类型与a[i]相同，所以p&#x3D;a[i]是合法的。因为a[i]&#x3D;&#x3D;(a+i)，所以p&#x3D;(a+i)\n\n说明\n1 维：&amp; (a[i]) &#x3D; &amp; ( (a+i) ); 注意 &amp; 抵消，得 &amp;a[i] &#x3D; (a+i )\n2 维; &amp;(a[i][j]) &#x3D; (*(a+i) + j);\n\n\n二维数组名也是一个地址常量（可理解为一个行指针）\n二维数组名是一个存放地址常量的指针，其值为二维数组第一个元素的地址。\na的值和a[0][0]相同，不过基类型不同。a的基类型为具有4个整型元素的数组类型，即a+0的值与a[0]相同，a+1的值与a[1]相同。\na+1中的数值1是4＊2个字节\n赋值语句p=a；是不合法的，因为p和a的基类型不同。\n\n二维数组元素的地址&emsp;&emsp;元素的地址有以下几种表示方式：\n\n&amp;a[i][j]\na[i]+j\n*(a+i)+j\n&amp;a[0][0]+i*4+j\na[0]+4*i+j\n\n注意&emsp;&emsp;&amp;a [i][j]，a[i]都是基类型为int类型，而a的基类型为具有四个元素的一维数组，所以a+i*4+j是错误的。\n则数组a中的元素a[i][j]有以下五种表达方式：\na[i][j]\n(*(a+i))[j]\n*(a[i]+j)\n((a+i)+j)\n(&amp;a[0][0]+4i+j)\n\n&emsp;&emsp;以上均等价于\n\n&amp;a[i][j]\na[i]+j\n*(a+i)+j\n&amp;a[0][0]+i*4+j\na[0]+4*i+j\n\n"},{"url":"/Blog/posts/0/","content":"第四章 选择结构程序设计——让程序学会思考学习目标：打造会”决策”的程序通过本章修炼，你将获得：\n\n掌握关系运算与逻辑运算的”判断之眼”\n理解条件表达式的”选择之心”\n熟练运用if语句家族（单分支&#x2F;双分支&#x2F;嵌套）\n玩转switch-case的”多选魔法阵”\n认识语句标号与goto语句的”古老秘术”\n\n知识脉络一、基础判断力培养\n关系运算：如同裁判员比较选手得分（&gt;, &lt;, &#x3D;&#x3D; 等）\n逻辑运算：像侦探推理的真伪判断（&amp;&amp;, ||, !）\n优先级法则：掌握运算顺序的”武林秘籍”\n\n二、选择结构三重奏\n条件表达式：构建决策树的种子\nif家族传奇：\n单分支：如果下雨就带伞的经典逻辑\n双分支：像自动售货机的”投币-出货”机制\n嵌套结构：多层关卡挑战的通关密码\n\n\n\n三、多路分支魔法阵\nswitch-case：\ncase：像不同钥匙打开对应锁孔\nbreak：防止”穿透效应”的防护罩\ndefault：兜底方案的保险箱\n\n\n\n四、古老控制术\n语句标号：给代码行装上定位器\ngoto语句：时空跳跃的传送门（慎用！）\n\n生活场景映射\n天气感知系统：像老中医看天穿衣\n智能导航：化身GPS里的决策精灵\n权限验证：做数字世界的守门人\n游戏AI：创造会思考的虚拟对手\n\n修炼指南&emsp;&emsp;建议用”流程图思维”观察程序走向，重点参悟if语句的嵌套心法和switch-case的匹配玄机。对于goto语句，了解其运行机制即可，现代编程应以结构化控制语句为正道，goto他是邪修!\n"},{"url":"/Blog/posts/0/","content":"一维数组的引用规定\n数组必须先定义，后使用\n只能逐个引用数组元素，不能整体引用\n对于字符数组可以整体输入输出\n\n#include &lt;stdio.h&gt;int main() &#123;    // 示例1：整型数组逐个使用    int numbers[3];    numbers[0] = 10;    numbers[1] = 20;    numbers[2] = 30;        printf(&quot;整型数组元素：\\n&quot;);    printf(&quot;numbers[0] = %d\\n&quot;, numbers[0]);    printf(&quot;numbers[1] = %d\\n&quot;, numbers[1]);    printf(&quot;numbers[2] = %d\\n&quot;, numbers[2]);    // 示例2：字符数组整体使用    char name[20];    printf(&quot;\\n请输入您的姓名：&quot;);    scanf(&quot;%s&quot;, name);  // 注意：字符数组作为参数时不需要&amp;    printf(&quot;您好，%s！\\n&quot;, name);    return 0;&#125;\n\n数组元素的表示形式：数组名[下标]\n其中：下标可以是常量或者整型表达式\n\n\n\n一维数组的引用方法通过数组名引用int a[5] = &#123;1, 2, 3, 4, 5&#125;;printf(&quot;%d\\n&quot;, a[0]);\n\n通过数组的首地址引用元素&emsp;&emsp;通过间接访问运算符*：引用地址所在存储单元。\na=&amp;a[0]*&amp;a[0]=*(a+0)=*a\n&emsp;&emsp;例如：以下语句的功能是逐个输出a数组元素中的值\nfor(k=0;k&lt;10;k++)    printf(“%d”,*(a+k));// 等价于for(k=0;k&lt;10;k++)    printf(“%d”,a[k]);\n\n通过指针引用一维数组元素float array[10],*p,k;p=a ;for(k=0;k&lt;10;k++)   printf(“%4d”,*(p+k));// 没有移动指针，等价于for(k=0;k&lt;10;k++)   printf(“%4d”, a[k]);\n\n用带下标的指针变量引用int *p,a[10],i;p=a;// 可以用以下三种表示a[i]的地址＆a[i]a+ip+i// 也可以用四种表达式来表示数组元素a[i]a[i]*(p+i)*(a+i)p[i]\n注意&emsp;&emsp;p[i]和 a[i]均可表示数组中的第i个元素，但是a和p有着明显的区别，a是不可变的，而p中的地址却是可以改变的。\n\na&#x3D;p , a++&emsp;&emsp;&emsp;&emsp;错误p++ ， p&#x3D;a ， p&#x3D;&amp;a[i]&emsp;&emsp;正确\n\n\n"},{"url":"/Blog/posts/0/","content":"数组&emsp;&emsp;数组是C语言所提供的最简单的构造类型。每个数组包含一组具有同一类型的变量，这些变量在内存中占有连续的存储单元。\n🎯 核心目标：掌握一维数组的定义规则、初始化方式及内存分配机制  \n\n一维数组的定义🔧 基本语法与规则类型名 数组名[整型常量表达式];\n示例代码如下：\nint a[5];\n\n定义三要素：  \n类型名（如 int, char）  \n数组名（合法标识符，如 a, score）  \n长度（常量表达式，如 5, N）\n\n\n\n📦 内存分配规则\n连续存储：数组元素在内存中占用连续空间  \n字节数计算：数组长度 * sizeof(元素类型)  \n地址特性：数组名是首地址常量，不可修改\n\n🚫 常见错误与避坑指南\n\n\n错误类型\n错误代码示例\n修复方法\n\n\n\n变量定义长度\nint n=5; int a[n];\n改为 int a[5];\n\n\n越界访问\na[5] = 10;（长度为5）\n确保下标范围 0到总长度-1，对于这个东西的个人理解就是超出范围了，数组是从0开始的，而我们习惯1开始\n\n\n非整型下标\nfloat a[3.5];\n下标必须为整型常量表达式\n\n\n\n一维数组的初始化✅ 初始化方式对比\n\n\n初始化类型\n语法示例\n内存效果\n\n\n\n完全初始化\nint a[5] = {1,2,3,4,5};\n全部元素赋初值\n\n\n部分初始化\nint a[5] = {1,2};\n未显式初始化的元素默认为0\n\n\n省略长度\nint a[] = {1,2,3};\n编译器自动推导长度为3\n\n\n静态数组默认值\nstatic int a[3];\n默认初始化为0\n\n\n🧠 关键点解析\n默认值规则：未初始化的局部数组元素值为随机数，静态数组默认为0  \n长度省略技巧：char c[] = {&#39;a&#39;}; 等价于 char c[1] = {&#39;a&#39;};  \n错误案例：int a[3] = {1,2,3,4}; ❌（初始值过多）\n\n\n说明\n数组不初始化，其元素值为随机数\n对static数组元素不赋初值，系统自动赋0\n部分元素赋初值，其余为0\n全部元素赋初值，可以不指定长度\n\n\n真题实战与调试技巧🧪 真题1（2005年4月）题目：以下能正确定义一维数组的选项是A. int a[5]={0,1,2,3,4,5};B. char a[]={&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;};C. char a={&#39;A&#39;,&#39;B&#39;,&#39;C&#39;};D. int a[5]=&quot;0123&quot;;  \n答案：B解析：  \n\nA选项初始值个数超过数组长度  \nC选项缺少数组定义符号[]  \nD选项字符串长度隐含+1（包含\\0），实际需长度为5\n\n\n🧪 真题2（数组越界陷阱）代码：  \nint a[3] = &#123;0&#125;; printf(&quot;%d&quot;, a[3]); // ❓输出什么？\n答案：输出随机值或导致崩溃解析：数组下标越界访问了未分配的内存  \n\n高级技巧与调试方法🔍 调试技巧：观察数组内存布局#include &lt;stdio.h&gt;int main() &#123;    int a[3] = &#123;0x11223344, 0x55667788, 0x99AABBCC&#125;;    for(int i=0; i&lt;3; i++) &#123;        printf(&quot;a[%d] 地址: %p 值: %x\\n&quot;, i, &amp;a[i], a[i]);    &#125;    return 0;&#125;\n输出示例（小端序机器）：  \na[0] 地址: 0061FF1C 值: 11223344  a[1] 地址: 0061FF20 值: 55667788  a[2] 地址: 0061FF24 值: 99AABBCC  \n结论：数组元素连续存储，地址递增  \n\n🎯 总结口诀数组定义三要素，连续存储按索引  初始化可省长度，静态默认零填充  越界访问风险高，调试打印看地址  真题多练避坑道，一维基础要打牢"},{"url":"/Blog/posts/0/","content":"&emsp;&emsp;若有以下定义\nint a[3][2],(*prt)[2]\n说明\n*号先与prt 结合，说明prt是指针变量\n然后*prt再与[2]结合，说明指针变量的基类型是包含2个元素的数组。3.＊prt的基类型与a相同所以：prt&#x3D;a是合法的赋值。prt+1相当于a+1相当于a[1]\n\n\n&emsp;&emsp;这里prt是一个指针变量，值可变，而a的值不可变。\n"},{"url":"/Blog/posts/0/","content":"二维数组元素的引用形式\n数组名[行索引][列索引]\n\n&emsp;&emsp;例如：\n double w[4][2];// 如下几种写法均正确//w[0][2]//w[i][j]//w[i+k][j+k]//====错误写法====//// w[0,2]// w[i j]// w(i+k)(j+k)"},{"url":"/Blog/posts/0/","content":"指针作为函数参数详解核心原理&emsp;&emsp;指针作为函数参数就像给函数发”定位器”，让函数能直接操作你家里的真实物品。普通参数传递相当于给函数一个物品的复印件，函数怎么改都不会影响原件；而指针参数相当于告诉函数”这个东西在你家客厅第三个柜子第四个抽屉”，函数可以直接修改原件。\n经典代码示例// 交换两个数的函数void swap(int *a, int *b) &#123;    int temp = *a;  // 取出a指向的值    *a = *b;        // 把b的值放回a的位置    *b = temp;      // 把临时值放回b的位置&#125;\n\n生活类比\n医院体检场景：医生直接修改你的原始报告单 vs 看复印件\n快递取件场景：直接给原始取件码 vs 复印取件码\n\n进阶应用场景// 计算矩形面积和周长的函数void calculateRectangle(int length, int width, int *area, int *perimeter) &#123;    *area = length * width;    *perimeter = 2 * (length + width);&#125;\n\n&emsp;&emsp;指针可以作为参数在主调函数和被调用函数之间传递数据，通过指针可以在被调用函数对调用函数中的变量进行引用，这也就使得通过形参改变对应实参的值有了可能，利用此形式就可以把两个或两个以上的数据从被调用的函数返回到调用函数。\n&emsp;&emsp;通过传送地址值，可以在被调用函数中对调用函数中的变量进行引用。\n"},{"url":"/Blog/posts/0/","content":"数组元素地址作为实参&emsp;&emsp;数组元素地址作为实参时，对应的形参也应当是基类型相同的指针变量。&emsp;&emsp;    数组名作为实参，对应的形参就应当是一个指针变量，并且指针的基类型必须与数组的类型一致。在函数中可以通过此指针变量来引用调用函数中对应的数组元素，从而达到对调用函数中对应的数组元素进行操作而改变其中的值。\n说明\n当数组名作为实参时，对应的形参除了是指针外，还可以用另外两种形式。\n\narrin(int *a)arrin(int a[])arrin(int a[M])\n&emsp;&emsp;对于后两种形式，虽然说明的形式与数组的说明相同，但C编译程序都将a处理成第一种的指针形式。\n\n当传递数组名时，在被调用函数中也同样可以用数组元素的形式来引用调用函数中对应的数组元素。这种只是形式上的相似，并不是整个数组可以传递给被调用函数。\n在被调用函数中，并没有为与数组名对应的形参开辟一串连续的空间，只是开辟了一个指针变量的存储单元。在被调用函数中所引用的数组元素就是实参数组中的元素。调用函数只是把数组的首地址传递给了形参指针，仍是遵循按“值”传递。\n\n"},{"url":"/Blog/posts/0/","content":"变量（从内存层次的重理解）&emsp;&emsp; 变量实质上代表了“内存中的某个存储单元”。若在内存中定义一个变量，那么这个变量的内存也就是确定的了。&emsp;&emsp; 即，定义一个变量，相当于插了个路标，指向一定的存储空间。&emsp;&emsp; 举个通俗一点的例子：假设你要去一栋教学楼中的一间教室，去取某个物品，此时你要去的教室名“4 教 101”便是 变量名，而教室钥匙便是 指针，教室便是 内存空间，你要取的物品便是 存储值。\n&emsp;&emsp; 我们在程序中只需要指出变量名（教室名），无需知道每个变量在内存中的具体位置（房间具体在教学楼的哪个位置），每个变量与具体地址的联系是由 C 语言编译系统来完成的。对于变量的存取操作就是对某个存储单元进行操作。这种  直接按变量的地址存取变量值  的方式就称作  直接存取 。\n\n指针&emsp;&emsp; 指针也可以视作一种变量，而这种变量用来存放的是内存地址。\nint *p;int a = 9063;p = &amp;a;\n\n\n间接存取&emsp;&emsp; 这种通过变量 p 到变量 a 的地址，然后再存取变量 a 的值的方式称为“间接存取”&emsp;&emsp; 指针变量 p 指向了变量 a 的含义是：指针 p 中存放了变量 a 的地址。\n定义&emsp;&emsp; 一个变量的地址\n指针变量&emsp;&emsp; 专门用来存放变量地址的变量。\n\n定义指针的形式类型名 *指针变量名1，*指针变量2，……int *pi,*pj;\n\n\n*是一个说明符，说明该变量指针变量。\n*不可省略，否则就变成了 int pi , pj（定义两个整型变量）。\n\ndouble *pd;// 只能是指向double型的变量，即存放double型变量的地址。char *s1,*s2;// 只能是指向char型的变量，即存放char型变量的地址。\n\n说明int **p , *s , k = 20;s = &amp;k;p = &amp;s;\n\n\n指针 p 的基类型是 int 类型的指针。\n&amp;是求地址运算符。\n因为基本数据类型 int、float、char 等所需存储的空间不同，所以需要定义指针变量的基类型。\n*是指针运算符，返回其所指对象的值。\n\n\n\n考点\n指针变量定义的形式：\n\n\n存储类型 类型名 指针变量名 1, 指针变量名 2,…\n\n\n也可以定义的同时赋初值:\n\n\n存储类型 类型名 *指针变量名 1 &#x3D; [初值],…\n\n\n“存储类型”可以缺省, 缺省时的存储类型为自动型 auto\n定义指针变量时，指针变量名前必须有一个*，在此它是定义指针变量的标志，不同于后面所说的“指针运算符”\n初值的形式通常有三种：“&amp;普通变量名”、“&amp;数组元素”和“数组名”\n\nC 语言规定：&emsp;&emsp; 数组名代表的是数组的首地址，即第一个元素的地址。\n"},{"url":"/Blog/posts/0/","content":"第八章 地址与指针——内存操控的九阳真经核心能力修炼：参悟三大指针秘术通过本章修炼，你将获得：\n\n掌握指针变量的”灵魂绑定”之术\n驯服内存地址的”瞬移大法”\n参透指针比较的”天机算盘”\n解锁函数参数的”隔空传物”神功\n破解指针移动的”循经走脉”奥秘\n\n知识脉络一、指针根基\n定义仪式：指针变量的声明如同签订生死契约（int *p;的玄机）\n初始化要诀：野指针是修真者的大忌（NULL指针的自我保护机制）\n取址秘法：&amp;运算符是打开内存之门的钥匙\n\n二、内存操控\n间接访问：*运算符的穿墙术（通过指针修改变量值）\n指针移动：步进法则如同打通任督二脉（+1不是加1！）\n地址比较：内存布局的华山论剑（&gt;、&lt;、&#x3D;&#x3D;的江湖规矩）\n\n三、实战应用场\n函数参数：地址传递的隔空传物（突破值传递的桎梏）\n数组操作：指针与数组的双生之谜（a[i]与*(a+i)的等价证明）\n字符串处理：char指针的游龙戏凤（字符串常量的正确打开方式）\n动态内存：malloc&#x2F;calloc的内功心法（未完待续…）\n\n修炼心法&emsp;&emsp;建议用”内存视角”观察程序运行，重点参悟指针移动的步进法则。警惕野指针的”走火入魔”，善用调试器观察内存地址变化。特别注意数组越界访问的”经脉错乱”，掌握空指针检查的”护体神功”。指针运算需遵循类型法则，切勿强行类型转换破坏内存安全。\n"},{"url":"/Blog/posts/0/","content":"自加运算符++、自减运算符–&emsp;&emsp;i++（或者i–），一般叫做后置自加（或自减），我更习惯叫作自增，表示在使用该表达式之后，将表达式值+1，或者-1。&emsp;&emsp;++i（或者–i），一般叫做前置自加（或自减），表示在使用该表达式之前，将表达式值+1，或者-1。\n&emsp;&emsp;个人记忆方法，++（或–）在前，就先+1（或者-1），然后使用这个值。++（或–）在后，就先使用这个值，然后+1（或者-1）。\n说明\n++和–仅适用于变量（整型，实型，字符型）和指针，不能用于常量和表达式。\n++和–运算符的结合方向是至右向左。\n\n考点\n自增、自减运算符只能用于变量，不能用于常量和表达式。5++、–(a+b)等都是非法的。\n自增、自减运算符和其它运算符混合使用时，其结合性为：至右向左。\n自增、自减运算符，无论作为前缀（++a，–a）还是后缀（ a ++， a –）运算符，对于变量本身来说自增1或自减1都具有相同的效果，但对表达式来说却有着不同的值。\n\n"},{"url":"/Blog/posts/0/","content":"赋值运算&emsp;&emsp;赋值符号“&#x3D;”就是赋值运算符，它的作用是将一个表达式的值赋给一个变量。赋值运算符的一般形式为：\n变量名 = 表达式a = 3;b = a + 5;c = sum(a, b);\n&emsp;&emsp;如果表达式值的类型，与被赋值变量的类型不一致，但都是数值型或字符型时，系统自动地将表达式的值转换成被赋值变量的数据类型，然后再赋值给变量.\n\n几点说明\n赋值运算符的优先级只高于逗号运算符，比其它的运算符优先级都低，且具有自右向左的结合性。\n赋值运算符不是数学中的“等于号”，而是进行“赋予”操作。\n表达式x&#x3D;y读作“将y的值赋给变量x”而不读作”x等于y“\n赋值运算符左边只能是变量，不能是常量或是表达式。如a+b&#x3D;c就是错误的。\n赋值运算符右边也可以是赋值表达式。如a&#x3D;b&#x3D;7+1,而a&#x3D;7+1&#x3D;b则是错误的。\n“&#x3D;”视作运算符，a&#x3D;19是一个表达式，C语言规定最左边变量中所得到的新值就是赋值表达式的值。\n\n\n复合赋值表达式&emsp;&emsp;复合赋值运算符是由赋值运算符之前再加一个双目运算符构成的。一般格式为：&emsp;&emsp;此表达式等价于：变量  &#x3D;  变量  双目运算符（表达式）&emsp;&emsp;当表达式为简单表达式时，表达式外的一对圆括号才可缺省，否则可能出错。\n&emsp;&emsp;例如：\na += 5; // 等价于 a = a + 5;a -= 5; // 等价于 a = a - 5;y *= x + 6; // 等价于 y = y * (x + 6);\n说明\n结合方向：赋值运算符的结合方向是自右向左。\n左侧必须是变量，不能是常量或者表达式。\n赋值转换规则：使赋值号右边表达式值自动转换成其左边变量的类型。\n赋值表达式的值与变量值相等,且可嵌套，例如：\n\na=b=c=5  //表达式值为5，a,b,c值为5a=(b=5)  //b=5;a=5a=5+(c=6)  //表达式值11，c=6,a=11a=(b=4)+(c=6)  //表达式值10，a=10,b=4,c=6a=(b=10)/(c=2)  //表达式值5，a=5,b=10,c=2\n\n\n赋值运算中的类型转换&emsp;&emsp;   在C语言的赋值表达式中，赋值号右边的值先转换成与左边的变量相同的类型，然后进行赋值。\n注意\n当赋值号左边的变量为短整型，右边的值为长整型时，短整型变量只能接受长整型数据低位上的两个字节的数据，高位上的数据将丢失。也就是说，右边的值不能超过短整型的数值范围。即长整型假设4字节，共有32位，短整型假设2字节，共16位，那么短整型只接受32位的后一半，低16位上的数据，高16位直接丢失。\n当赋值号左边的变量为无符号整型，右边的值为有符号整型时，则把内存中的内容原样复制。右边数据的范围不应超出左边变量可以接受的数据范围。同时要注意，这时负数将转换为正数。\n当赋值号左边的变量为有符号整型，右边的值为无符号整型时，复制的机制同上，这时，若符号位为1，将按负数处理。\n\n"},{"url":"/Blog/posts/0/","content":"形式&emsp;&emsp;一般来说，形式类似于：表达式1,表达式2,表达式n\n结合性&emsp;&emsp;从左向右\n优先级&emsp;&emsp;所有运算符中，逗号的优先级最低\n表达式的值&emsp;&emsp;逗号表达式的值是最后一个表达式的值。\n考点\n逗号运算符的结合性为从左到右。，先计算表达式1，最后计算表达式n，最后一个表达式的值即为该逗号表达式的值。\n逗号运算符在所有运算符中，优先级最低。\n\n"},{"url":"/Blog/posts/0/","content":"一、什么是标识符说到标识符，一般来说，能大概理解，但是不知道实质。但是，当我们将标识符换种说法——名称，应该就会好理解一点。名称可以用来干什么，名称可以给一个东西进行标记，比如箱子，瓶子这种。而标识符，就是用来标识变量、符号常量、函数、数组、类型、标号以及一些具有专门含义的有效字符序列。\n\n二、标识符的分类1. 关键字数据类型关键字 - 12个\n\n\n名称\n作用\n\n\n\nchar\n声明字符型变量（通常占1字节）。\n\n\nshort\n声明短整型变量（通常占2字节）。\n\n\nint\n声明基本整型变量（通常占4字节）。\n\n\nlong\n声明长整型变量（通常占4或8字节，取决于系统）。\n\n\nfloat\n声明单精度浮点型变量（占4字节）。\n\n\ndouble\n声明双精度浮点型变量（占8字节）。\n\n\nsigned\n声明有符号类型变量（默认整型为signed）。\n\n\nunsigned\n声明无符号类型变量（只能存储非负数）。\n\n\nstruct\n定义结构体（struct）类型。\n\n\nunion\n定义共用体（union）类型，同一内存区域存储不同成员。\n\n\nenum\n定义枚举类型（enum），用符号名表示整数值。\n\n\nvoid\n表示“无类型”，用于函数无返回值、无参数或空指针。\n\n\n控制语句关键字 - 12个\n\n\n名称\n作用\n\n\n\nif\n条件判断语句，执行分支代码（与else配合使用）。\n\n\nelse\n与if配合，表示条件不满足时的分支。\n\n\nswitch\n多路分支语句，根据表达式值选择执行不同case。\n\n\ncase\nswitch语句中的分支标签，匹配值后执行代码。\n\n\ndefault\nswitch语句中的默认分支（当无匹配case时执行）。\n\n\nfor\n循环语句，通过初始化、条件和迭代表达式控制循环。\n\n\nwhile\n循环语句，重复执行代码块直到条件不满足。\n\n\ndo...while\n循环语句，先执行代码块再检查条件（至少执行一次）。\n\n\nbreak\n跳出当前循环或switch语句。\n\n\ncontinue\n跳过当前循环迭代，直接进入下一轮循环。\n\n\ngoto\n无条件跳转到程序中带标签的语句（不推荐频繁使用）。\n\n\nreturn\n从函数中返回，并可携带返回值（若函数类型非void）。\n\n\n存储类型关键字 - 4个\n\n\n名称\n作用\n\n\n\nauto\n声明自动变量（默认类型，通常省略，存储在栈中，生命周期为作用域内）。\n\n\nextern\n声明变量或函数在其他文件中定义（用于引用外部定义的全局变量或函数）。\n\n\nregister\n建议编译器将变量存入寄存器（提高访问速度，但现代编译器较少依赖此关键字）。\n\n\nstatic\n声明静态变量：局部静态变量保留值，全局静态变量仅在本文件可见。\n\n\n其它关键字 - 4个\n\n\n名称\n作用\n\n\n\nconst\n声明常量，值不可修改（如const int MAX = 10;）。\n\n\nsizeof\n计算数据类型或变量的内存占用字节数（如sizeof(int)或sizeof(var)）。\n\n\ntypedef\n为类型定义别名（如typedef long long LL;）。\n\n\nvolatile\n声明变量可能被外部隐含修改（禁用编译器优化，如硬件寄存器或中断变量）。\n\n\n2. 预定义标识符&emsp;&emsp;一般指C语言提供的库函数名和编译预处理命令。比如常用的 printf 等等，这些名称是固定的用途，不可以在用来干别的。\n3. 用户标识符&emsp;&emsp;在编程时，需要用户给一些变量、函数、数组等命名，这类由用户根据需要自定义的标识符称为用户标识符。\n\n三、命名标识符的规范1. 组成\n只能由字母、数字、下划线组成，并且第一个字符必须是字母或者下划线\n大小写十分敏感，Sum，SUM，sum 是三个变量！\n不能使用之前提到的关键字\n\n2. 长度&emsp;&emsp;虽然我们现在的 VSC 理论上变量长度可以达到 1 K 字符以上，但是为了兼容旧平台等，所以建议不要超过 31 个字符。\n3. 命名原则\n一般要求是见到变量名字就要知道这个变量是干什么的\n不要用容易混淆的字符，比如网上很火的大写 I 和小写 l 之类的那种奇怪的东西\n\n"},{"url":"/Blog/posts/0/","content":"隐式转换&emsp;&emsp;个人理解隐式转换仅仅是在你不声明的情况下将数据类型进行转换的一种方式，是编译器的一种操作。\n\n运算转换：&emsp;&emsp;即不同数据之间进行运算时，如下：\n#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    float b = 20.5;    float c = a + b;    printf(&quot;%f&quot;, c ) ;    return 0;&#125;\n&emsp;&emsp;运行结果如下：\n30.500000\n&emsp;&emsp;在这个过程中，我们首先定义一个int型变量a，赋值为10，然后定义一个float型变量b，赋值为20.5，将float型变量c赋值为a+b，在运算时，编译器首先会将int型变量a转换为float型，然后与同类型变量b相加输出结果，并将其赋值给float型变量c。\n赋值转换：&emsp;&emsp;把一个值赋给与其不同的变量时，如下：\n#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    float b = a;    printf(&quot;%f&quot;, b ) ;    return 0;&#125;\n\n&emsp;&emsp;运行结果如下:\n10.000000\n\n&emsp;&emsp;在这个过程中，我们首先定义一个int型变量a，赋值为10，然后定义一个float型变量b，将int型变量a赋值给float型变量b，编译器首先会将int型变量a转换为float型，然后赋值给float型变量b，输出结果。\n输出转换：&emsp;&emsp;在输出时将格式转换为指定格式，如下：\n#include &lt;stdio.h&gt;int main()&#123;    char a = &#x27;B&#x27;;    printf(&quot;%d&quot;, a ) ;    return 0;&#125;\n\n&emsp;&emsp;运行结果如下：\n66\n&emsp;&emsp;上述代码在执行时，，首先定义一个字符变量a,，在执行输出时，将字符变量a转换为整型变量，然后输出结果。这一过程就是输出转化。\n\n形参与实参&emsp;&emsp;在讲解下一个过程之前，我们需要了解“实参”和“形参”这两个概念。这两个概念我们在后期会经常使用，要对他们有大致的了解。\n形参：定义：&emsp;&emsp;形参是函数定义时在函数头部声明的参数，用于接收调用函数时传入的实际值。它们是函数接口的一部分，定义了函数需要哪些输入数据。\n特点：\n占位符作用：形参在函数定义时只是一个占位符，不占用内存空间，直到函数被调用时才会分配存储空间。\n局部性：形参的作用域仅限于函数内部，函数执行结束后，形参的存储空间会被释放。\n值传递：在C语言中，形参默认是通过值传递（Call by Value）接收实参的值。这意味着形参是实参的副本，对形参的修改不会影响实参。\n类型匹配：形参的类型必须与实参的类型兼容，否则可能导致隐式类型转换或编译错误。\n\n示例：#include&lt;stdio.h&gt;void test(int a,int b) //此时a和b就是形参&#123;    int c = a + b;    return c;&#125;int main()&#123;    int x , y;    int c = test(x ,y);&#125;\n\n实参：定义&emsp;&emsp;实参是函数调用时传递给函数的具体值或表达式。它们是函数执行所需的实际数据。\n特点：\n来源：实参可以是常量、变量、表达式，甚至是其他函数的返回值。\n单向传递：实参的值被传递给形参，但形参的修改不会影响实参（除非通过指针传递地址）。\n类型匹配：实参的类型必须与形参的类型兼容，否则可能导致不可预期的结果。\n\n示例：#include&lt;stdio.h&gt;int main() &#123;    int x = 5, y = 10;  // x和y是实参    swap(x, y);         // 调用swap函数时，x和y作为实参传递    return 0;&#125;\n\n实参和形参的关系值传递&emsp;&emsp;在C语言中，函数参数默认是按值传递的。这意味着实参的值会被复制到形参中，形参和实参是两个独立的变量，存储在不同的内存位置。下面这个例子将会详细给你讲解：\n#include &lt;stdio.h&gt;void swap(int a, int b)&#123;    int temp = a;    a = b;    b = temp;    printf(&quot;Inside swap function: a = %d, b = %d\\n&quot;, a, b);&#125;int main()&#123;    int x = 5, y = 10;    printf(&quot;Before swap: x = %d, y = %d\\n&quot;, x, y);    swap(x, y);    printf(&quot;After swap: x = %d, y = %d\\n&quot;, x, y);    return 0;&#125;\n\n&emsp;&emsp;在上面这段代码中，函数swap()有两个参数，分别是int a 和 int b。这两个参数就是形参，而我们在main()中定义的 int x， int y是实参，而我们在main()中调用swap()函数时，将X和Y的值传递给a和b。形参相当于只是个用来占位的替身，实际上是实参在起作用。这个过程也就是形参和实参相当重要的一个特点：值传递\n地址传递&emsp;&emsp;如果需要让函数修改实参的值，可以通过传递变量的地址（指针）来实现。此时，形参是一个指针，指向实参的内存地址。指针这一块我们在这里大致举例即可，后面会详细讲解。\nvoid increment(int *a) &#123;    (*a) += 1;  // 通过指针修改实参的值    printf(&quot;Inside function: %d\\n&quot;, *a);&#125;int main() &#123;    int x = 5;    increment(&amp;x);  // 传递x的地址    printf(&quot;Outside function: %d\\n&quot;, x);  // x的值变为6    return 0;&#125;\n&emsp;&emsp;在这个例子中，函数increment()的参数是一个指针，指向一个int类型的变量。在函数中，通过指针修改实参的值。然后，在main()中，我们调用increment()函数，并传递x的地址。这样，函数修改了x的值，并返回了修改后的值。\n\n&emsp;&emsp;形参实参大致讲解到这，让我们继续回到隐式转换。\n\n函数调用转换：&emsp;&emsp;函数调用转换是指，当函数调用时，编译器会根据函数的参数和返回值类型，将实参转换为形参的类型。如下：\n#include &lt;stdio.h&gt;int add(int a, int b)&#123;    int c = a + b;    return c;&#125;int main()&#123;    char x = &#x27;A&#x27;, y = &#x27;B&#x27;;    int z = add(x, y);    printf(&quot;%d&quot;, z);    return 0;&#125;\n&emsp;&emsp;在这个例子中，函数add()的参数是int型，返回值也是int型。在main()中，定义了三个变量x，y，z，并调用add()函数，将字符变量x和y作为实参传递给add()函数。编译器会根据函数的参数和返回值类型，将x和y转换为int型，然后调用add()函数，将转换后的实参传递给形参a和b。函数add()返回一个int型结果，将结果赋给z。最后，输出z的值。\n\n运算转换规则&emsp;&emsp;以上就是C语言中基本的隐式转换，我们可以总结出运算转换的规则如下：不同类型的数据运算时先自动转换为同一类型，然后在执行其余步骤。\n\n不同数据类型之间转换顺序&emsp;&emsp;在这幅图中，横向的箭头是一定会执行的转换，纵向的箭头是不同类型之间执行的转换，同时，低位会向高位转换。例如：\nchar ch;int i;float f;double d;ch/i + f*d - (f+i)\n&emsp;&emsp;这一过程中，因为char型的ch一定会转换为int型，所以会先将ch转换为int型，然后float型的f一定转换给double型，转换完后，在运算时因为存在最高的double，所以int会向高位转换给double，所以最后输出的就是double。\n\n\n显式转换&emsp;&emsp;显式转换（又叫强制转换），是我们常用的一种方式。\n一般形式：(类型名)(表达式)\n\n&emsp;&emsp;比如：\nint a = 10;float b = (float)a;printf(&quot;%f&quot;,b);\n&emsp;&emsp;在上述代码中，我们把int型变量a强制转换为float型变量b，并输出b的值。\n说明：&emsp;&emsp;强制转换得到所需类型的中间变量，原变量不变。（在转换过程中，常伴有精度损失等问题，常发生在较高类型转换为较低类型时）\n"},{"url":"/Blog/posts/0/","content":"算术运算符的优先级&emsp;&emsp;一般来说，算术运算符的优先级顺序如下：\n\n\n\n类型\n常见运算符\n优先级\n\n\n\n\n()\n最高\n\n\n单目\n++, –\n其次\n\n\n双目\n+ , - , % , &#x2F; , *\n再次\n\n\n三目\n?:\n最后\n\n\n&emsp;&emsp;此处优先级类似于我们常说的“先乘除后加减”这种顺序\n算术运算符和圆括号的结合性&emsp;&emsp;所谓结合性是指，当一个操作数两侧的运算符具有相同的优先级时，该操作数是先与左边的运算符结合，还是先与右边的运算符结合。\n&emsp;&emsp;自左至右的结合方向，称为左结合性。反之，称为右结合性。&emsp;&emsp;结合性是Ｃ语言的独有概念。&emsp;&emsp;除 单目运算符、赋值运算符和条件运算符 是右结合性外，其它运算符都是左结合性。\n&emsp;&emsp;例如，算术运算符的结合方向是“自左至右”，即：&emsp;&emsp;在执行“a – b + c”时，变量b先与减号结合，执行“a - b”；&emsp;&emsp;然后再执行加c的运算。\n"},{"url":"/Blog/posts/0/","content":"第二章 前言咱们先来认识C语言的“ABC”——就像学英语要从26个字母开始一样，编程也要掌握基本要素。\n从Hello World开始本章开篇就带大家写最经典的“Hello World”程序。别看它只会打印一句话，这可是每个程序员的成人礼！通过这个小程序，我们会认识C语言的基本框架。\n完整示例🌰：\n#include &lt;stdio.h&gt;  // 引入输入输出库int main() &#123;        // 主函数入口    printf(&quot;Hello, World!\\n&quot;);  // 输出问候语    return 0;       // 返回成功状态&#125;\n\n数据的身份证接着要认识C语言里的数据类型，就像给不同种类的数据发“身份证”：\n\n整数用int（比如年龄）\n小数用float&#x2F;double（比如价格）\n字符用char（比如等级）\n\n代码示例🌰：\nint age = 20;            // 定义整型变量float price = 19.99f;     // 定义单精度浮点数char grade = &#x27;A&#x27;;         // 定义字符型\n\n还会学到怎么给这些数据起名字（变量命名规则），以及如何定义常量——那些程序里不能变的“铁规矩”。\n运算的秘密最后会揭秘各种运算符，包括加减乘除这些基础操作，还有自增自减这种C语言特色技巧。重点理解运算优先级，就像知道先穿袜子再穿鞋一样重要！\n优先级对比🌰：\nint a = 5 + 3 * 2;      // 先乘后加 结果=11\nint b = (5 + 3) * 2;    // 加号优先 结果=16\n\n"},{"url":"/Blog/posts/0/","content":"一、前言&emsp;&emsp;C语言属于是编程界的开山鼻祖了，所以有些东西超级原始，但也不是不好理解，在学习C语言之前有些工具我们要设置一下。当然，学校还在用Visual Studio 2010的版本，出去别人一问。哇！是清朝老古董欸！那就尴尬了，所以我用的是比较大众化，适合多平台开发的Visual Studio Code，不光可以用来写C，还可以写Python，JAVA，PHP，算是全能型选手了。\n\n二、[[安装Visual Studio Code]]&emsp;&emsp;首先打开他的官网，点击Download For Windows&emsp;&emsp;会下载一个安装包，打开之后一直点下一步就好，第一次打开之后可能是全英文界面，比如下面这样&emsp;&emsp;所以，我在这边提供了我的配置文件，下载下来后你只需要按照图示操作即可（不过就算是中文也建议用一下我的配置文件，因为我将别的设置部分也配置好了）\n点击下载配置文件&emsp;&emsp;配置文件下载之后，按下图导入&emsp;&emsp;然后选择我们下载的配置文件打开即可（之后我都会以VSC来简称这个软件）\n\n三、[[安装MSYS2]]&emsp;&emsp;之前我们安装的VSC只是个编辑软件，将相当于编辑任务清单，具体执行还是需要MSYS来进行配合。&emsp;&emsp;首先去MSYS2的官网去下载安装包，网站打开之后点击这个&emsp;&emsp;下载之后的安装包也是一直点下一步即可（如果要修改安装路径，不建议有中文，空格等等），在安装完成之后会打开一个命令行窗口，分别输入以下命令以更新基础数据库。（即一行一行执行）\npacman -Syupacman -Supacman -S --needed base-devel mingw-w64-x86_64-toolchain\n&emsp;&emsp;命令执行期间只要不报错即可，出现[Y&#x2F;n]的选项都填入Y然后点击回车即可，另说就是，这些命令行无法使用CTRL+C或者+V之类的快捷键，因为在这些系统之中ctrl+c属于停止运行的快捷键，所以一般还是不要用比较好，在界面右键选择copy和paste也可以复制粘贴。&emsp;&emsp;接下来打开我们刚才的安装路径，比如我是默认安装，就在C:&#x2F;msys64这个路径之下，找到mingw64文件夹，然后打开它里面的bin文件夹，复制整个文件路径C:\\msys64\\mingw64\\bin，在此电脑图标上右键，点击属性，打开设置之后点击高级系统属性&emsp;&emsp;在蓝色框里把路径填写进去之后点确定就可以，，然后按住win+r，打开运行窗口，输入CMD，输入如下命令测试安装是否成功。\ngcc -v\n&emsp;&emsp;出现如下内容便是安装成功&emsp;&emsp;至此，我们的基础设置已经全部完成！接下来就是正式学习C语言了。\n"}]